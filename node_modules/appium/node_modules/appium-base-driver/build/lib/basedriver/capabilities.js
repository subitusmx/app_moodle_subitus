'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _desiredCaps = require('./desired-caps');

var _appiumSupport = require('appium-support');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

// Takes primary caps object and merges it into a secondary caps object.
// (see https://www.w3.org/TR/webdriver/#dfn-merging-capabilities)
function mergeCaps() {
  var primary = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var secondary = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var result = _Object$assign({}, primary);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(_lodash2['default'].toPairs(secondary)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2);

      var _name = _step$value[0];
      var value = _step$value[1];

      // Overwriting is not allowed. Primary and secondary must have different properties (w3c rule 4.4)
      if (!_lodash2['default'].isUndefined(primary[_name])) {
        throw new Error('property ' + _name + ' should not exist on both primary and secondary');
      }
      result[_name] = value;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
}

// Validates caps against a set of constraints
function validateCaps(caps) {
  var constraints = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var skipPresenceConstraint = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

  if (!_lodash2['default'].isObject(caps)) {
    throw new Error('must be a JSON object');
  }

  constraints = _lodash2['default'].cloneDeep(constraints); // Defensive copy

  // Remove the 'presence' constraint if we're not checking for it
  if (skipPresenceConstraint) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _getIterator(_Object$keys(constraints)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var key = _step2.value;

        delete constraints[key].presence;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  var validationErrors = _desiredCaps.validator.validate(_lodash2['default'].pickBy(caps, _appiumSupport.util.hasValue), constraints, { fullMessages: false });

  if (validationErrors) {
    var message = [];
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = _getIterator(_lodash2['default'].toPairs(validationErrors)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _step3$value = _slicedToArray(_step3.value, 2);

        var attribute = _step3$value[0];
        var reasons = _step3$value[1];
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = _getIterator(reasons), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var reason = _step4.value;

            message.push(' ' + attribute + ' ' + reason + ',');
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4['return']) {
              _iterator4['return']();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    throw new Error(message.join(''));
  }

  // Return caps
  return caps;
}

// Standard, non-prefixed capabilities (see https://www.w3.org/TR/webdriver/#dfn-table-of-standard-capabilities)
var STANDARD_CAPS = ['browserName', 'browserVersion', 'platformName', 'acceptInsecureCerts', 'pageLoadStrategy', 'proxy', 'setWindowRect', 'timeouts', 'unhandledPromptBehavior'];

function isStandardCap(cap) {
  return !!_lodash2['default'].find(STANDARD_CAPS, function (standardCap) {
    return standardCap.toLowerCase() === ('' + cap).toLowerCase();
  });
}

// If the 'appium:' prefix was provided and it's a valid capability, strip out the prefix (see https://www.w3.org/TR/webdriver/#dfn-extension-capabilities)
// (NOTE: Method is destructive and mutates contents of caps)
function stripAppiumPrefixes(caps) {
  var prefix = 'appium:';
  var prefixedCaps = _lodash2['default'].filter(_lodash2['default'].keys(caps), function (cap) {
    return ('' + cap).startsWith(prefix);
  });
  var badPrefixedCaps = [];
  var unprefixedCaps = _lodash2['default'].filter(_lodash2['default'].keys(caps), function (cap) {
    return !cap.includes(':') && !isStandardCap(cap);
  });

  // Strip out the 'appium:' prefix
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = _getIterator(prefixedCaps), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var prefixedCap = _step5.value;

      var strippedCapName = prefixedCap.substr(prefix.length);

      // If it's standard capability that was prefixed, add it to an array of incorrectly prefixed capabilities
      if (isStandardCap(strippedCapName)) {
        badPrefixedCaps.push(strippedCapName);
      }

      // Strip out the prefix
      caps[strippedCapName] = caps[prefixedCap];
      delete caps[prefixedCap];
    }

    // If we found standard caps that were incorrectly prefixed, throw an exception (e.g.: don't accept 'appium:platformName', only accept just 'platformName')
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5['return']) {
        _iterator5['return']();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  if (badPrefixedCaps.length > 0) {
    throw new Error('The capabilities ' + JSON.stringify(badPrefixedCaps) + ' are standard capabilities and should not have the "appium:" prefix');
  }

  // If client provides non-prefixed, non-standard capabilities, warn them that these should be prefixed
  if (unprefixedCaps.length > 0) {
    _logger2['default'].warn(JSON.stringify(unprefixedCaps) + ' are not standard capabilities and should have an extension prefix');
  }
}

// Parse capabilities (based on https://www.w3.org/TR/webdriver/#processing-capabilities)
function parseCaps(caps) {
  var constraints = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var shouldValidateCaps = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

  if (!_lodash2['default'].isObject(caps)) {
    throw new Error('The capabilities argument was not valid for the following reason(s): "capabilities" must be a JSON object.');
  }

  var requiredCaps = caps.alwaysMatch;
  var _caps$firstMatch = caps.firstMatch;
  var allFirstMatchCaps = _caps$firstMatch === undefined ? [] : _caps$firstMatch;

  if (!_lodash2['default'].isObject(requiredCaps)) {
    requiredCaps = {};
  }

  // Reject 'firstMatch' argument if it's not an array (see spec #3.2)
  if (!_lodash2['default'].isArray(allFirstMatchCaps)) {
    throw new Error('The capabilities.firstMatch argument was not valid for the following reason(s): "capabilities.firstMatch" must be a JSON array or undefined');
  }

  // Strip out the 'appium:' prefix
  stripAppiumPrefixes(requiredCaps);
  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = _getIterator(allFirstMatchCaps), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var firstMatchCaps = _step6.value;

      stripAppiumPrefixes(firstMatchCaps);
    }
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6['return']) {
        _iterator6['return']();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  if (shouldValidateCaps) {
    requiredCaps = validateCaps(requiredCaps, constraints);
  }

  // Validate all of the first match capabilities (see spec #5)
  var validatedFirstMatchCaps = allFirstMatchCaps.map(function (firstMatchCaps) {
    try {
      // Validate firstMatch caps (don't validate 'presence' though, 'presence' is only validated in alwaysMatch)
      return shouldValidateCaps ? validateCaps(firstMatchCaps, constraints, true) : firstMatchCaps;
    } catch (e) {
      throw new Error('The capabilities.firstMatch argument was not valid for the following reason: ' + JSON.stringify(firstMatchCaps) + ' ' + e.message);
    }
  });

  // Try to merge requiredCaps with first match capabilities, break once it finds its first match (see spec #6)
  var matchedCaps = null;
  var _iteratorNormalCompletion7 = true;
  var _didIteratorError7 = false;
  var _iteratorError7 = undefined;

  try {
    for (var _iterator7 = _getIterator(validatedFirstMatchCaps), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
      var firstMatchCaps = _step7.value;

      try {
        matchedCaps = mergeCaps(requiredCaps, firstMatchCaps);
        if (matchedCaps) {
          break;
        }
      } catch (ign) {}
    }

    // If there was no match, use the de-facto requiredCaps on its own
  } catch (err) {
    _didIteratorError7 = true;
    _iteratorError7 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion7 && _iterator7['return']) {
        _iterator7['return']();
      }
    } finally {
      if (_didIteratorError7) {
        throw _iteratorError7;
      }
    }
  }

  matchedCaps = matchedCaps || requiredCaps;

  // Returns variables for testing purposes
  return { requiredCaps: requiredCaps, allFirstMatchCaps: allFirstMatchCaps, validatedFirstMatchCaps: validatedFirstMatchCaps, matchedCaps: matchedCaps };
}

// Calls parseCaps and just returns the matchedCaps variable
function processCapabilities(caps) {
  var constraints = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var shouldValidateCaps = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

  return parseCaps(caps, constraints, shouldValidateCaps).matchedCaps;
}

exports['default'] = { parseCaps: parseCaps, processCapabilities: processCapabilities, validateCaps: validateCaps, mergeCaps: mergeCaps };
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9iYXNlZHJpdmVyL2NhcGFiaWxpdGllcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O3NCQUFjLFFBQVE7Ozs7MkJBQ0ksZ0JBQWdCOzs2QkFDckIsZ0JBQWdCOztzQkFDckIsVUFBVTs7Ozs7O0FBSTFCLFNBQVMsU0FBUyxHQUFnQztNQUE5QixPQUFPLHlEQUFHLEVBQUU7TUFBRSxTQUFTLHlEQUFHLEVBQUU7O0FBQzlDLE1BQUksTUFBTSxHQUFHLGVBQWMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDOzs7Ozs7O0FBRXhDLHNDQUEwQixvQkFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLDRHQUFFOzs7VUFBdEMsS0FBSTtVQUFFLEtBQUs7OztBQUVuQixVQUFJLENBQUMsb0JBQUUsV0FBVyxDQUFDLE9BQU8sQ0FBQyxLQUFJLENBQUMsQ0FBQyxFQUFFO0FBQ2pDLGNBQU0sSUFBSSxLQUFLLGVBQWEsS0FBSSxxREFBa0QsQ0FBQztPQUNwRjtBQUNELFlBQU0sQ0FBQyxLQUFJLENBQUMsR0FBRyxLQUFLLENBQUM7S0FDdEI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFRCxTQUFPLE1BQU0sQ0FBQztDQUNmOzs7QUFHRCxTQUFTLFlBQVksQ0FBRSxJQUFJLEVBQW9EO01BQWxELFdBQVcseURBQUcsRUFBRTtNQUFFLHNCQUFzQix5REFBRyxLQUFLOztBQUMzRSxNQUFJLENBQUMsb0JBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ3JCLFVBQU0sSUFBSSxLQUFLLHlCQUF5QixDQUFDO0dBQzFDOztBQUVELGFBQVcsR0FBRyxvQkFBRSxTQUFTLENBQUMsV0FBVyxDQUFDLENBQUM7OztBQUd2QyxNQUFJLHNCQUFzQixFQUFFOzs7Ozs7QUFDMUIseUNBQWdCLGFBQVksV0FBVyxDQUFDLGlIQUFFO1lBQWpDLEdBQUc7O0FBQ1YsZUFBTyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDO09BQ2xDOzs7Ozs7Ozs7Ozs7Ozs7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OztBQUN2Qix1Q0FBMkIsdUJBQXVCLGlIQUFFO1VBQTNDLGNBQWM7O0FBQ3JCLFVBQUk7QUFDRixtQkFBVyxHQUFHLFNBQVMsQ0FBQyxZQUFZLEVBQUUsY0FBYyxDQUFDLENBQUM7QUFDdEQsWUFBSSxXQUFXLEVBQUU7QUFDZixnQkFBTTtTQUNQO09BQ0YsQ0FBQyxPQUFPLEdBQUcsRUFBRSxFQUFHO0tBQ2xCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHRCxhQUFXLEdBQUcsV0FBVyxJQUFJLFlBQVksQ0FBQzs7O0FBRzFDLFNBQU8sRUFBQyxZQUFZLEVBQVosWUFBWSxFQUFFLGlCQUFpQixFQUFqQixpQkFBaUIsRUFBRSx1QkFBdUIsRUFBdkIsdUJBQXVCLEVBQUUsV0FBVyxFQUFYLFdBQVcsRUFBQyxDQUFDO0NBQ2hGOzs7QUFHRCxTQUFTLG1CQUFtQixDQUFFLElBQUksRUFBK0M7TUFBN0MsV0FBVyx5REFBRyxFQUFFO01BQUUsa0JBQWtCLHlEQUFHLElBQUk7O0FBQzdFLFNBQU8sU0FBUyxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsa0JBQWtCLENBQUMsQ0FBQyxXQUFXLENBQUM7Q0FDckU7O3FCQUdjLEVBQUUsU0FBUyxFQUFULFNBQVMsRUFBRSxtQkFBbUIsRUFBbkIsbUJBQW1CLEVBQUUsWUFBWSxFQUFaLFlBQVksRUFBRSxTQUFTLEVBQVQsU0FBUyxFQUFFIiwiZmlsZSI6ImxpYi9iYXNlZHJpdmVyL2NhcGFiaWxpdGllcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyB2YWxpZGF0b3IgfSBmcm9tICcuL2Rlc2lyZWQtY2Fwcyc7XG5pbXBvcnQgeyB1dGlsIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5cbi8vIFRha2VzIHByaW1hcnkgY2FwcyBvYmplY3QgYW5kIG1lcmdlcyBpdCBpbnRvIGEgc2Vjb25kYXJ5IGNhcHMgb2JqZWN0LlxuLy8gKHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvd2ViZHJpdmVyLyNkZm4tbWVyZ2luZy1jYXBhYmlsaXRpZXMpXG5mdW5jdGlvbiBtZXJnZUNhcHMgKHByaW1hcnkgPSB7fSwgc2Vjb25kYXJ5ID0ge30pIHtcbiAgbGV0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIHByaW1hcnkpO1xuXG4gIGZvciAobGV0IFtuYW1lLCB2YWx1ZV0gb2YgXy50b1BhaXJzKHNlY29uZGFyeSkpIHtcbiAgICAvLyBPdmVyd3JpdGluZyBpcyBub3QgYWxsb3dlZC4gUHJpbWFyeSBhbmQgc2Vjb25kYXJ5IG11c3QgaGF2ZSBkaWZmZXJlbnQgcHJvcGVydGllcyAodzNjIHJ1bGUgNC40KVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwcmltYXJ5W25hbWVdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcm9wZXJ0eSAke25hbWV9IHNob3VsZCBub3QgZXhpc3Qgb24gYm90aCBwcmltYXJ5IGFuZCBzZWNvbmRhcnlgKTtcbiAgICB9XG4gICAgcmVzdWx0W25hbWVdID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBWYWxpZGF0ZXMgY2FwcyBhZ2FpbnN0IGEgc2V0IG9mIGNvbnN0cmFpbnRzXG5mdW5jdGlvbiB2YWxpZGF0ZUNhcHMgKGNhcHMsIGNvbnN0cmFpbnRzID0ge30sIHNraXBQcmVzZW5jZUNvbnN0cmFpbnQgPSBmYWxzZSkge1xuICBpZiAoIV8uaXNPYmplY3QoY2FwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG11c3QgYmUgYSBKU09OIG9iamVjdGApO1xuICB9XG5cbiAgY29uc3RyYWludHMgPSBfLmNsb25lRGVlcChjb25zdHJhaW50cyk7IC8vIERlZmVuc2l2ZSBjb3B5XG5cbiAgLy8gUmVtb3ZlIHRoZSAncHJlc2VuY2UnIGNvbnN0cmFpbnQgaWYgd2UncmUgbm90IGNoZWNraW5nIGZvciBpdFxuICBpZiAoc2tpcFByZXNlbmNlQ29uc3RyYWludCkge1xuICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhjb25zdHJhaW50cykpIHtcbiAgICAgIGRlbGV0ZSBjb25zdHJhaW50c1trZXldLnByZXNlbmNlO1xuICAgIH1cbiAgfVxuXG4gIGxldCB2YWxpZGF0aW9uRXJyb3JzID0gdmFsaWRhdG9yLnZhbGlkYXRlKF8ucGlja0J5KGNhcHMsIHV0aWwuaGFzVmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdWxsTWVzc2FnZXM6IGZhbHNlfSk7XG5cbiAgaWYgKHZhbGlkYXRpb25FcnJvcnMpIHtcbiAgICBsZXQgbWVzc2FnZSA9IFtdO1xuICAgIGZvciAobGV0IFthdHRyaWJ1dGUsIHJlYXNvbnNdIG9mIF8udG9QYWlycyh2YWxpZGF0aW9uRXJyb3JzKSkge1xuICAgICAgZm9yIChsZXQgcmVhc29uIG9mIHJlYXNvbnMpIHtcbiAgICAgICAgbWVzc2FnZS5wdXNoKGAgJHthdHRyaWJ1dGV9ICR7cmVhc29ufSxgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2Uuam9pbignJykpO1xuICB9XG5cbiAgLy8gUmV0dXJuIGNhcHNcbiAgcmV0dXJuIGNhcHM7XG59XG5cbi8vIFN0YW5kYXJkLCBub24tcHJlZml4ZWQgY2FwYWJpbGl0aWVzIChzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmRyaXZlci8jZGZuLXRhYmxlLW9mLXN0YW5kYXJkLWNhcGFiaWxpdGllcylcbmNvbnN0IFNUQU5EQVJEX0NBUFMgPSBbXG4gICdicm93c2VyTmFtZScsXG4gICdicm93c2VyVmVyc2lvbicsXG4gICdwbGF0Zm9ybU5hbWUnLFxuICAnYWNjZXB0SW5zZWN1cmVDZXJ0cycsXG4gICdwYWdlTG9hZFN0cmF0ZWd5JyxcbiAgJ3Byb3h5JyxcbiAgJ3NldFdpbmRvd1JlY3QnLFxuICAndGltZW91dHMnLFxuICAndW5oYW5kbGVkUHJvbXB0QmVoYXZpb3InXG5dO1xuXG5mdW5jdGlvbiBpc1N0YW5kYXJkQ2FwIChjYXApIHtcbiAgcmV0dXJuICEhXy5maW5kKFNUQU5EQVJEX0NBUFMsIChzdGFuZGFyZENhcCkgPT4gc3RhbmRhcmRDYXAudG9Mb3dlckNhc2UoKSA9PT0gYCR7Y2FwfWAudG9Mb3dlckNhc2UoKSk7XG59XG5cbi8vIElmIHRoZSAnYXBwaXVtOicgcHJlZml4IHdhcyBwcm92aWRlZCBhbmQgaXQncyBhIHZhbGlkIGNhcGFiaWxpdHksIHN0cmlwIG91dCB0aGUgcHJlZml4IChzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmRyaXZlci8jZGZuLWV4dGVuc2lvbi1jYXBhYmlsaXRpZXMpXG4vLyAoTk9URTogTWV0aG9kIGlzIGRlc3RydWN0aXZlIGFuZCBtdXRhdGVzIGNvbnRlbnRzIG9mIGNhcHMpXG5mdW5jdGlvbiBzdHJpcEFwcGl1bVByZWZpeGVzIChjYXBzKSB7XG4gIGNvbnN0IHByZWZpeCA9ICdhcHBpdW06JztcbiAgY29uc3QgcHJlZml4ZWRDYXBzID0gXy5maWx0ZXIoXy5rZXlzKGNhcHMpLCBjYXAgPT4gYCR7Y2FwfWAuc3RhcnRzV2l0aChwcmVmaXgpKTtcbiAgY29uc3QgYmFkUHJlZml4ZWRDYXBzID0gW107XG4gIGNvbnN0IHVucHJlZml4ZWRDYXBzID0gXy5maWx0ZXIoXy5rZXlzKGNhcHMpLCAoY2FwKSA9PiAoXG4gICAgIWNhcC5pbmNsdWRlcygnOicpICYmICFpc1N0YW5kYXJkQ2FwKGNhcClcbiAgKSk7XG5cbiAgLy8gU3RyaXAgb3V0IHRoZSAnYXBwaXVtOicgcHJlZml4XG4gIGZvciAobGV0IHByZWZpeGVkQ2FwIG9mIHByZWZpeGVkQ2Fwcykge1xuICAgIGNvbnN0IHN0cmlwcGVkQ2FwTmFtZSA9IHByZWZpeGVkQ2FwLnN1YnN0cihwcmVmaXgubGVuZ3RoKTtcblxuICAgIC8vIElmIGl0J3Mgc3RhbmRhcmQgY2FwYWJpbGl0eSB0aGF0IHdhcyBwcmVmaXhlZCwgYWRkIGl0IHRvIGFuIGFycmF5IG9mIGluY29ycmVjdGx5IHByZWZpeGVkIGNhcGFiaWxpdGllc1xuICAgIGlmIChpc1N0YW5kYXJkQ2FwKHN0cmlwcGVkQ2FwTmFtZSkpIHtcbiAgICAgIGJhZFByZWZpeGVkQ2Fwcy5wdXNoKHN0cmlwcGVkQ2FwTmFtZSk7XG4gICAgfVxuXG4gICAgLy8gU3RyaXAgb3V0IHRoZSBwcmVmaXhcbiAgICBjYXBzW3N0cmlwcGVkQ2FwTmFtZV0gPSBjYXBzW3ByZWZpeGVkQ2FwXTtcbiAgICBkZWxldGUgY2Fwc1twcmVmaXhlZENhcF07XG4gIH1cblxuICAvLyBJZiB3ZSBmb3VuZCBzdGFuZGFyZCBjYXBzIHRoYXQgd2VyZSBpbmNvcnJlY3RseSBwcmVmaXhlZCwgdGhyb3cgYW4gZXhjZXB0aW9uIChlLmcuOiBkb24ndCBhY2NlcHQgJ2FwcGl1bTpwbGF0Zm9ybU5hbWUnLCBvbmx5IGFjY2VwdCBqdXN0ICdwbGF0Zm9ybU5hbWUnKVxuICBpZiAoYmFkUHJlZml4ZWRDYXBzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBjYXBhYmlsaXRpZXMgJHtKU09OLnN0cmluZ2lmeShiYWRQcmVmaXhlZENhcHMpfSBhcmUgc3RhbmRhcmQgY2FwYWJpbGl0aWVzIGFuZCBzaG91bGQgbm90IGhhdmUgdGhlIFwiYXBwaXVtOlwiIHByZWZpeGApO1xuICB9XG5cbiAgLy8gSWYgY2xpZW50IHByb3ZpZGVzIG5vbi1wcmVmaXhlZCwgbm9uLXN0YW5kYXJkIGNhcGFiaWxpdGllcywgd2FybiB0aGVtIHRoYXQgdGhlc2Ugc2hvdWxkIGJlIHByZWZpeGVkXG4gIGlmICh1bnByZWZpeGVkQ2Fwcy5sZW5ndGggPiAwKSB7XG4gICAgbG9nLndhcm4oYCR7SlNPTi5zdHJpbmdpZnkodW5wcmVmaXhlZENhcHMpfSBhcmUgbm90IHN0YW5kYXJkIGNhcGFiaWxpdGllcyBhbmQgc2hvdWxkIGhhdmUgYW4gZXh0ZW5zaW9uIHByZWZpeGApO1xuICB9XG59XG5cbi8vIFBhcnNlIGNhcGFiaWxpdGllcyAoYmFzZWQgb24gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmRyaXZlci8jcHJvY2Vzc2luZy1jYXBhYmlsaXRpZXMpXG5mdW5jdGlvbiBwYXJzZUNhcHMgKGNhcHMsIGNvbnN0cmFpbnRzID0ge30sIHNob3VsZFZhbGlkYXRlQ2FwcyA9IHRydWUpIHtcbiAgaWYgKCFfLmlzT2JqZWN0KGNhcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2FwYWJpbGl0aWVzIGFyZ3VtZW50IHdhcyBub3QgdmFsaWQgZm9yIHRoZSBmb2xsb3dpbmcgcmVhc29uKHMpOiBcImNhcGFiaWxpdGllc1wiIG11c3QgYmUgYSBKU09OIG9iamVjdC4nKTtcbiAgfVxuXG4gIGxldCB7YWx3YXlzTWF0Y2g6IHJlcXVpcmVkQ2FwcywgZmlyc3RNYXRjaDogYWxsRmlyc3RNYXRjaENhcHMgPSBbXX0gPSBjYXBzO1xuXG4gIGlmICghXy5pc09iamVjdChyZXF1aXJlZENhcHMpKSB7XG4gICAgcmVxdWlyZWRDYXBzID0ge307XG4gIH1cblxuICAvLyBSZWplY3QgJ2ZpcnN0TWF0Y2gnIGFyZ3VtZW50IGlmIGl0J3Mgbm90IGFuIGFycmF5IChzZWUgc3BlYyAjMy4yKVxuICBpZiAoIV8uaXNBcnJheShhbGxGaXJzdE1hdGNoQ2FwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjYXBhYmlsaXRpZXMuZmlyc3RNYXRjaCBhcmd1bWVudCB3YXMgbm90IHZhbGlkIGZvciB0aGUgZm9sbG93aW5nIHJlYXNvbihzKTogXCJjYXBhYmlsaXRpZXMuZmlyc3RNYXRjaFwiIG11c3QgYmUgYSBKU09OIGFycmF5IG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgLy8gU3RyaXAgb3V0IHRoZSAnYXBwaXVtOicgcHJlZml4XG4gIHN0cmlwQXBwaXVtUHJlZml4ZXMocmVxdWlyZWRDYXBzKTtcbiAgZm9yIChsZXQgZmlyc3RNYXRjaENhcHMgb2YgYWxsRmlyc3RNYXRjaENhcHMpIHtcbiAgICBzdHJpcEFwcGl1bVByZWZpeGVzKGZpcnN0TWF0Y2hDYXBzKTtcbiAgfVxuXG4gIGlmIChzaG91bGRWYWxpZGF0ZUNhcHMpIHtcbiAgICByZXF1aXJlZENhcHMgPSB2YWxpZGF0ZUNhcHMocmVxdWlyZWRDYXBzLCBjb25zdHJhaW50cyk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBhbGwgb2YgdGhlIGZpcnN0IG1hdGNoIGNhcGFiaWxpdGllcyAoc2VlIHNwZWMgIzUpXG4gIGxldCB2YWxpZGF0ZWRGaXJzdE1hdGNoQ2FwcyA9IGFsbEZpcnN0TWF0Y2hDYXBzLm1hcCgoZmlyc3RNYXRjaENhcHMpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVmFsaWRhdGUgZmlyc3RNYXRjaCBjYXBzIChkb24ndCB2YWxpZGF0ZSAncHJlc2VuY2UnIHRob3VnaCwgJ3ByZXNlbmNlJyBpcyBvbmx5IHZhbGlkYXRlZCBpbiBhbHdheXNNYXRjaClcbiAgICAgIHJldHVybiBzaG91bGRWYWxpZGF0ZUNhcHMgPyB2YWxpZGF0ZUNhcHMoZmlyc3RNYXRjaENhcHMsIGNvbnN0cmFpbnRzLCB0cnVlKSA6IGZpcnN0TWF0Y2hDYXBzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGNhcGFiaWxpdGllcy5maXJzdE1hdGNoIGFyZ3VtZW50IHdhcyBub3QgdmFsaWQgZm9yIHRoZSBmb2xsb3dpbmcgcmVhc29uOiAke0pTT04uc3RyaW5naWZ5KGZpcnN0TWF0Y2hDYXBzKX0gJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUcnkgdG8gbWVyZ2UgcmVxdWlyZWRDYXBzIHdpdGggZmlyc3QgbWF0Y2ggY2FwYWJpbGl0aWVzLCBicmVhayBvbmNlIGl0IGZpbmRzIGl0cyBmaXJzdCBtYXRjaCAoc2VlIHNwZWMgIzYpXG4gIGxldCBtYXRjaGVkQ2FwcyA9IG51bGw7XG4gIGZvciAobGV0IGZpcnN0TWF0Y2hDYXBzIG9mIHZhbGlkYXRlZEZpcnN0TWF0Y2hDYXBzKSB7XG4gICAgdHJ5IHtcbiAgICAgIG1hdGNoZWRDYXBzID0gbWVyZ2VDYXBzKHJlcXVpcmVkQ2FwcywgZmlyc3RNYXRjaENhcHMpO1xuICAgICAgaWYgKG1hdGNoZWRDYXBzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGlnbikgeyB9XG4gIH1cblxuICAvLyBJZiB0aGVyZSB3YXMgbm8gbWF0Y2gsIHVzZSB0aGUgZGUtZmFjdG8gcmVxdWlyZWRDYXBzIG9uIGl0cyBvd25cbiAgbWF0Y2hlZENhcHMgPSBtYXRjaGVkQ2FwcyB8fCByZXF1aXJlZENhcHM7XG5cbiAgLy8gUmV0dXJucyB2YXJpYWJsZXMgZm9yIHRlc3RpbmcgcHVycG9zZXNcbiAgcmV0dXJuIHtyZXF1aXJlZENhcHMsIGFsbEZpcnN0TWF0Y2hDYXBzLCB2YWxpZGF0ZWRGaXJzdE1hdGNoQ2FwcywgbWF0Y2hlZENhcHN9O1xufVxuXG4vLyBDYWxscyBwYXJzZUNhcHMgYW5kIGp1c3QgcmV0dXJucyB0aGUgbWF0Y2hlZENhcHMgdmFyaWFibGVcbmZ1bmN0aW9uIHByb2Nlc3NDYXBhYmlsaXRpZXMgKGNhcHMsIGNvbnN0cmFpbnRzID0ge30sIHNob3VsZFZhbGlkYXRlQ2FwcyA9IHRydWUpIHtcbiAgcmV0dXJuIHBhcnNlQ2FwcyhjYXBzLCBjb25zdHJhaW50cywgc2hvdWxkVmFsaWRhdGVDYXBzKS5tYXRjaGVkQ2Fwcztcbn1cblxuXG5leHBvcnQgZGVmYXVsdCB7IHBhcnNlQ2FwcywgcHJvY2Vzc0NhcGFiaWxpdGllcywgdmFsaWRhdGVDYXBzLCBtZXJnZUNhcHMgfTtcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
