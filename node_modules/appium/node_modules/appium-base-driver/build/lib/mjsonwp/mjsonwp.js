'use strict';

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _appiumSupport = require('appium-support');

var _validators = require('./validators');

var _errors = require('./errors');

var _routes = require('./routes');

var _basedriverDriver = require('../basedriver/driver');

var _basedriverDriver2 = _interopRequireDefault(_basedriverDriver);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var log = _appiumSupport.logger.getLogger('MJSONWP');
var JSONWP_SUCCESS_STATUS_CODE = 0;
// TODO: Make this value configurable as a server side capability
var LOG_OBJ_LENGTH = 1024; // MAX LENGTH Logged to file / console

var MJSONWP = function MJSONWP() {
  _classCallCheck(this, MJSONWP);
};

function isSessionCommand(command) {
  return !_lodash2['default'].includes(_routes.NO_SESSION_ID_COMMANDS, command);
}

function wrapParams(paramSets, jsonObj) {
  /* There are commands like performTouch which take a single parameter (primitive type or array).
   * Some drivers choose to pass this parameter as a value (eg. [action1, action2...]) while others to
   * wrap it within an object(eg' {gesture:  [action1, action2...]}), which makes it hard to validate.
   * The wrap option in the spec enforce wrapping before validation, so that all params are wrapped at
   * the time they are validated and later passed to the commands.
   */
  var res = jsonObj;
  if (_lodash2['default'].isArray(jsonObj) || !_lodash2['default'].isObject(jsonObj)) {
    res = {};
    res[paramSets.wrap] = jsonObj;
  }
  return res;
}

function unwrapParams(paramSets, jsonObj) {
  /* There are commands like setNetworkConnection which send parameters wrapped inside a key such as
   * "parameters". This function unwraps them (eg. {"parameters": {"type": 1}} becomes {"type": 1}).
   */
  var res = jsonObj;
  if (_lodash2['default'].isObject(jsonObj)) {
    // some clients, like ruby, don't wrap
    if (jsonObj[paramSets.unwrap]) {
      res = jsonObj[paramSets.unwrap];
    }
  }
  return res;
}

function checkParams(paramSets, jsonObj) {
  var requiredParams = [];
  var optionalParams = [];
  var receivedParams = _lodash2['default'].keys(jsonObj);

  if (paramSets) {
    if (paramSets.required) {
      // we might have an array of parameters,
      // or an array of arrays of parameters, so standardize
      if (!_lodash2['default'].isArray(_lodash2['default'].first(paramSets.required))) {
        requiredParams = [paramSets.required];
      } else {
        requiredParams = paramSets.required;
      }
    }
    // optional parameters are just an array
    if (paramSets.optional) {
      optionalParams = paramSets.optional;
    }

    // If a function was provided as the 'validate' key, it will here be called with
    // jsonObj as the param. If it returns something falsy, verification will be
    // considered to have passed. If it returns something else, that will be the
    // argument to an error which is thrown to the user
    if (paramSets.validate) {
      var message = paramSets.validate(jsonObj);
      if (message) {
        throw new _errors.errors.BadParametersError(message, jsonObj);
      }
    }
  }

  // if we have no required parameters, all is well
  if (requiredParams.length === 0) {
    return;
  }

  // some clients pass in the session id in the params
  if (optionalParams.indexOf('sessionId') === -1) {
    optionalParams.push('sessionId');
  }

  // some clients pass in an element id in the params
  if (optionalParams.indexOf('id') === -1) {
    optionalParams.push('id');
  }

  // go through the required parameters and check against our arguments
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(requiredParams), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var params = _step.value;

      if (_lodash2['default'].difference(receivedParams, params, optionalParams).length === 0 && _lodash2['default'].difference(params, receivedParams).length === 0) {
        // we have a set of parameters that is correct
        // so short-circuit
        return;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  throw new _errors.errors.BadParametersError(paramSets, receivedParams);
}

/*
 * This method takes 3 pieces of data: request parameters ('requestParams'),
 * a request JSON body ('jsonObj'), and 'payloadParams', which is the section
 * from the route definition for a particular endpoint which has instructions
 * on handling parameters. This method returns an array of arguments which will
 * be applied to a command.
 */
function makeArgs(requestParams, jsonObj, payloadParams) {
  // We want to pass the "url" parameters to the commands in reverse order
  // since the command will sometimes want to ignore, say, the sessionId.
  // This has the effect of putting sessionId last, which means in JS we can
  // omit it from the function signature if we're not going to use it.
  var urlParams = _lodash2['default'].keys(requestParams).reverse();

  // In the simple case, the required parameters are a basic array in
  // payloadParams.required, so start there. It's possible that there are
  // multiple optional sets of required params, though, so handle that case
  // too.
  var requiredParams = payloadParams.required;
  if (_lodash2['default'].isArray(_lodash2['default'].first(payloadParams.required))) {
    // If there are optional sets of required params, then we will have an
    // array of arrays in payloadParams.required, so loop through each set and
    // pick the one that matches which JSON params were actually sent. We've
    // already been through validation so we're guaranteed to find a match.
    var keys = _lodash2['default'].keys(jsonObj);
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _getIterator(payloadParams.required), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var params = _step2.value;

        if (_lodash2['default'].without.apply(_lodash2['default'], [params].concat(_toConsumableArray(keys))).length === 0) {
          requiredParams = params;
          break;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  // Now we construct our list of arguments which will be passed to the command
  var args = undefined;
  if (_lodash2['default'].isFunction(payloadParams.makeArgs)) {
    // In the route spec, a particular route might define a 'makeArgs' function
    // if it wants full control over how to turn JSON parameters into command
    // arguments. So we pass it the JSON parameters and it returns an array
    // which will be applied to the handling command. For example if it returns
    // [1, 2, 3], we will call `command(1, 2, 3, ...)` (url params are separate
    // from JSON params and get concatenated below).
    args = payloadParams.makeArgs(jsonObj);
  } else {
    // Otherwise, collect all the required and optional params and flatten them
    // into an argument array
    args = _lodash2['default'].flatten(requiredParams).map(function (p) {
      return jsonObj[p];
    });
    if (payloadParams.optional) {
      args = args.concat(_lodash2['default'].flatten(payloadParams.optional).map(function (p) {
        return jsonObj[p];
      }));
    }
  }
  // Finally, get our url params (session id, element id, etc...) on the end of
  // the list
  args = args.concat(urlParams.map(function (u) {
    return requestParams[u];
  }));
  return args;
}

function getResponseForJsonwpError(err) {
  var httpStatus = 500;
  var httpResBody = {
    status: err.jsonwpCode,
    value: {
      message: err.message
    }
  };

  if ((0, _errors.isErrorType)(err, _errors.errors.BadParametersError)) {
    // respond with a 400 if we have bad parameters
    log.debug('Bad parameters: ' + err);
    httpStatus = 400;
    httpResBody = err.message;
  } else if ((0, _errors.isErrorType)(err, _errors.errors.NotYetImplementedError) || (0, _errors.isErrorType)(err, _errors.errors.NotImplementedError)) {
    // respond with a 501 if the method is not implemented
    httpStatus = 501;
  } else if ((0, _errors.isErrorType)(err, _errors.errors.NoSuchDriverError)) {
    // respond with a 404 if there is no driver for the session
    httpStatus = 404;
  }

  return [httpStatus, httpResBody];
}

function getResponseForW3CError(err) {
  var httpStatus = err.w3cStatus;
  var httpResBody = err.message;
  return [httpStatus, httpResBody];
}

function routeConfiguringFunction(driver) {
  if (!driver.sessionExists) {
    throw new Error('Drivers used with MJSONWP must implement `sessionExists`');
  }

  if (!(driver.executeCommand || driver.execute)) {
    throw new Error('Drivers used with MJSONWP must implement `executeCommand` or `execute`');
  }

  // return a function which will add all the routes to the driver
  return function (app) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = _getIterator(_lodash2['default'].toPairs(_routes.METHOD_MAP)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _step3$value = _slicedToArray(_step3.value, 2);

        var path = _step3$value[0];
        var methods = _step3$value[1];
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = _getIterator(_lodash2['default'].toPairs(methods)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _step4$value = _slicedToArray(_step4.value, 2);

            var method = _step4$value[0];
            var spec = _step4$value[1];

            // set up the express route handler
            buildHandler(app, method, path, spec, driver, isSessionCommand(spec.command));
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4['return']) {
              _iterator4['return']();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  };
}

function buildHandler(app, method, path, spec, driver, isSessCmd) {
  var _this = this;

  var asyncHandler = function asyncHandler(req, res) {
    var jsonObj, httpResBody, httpStatus, newSessionId, args, driverRes, actualErr, _getResponseForW3CError, _getResponseForW3CError2, _getResponseForJsonwpError, _getResponseForJsonwpError2;

    return _regeneratorRuntime.async(function asyncHandler$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          jsonObj = req.body;
          httpResBody = {};
          httpStatus = 200;
          newSessionId = undefined;
          context$2$0.prev = 4;

          if (!(isSessCmd && !driver.sessionExists(req.params.sessionId))) {
            context$2$0.next = 7;
            break;
          }

          throw new _errors.errors.NoSuchDriverError();

        case 7:
          if (!(isSessCmd && driverShouldDoJwpProxy(driver, req, spec.command))) {
            context$2$0.next = 11;
            break;
          }

          context$2$0.next = 10;
          return _regeneratorRuntime.awrap(doJwpProxy(driver, req, res));

        case 10:
          return context$2$0.abrupt('return');

        case 11:
          if (spec.command) {
            context$2$0.next = 13;
            break;
          }

          throw new _errors.errors.NotImplementedError();

        case 13:

          // wrap params if necessary
          if (spec.payloadParams && spec.payloadParams.wrap) {
            jsonObj = wrapParams(spec.payloadParams, jsonObj);
          }

          // unwrap params if necessary
          if (spec.payloadParams && spec.payloadParams.unwrap) {
            jsonObj = unwrapParams(spec.payloadParams, jsonObj);
          }

          // ensure that the json payload conforms to the spec
          checkParams(spec.payloadParams, jsonObj);
          // ensure the session the user is trying to use is valid

          // turn the command and json payload into an argument list for
          // the driver methods
          args = makeArgs(req.params, jsonObj, spec.payloadParams || []);
          driverRes = undefined;

          // validate command args according to MJSONWP
          if (_validators.validators[spec.command]) {
            _validators.validators[spec.command].apply(_validators.validators, _toConsumableArray(args));
          }
          // run the driver command wrapped inside the argument validators
          log.debug('Calling ' + driver.constructor.name + '.' + spec.command + '() with args: ' + _lodash2['default'].truncate(JSON.stringify(args), { length: LOG_OBJ_LENGTH }));

          if (!driver.executeCommand) {
            context$2$0.next = 26;
            break;
          }

          context$2$0.next = 23;
          return _regeneratorRuntime.awrap(driver.executeCommand.apply(driver, [spec.command].concat(_toConsumableArray(args))));

        case 23:
          driverRes = context$2$0.sent;
          context$2$0.next = 29;
          break;

        case 26:
          context$2$0.next = 28;
          return _regeneratorRuntime.awrap(driver.execute.apply(driver, [spec.command].concat(_toConsumableArray(args))));

        case 28:
          driverRes = context$2$0.sent;

        case 29:

          // unpack createSession response
          if (spec.command === 'createSession') {
            newSessionId = driverRes[0];
            if (driver.protocol === _basedriverDriver2['default'].DRIVER_PROTOCOL.MJSONWP) {
              driverRes = driverRes[1];
            } else if (driver.protocol === _basedriverDriver2['default'].DRIVER_PROTOCOL.W3C) {
              driverRes = {
                capabilities: driverRes[1]
              };
            }
          }
          // convert undefined to null, but leave all other values the same
          if (_lodash2['default'].isUndefined(driverRes)) {
            driverRes = null;
          }

          // delete should not return anything even if successful
          if (spec.command === 'deleteSession') {
            log.debug('Received response: ' + _lodash2['default'].truncate(JSON.stringify(driverRes), { length: LOG_OBJ_LENGTH }));
            log.debug('But deleting session, so not returning');
            driverRes = null;
          }

          // if the status is not 0,  throw the appropriate error for status code.

          if (!(_appiumSupport.util.hasValue(driverRes) && _appiumSupport.util.hasValue(driverRes.status) && parseInt(driverRes.status, 10) !== 0)) {
            context$2$0.next = 34;
            break;
          }

          throw (0, _errors.errorFromCode)(driverRes.status, driverRes.value);

        case 34:

          // Response status should be the status set by the driver response.
          if (driver.protocol === _basedriverDriver2['default'].DRIVER_PROTOCOL.MJSONWP) {
            httpResBody.status = _lodash2['default'].isNil(driverRes) || _lodash2['default'].isUndefined(driverRes.status) ? JSONWP_SUCCESS_STATUS_CODE : driverRes.status;
          }
          httpResBody.value = driverRes;
          log.debug('Responding to client with driver.' + spec.command + '() ' + ('result: ' + _lodash2['default'].truncate(JSON.stringify(driverRes), { length: LOG_OBJ_LENGTH })));
          context$2$0.next = 44;
          break;

        case 39:
          context$2$0.prev = 39;
          context$2$0.t0 = context$2$0['catch'](4);
          actualErr = context$2$0.t0;

          if ((0, _errors.isErrorType)(context$2$0.t0, _errors.errors.ProxyRequestError)) {
            log.error('Encountered internal error running command:  ' + JSON.stringify(context$2$0.t0) + ' ' + context$2$0.t0.stack);
            actualErr = context$2$0.t0.getActualError();
          } else if (!((0, _errors.isErrorType)(context$2$0.t0, _errors.MJSONWPError) || (0, _errors.isErrorType)(context$2$0.t0, _errors.errors.BadParametersError))) {
            log.error('Encountered internal error running command: ' + context$2$0.t0.stack);
            actualErr = new _errors.errors.UnknownError(context$2$0.t0);
          }
          // if anything goes wrong, figure out what our response should be
          // based on the type of error that we encountered
          if (driver.protocol === _basedriverDriver2['default'].DRIVER_PROTOCOL.W3C) {
            _getResponseForW3CError = getResponseForW3CError(actualErr);
            _getResponseForW3CError2 = _slicedToArray(_getResponseForW3CError, 2);
            httpStatus = _getResponseForW3CError2[0];
            httpResBody = _getResponseForW3CError2[1];
          } else {
            _getResponseForJsonwpError = getResponseForJsonwpError(actualErr);
            _getResponseForJsonwpError2 = _slicedToArray(_getResponseForJsonwpError, 2);
            httpStatus = _getResponseForJsonwpError2[0];
            httpResBody = _getResponseForJsonwpError2[1];
          }

        case 44:

          // decode the response, which is either a string or json
          if (_lodash2['default'].isString(httpResBody)) {
            res.status(httpStatus).send(httpResBody);
          } else {
            if (newSessionId) {
              if (driver.protocol === _basedriverDriver2['default'].DRIVER_PROTOCOL.W3C) {
                httpResBody.value.sessionId = newSessionId;
              } else {
                httpResBody.sessionId = newSessionId;
              }
            } else {
              httpResBody.sessionId = req.params.sessionId || null;
            }

            res.status(httpStatus).json(httpResBody);
          }

        case 45:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[4, 39]]);
  };
  // add the method to the app
  app[method.toLowerCase()](path, function (req, res) {
    _bluebird2['default'].resolve(asyncHandler(req, res)).done();
  });
}

function driverShouldDoJwpProxy(driver, req, command) {
  // drivers need to explicitly say when the proxy is active
  if (!driver.proxyActive(req.params.sessionId)) {
    return false;
  }

  // we should never proxy deleteSession because we need to give the containing
  // driver an opportunity to clean itself up
  if (command === 'deleteSession') {
    return false;
  }

  // validate avoidance schema, and say we shouldn't proxy if anything in the
  // avoid list matches our req
  var proxyAvoidList = driver.getProxyAvoidList(req.params.sessionId);
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = _getIterator(proxyAvoidList), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var avoidSchema = _step5.value;

      if (!_lodash2['default'].isArray(avoidSchema) || avoidSchema.length !== 2) {
        throw new Error('Proxy avoidance must be a list of pairs');
      }

      var _avoidSchema = _slicedToArray(avoidSchema, 2);

      var avoidMethod = _avoidSchema[0];
      var avoidPathRegex = _avoidSchema[1];

      if (!_lodash2['default'].includes(['GET', 'POST', 'DELETE'], avoidMethod)) {
        throw new Error('Unrecognized proxy avoidance method \'' + avoidMethod + '\'');
      }
      if (!(avoidPathRegex instanceof RegExp)) {
        throw new Error('Proxy avoidance path must be a regular expression');
      }
      var normalizedUrl = req.originalUrl.replace(/^\/wd\/hub/, '');
      if (avoidMethod === req.method && avoidPathRegex.test(normalizedUrl)) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5['return']) {
        _iterator5['return']();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  return true;
}

function doJwpProxy(driver, req, res) {
  return _regeneratorRuntime.async(function doJwpProxy$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        log.info('Driver proxy active, passing request on via HTTP proxy');

        // check that the inner driver has a proxy function

        if (driver.canProxy(req.params.sessionId)) {
          context$1$0.next = 3;
          break;
        }

        throw new Error('Trying to proxy to a JSONWP server but driver is unable to proxy');

      case 3:
        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(driver.executeCommand('proxyReqRes', req, res, req.params.sessionId));

      case 6:
        context$1$0.next = 15;
        break;

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](3);

        if (!(0, _errors.isErrorType)(context$1$0.t0, _errors.errors.ProxyRequestError)) {
          context$1$0.next = 14;
          break;
        }

        throw context$1$0.t0;

      case 14:
        throw new Error('Could not proxy. Proxy error: ' + context$1$0.t0.message);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 8]]);
}

exports.MJSONWP = MJSONWP;
exports.routeConfiguringFunction = routeConfiguringFunction;
exports.isSessionCommand = isSessionCommand;

// if this is a session command but we don't have a session,
// error out early (especially before proxying)

// if the driver is currently proxying commands to another JSONWP
// server, bypass all our checks and assume the upstream server knows
// what it's doing. But keep this in the try/catch block so if proxying
// itself fails, we give a message to the client. Of course we only
// want to do these when we have a session command; the Appium driver
// must be responsible for start/stop session, etc...

// if a command is not in our method map, it's because we
// have no plans to ever implement it
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9tanNvbndwL21qc29ud3AuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQUFjLFFBQVE7Ozs7NkJBQ08sZ0JBQWdCOzswQkFDbEIsY0FBYzs7c0JBQ3dCLFVBQVU7O3NCQUN4QixVQUFVOztnQ0FDdEMsc0JBQXNCOzs7O3dCQUMvQixVQUFVOzs7O0FBR3hCLElBQU0sR0FBRyxHQUFHLHNCQUFPLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUN4QyxJQUFNLDBCQUEwQixHQUFHLENBQUMsQ0FBQzs7QUFFckMsSUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDOztJQUV0QixPQUFPLFlBQVAsT0FBTzt3QkFBUCxPQUFPOzs7QUFFYixTQUFTLGdCQUFnQixDQUFFLE9BQU8sRUFBRTtBQUNsQyxTQUFPLENBQUMsb0JBQUUsUUFBUSxpQ0FBeUIsT0FBTyxDQUFDLENBQUM7Q0FDckQ7O0FBRUQsU0FBUyxVQUFVLENBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRTs7Ozs7OztBQU92QyxNQUFJLEdBQUcsR0FBRyxPQUFPLENBQUM7QUFDbEIsTUFBSSxvQkFBRSxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxvQkFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7QUFDOUMsT0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNULE9BQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDO0dBQy9CO0FBQ0QsU0FBTyxHQUFHLENBQUM7Q0FDWjs7QUFFRCxTQUFTLFlBQVksQ0FBRSxTQUFTLEVBQUUsT0FBTyxFQUFFOzs7O0FBSXpDLE1BQUksR0FBRyxHQUFHLE9BQU8sQ0FBQztBQUNsQixNQUFJLG9CQUFFLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTs7QUFFdkIsUUFBSSxPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFO0FBQzdCLFNBQUcsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FB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LENBQUMsRUFBRTtBQUN2RCxjQUFNLElBQUksS0FBSyw0Q0FBeUMsV0FBVyxRQUFJLENBQUM7T0FDekU7QUFDRCxVQUFJLEVBQUUsY0FBYyxZQUFZLE1BQU0sQ0FBQSxBQUFDLEVBQUU7QUFDdkMsY0FBTSxJQUFJLEtBQUssQ0FBQyxtREFBbUQsQ0FBQyxDQUFDO09BQ3RFO0FBQ0QsVUFBSSxhQUFhLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzlELFVBQUksV0FBVyxLQUFLLEdBQUcsQ0FBQyxNQUFNLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRTtBQUNwRSxlQUFPLEtBQUssQ0FBQztPQUNkO0tBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFRCxTQUFPLElBQUksQ0FBQztDQUNiOztBQUVELFNBQWUsVUFBVSxDQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRzs7OztBQUN6QyxXQUFHLENBQUMsSUFBSSxDQUFDLHdEQUF3RCxDQUFDLENBQUM7Ozs7WUFHOUQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQzs7Ozs7Y0FDbEMsSUFBSSxLQUFLLENBQUMsa0VBQWtFLENBQUM7Ozs7O3lDQUc3RSxNQUFNLENBQUMsY0FBYyxDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDOzs7Ozs7Ozs7O2FBRXRFLHlDQUFpQixlQUFPLGlCQUFpQixDQUFDOzs7Ozs7OztjQUd0QyxJQUFJLEtBQUssb0NBQWtDLGVBQUksT0FBTyxDQUFHOzs7Ozs7O0NBR3BFOztRQUdRLE9BQU8sR0FBUCxPQUFPO1FBQUUsd0JBQXdCLEdBQXhCLHdCQUF3QjtRQUFFLGdCQUFnQixHQUFoQixnQkFBZ0IiLCJmaWxlIjoibGliL21qc29ud3AvbWpzb253cC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBsb2dnZXIsIHV0aWwgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyB2YWxpZGF0b3JzIH0gZnJvbSAnLi92YWxpZGF0b3JzJztcbmltcG9ydCB7IGVycm9ycywgaXNFcnJvclR5cGUsIE1KU09OV1BFcnJvciwgZXJyb3JGcm9tQ29kZSB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IE1FVEhPRF9NQVAsIE5PX1NFU1NJT05fSURfQ09NTUFORFMgfSBmcm9tICcuL3JvdXRlcyc7XG5pbXBvcnQgQmFzZURyaXZlciBmcm9tICcuLi9iYXNlZHJpdmVyL2RyaXZlcic7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5cblxuY29uc3QgbG9nID0gbG9nZ2VyLmdldExvZ2dlcignTUpTT05XUCcpO1xuY29uc3QgSlNPTldQX1NVQ0NFU1NfU1RBVFVTX0NPREUgPSAwO1xuLy8gVE9ETzogTWFrZSB0aGlzIHZhbHVlIGNvbmZpZ3VyYWJsZSBhcyBhIHNlcnZlciBzaWRlIGNhcGFiaWxpdHlcbmNvbnN0IExPR19PQkpfTEVOR1RIID0gMTAyNDsgLy8gTUFYIExFTkdUSCBMb2dnZWQgdG8gZmlsZSAvIGNvbnNvbGVcblxuY2xhc3MgTUpTT05XUCB7fVxuXG5mdW5jdGlvbiBpc1Nlc3Npb25Db21tYW5kIChjb21tYW5kKSB7XG4gIHJldHVybiAhXy5pbmNsdWRlcyhOT19TRVNTSU9OX0lEX0NPTU1BTkRTLCBjb21tYW5kKTtcbn1cblxuZnVuY3Rpb24gd3JhcFBhcmFtcyAocGFyYW1TZXRzLCBqc29uT2JqKSB7XG4gIC8qIFRoZXJlIGFyZSBjb21tYW5kcyBsaWtlIHBlcmZvcm1Ub3VjaCB3aGljaCB0YWtlIGEgc2luZ2xlIHBhcmFtZXRlciAocHJpbWl0aXZlIHR5cGUgb3IgYXJyYXkpLlxuICAgKiBTb21lIGRyaXZlcnMgY2hvb3NlIHRvIHBhc3MgdGhpcyBwYXJhbWV0ZXIgYXMgYSB2YWx1ZSAoZWcuIFthY3Rpb24xLCBhY3Rpb24yLi4uXSkgd2hpbGUgb3RoZXJzIHRvXG4gICAqIHdyYXAgaXQgd2l0aGluIGFuIG9iamVjdChlZycge2dlc3R1cmU6ICBbYWN0aW9uMSwgYWN0aW9uMi4uLl19KSwgd2hpY2ggbWFrZXMgaXQgaGFyZCB0byB2YWxpZGF0ZS5cbiAgICogVGhlIHdyYXAgb3B0aW9uIGluIHRoZSBzcGVjIGVuZm9yY2Ugd3JhcHBpbmcgYmVmb3JlIHZhbGlkYXRpb24sIHNvIHRoYXQgYWxsIHBhcmFtcyBhcmUgd3JhcHBlZCBhdFxuICAgKiB0aGUgdGltZSB0aGV5IGFyZSB2YWxpZGF0ZWQgYW5kIGxhdGVyIHBhc3NlZCB0byB0aGUgY29tbWFuZHMuXG4gICAqL1xuICBsZXQgcmVzID0ganNvbk9iajtcbiAgaWYgKF8uaXNBcnJheShqc29uT2JqKSB8fCAhXy5pc09iamVjdChqc29uT2JqKSkge1xuICAgIHJlcyA9IHt9O1xuICAgIHJlc1twYXJhbVNldHMud3JhcF0gPSBqc29uT2JqO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHVud3JhcFBhcmFtcyAocGFyYW1TZXRzLCBqc29uT2JqKSB7XG4gIC8qIFRoZXJlIGFyZSBjb21tYW5kcyBsaWtlIHNldE5ldHdvcmtDb25uZWN0aW9uIHdoaWNoIHNlbmQgcGFyYW1ldGVycyB3cmFwcGVkIGluc2lkZSBhIGtleSBzdWNoIGFzXG4gICAqIFwicGFyYW1ldGVyc1wiLiBUaGlzIGZ1bmN0aW9uIHVud3JhcHMgdGhlbSAoZWcuIHtcInBhcmFtZXRlcnNcIjoge1widHlwZVwiOiAxfX0gYmVjb21lcyB7XCJ0eXBlXCI6IDF9KS5cbiAgICovXG4gIGxldCByZXMgPSBqc29uT2JqO1xuICBpZiAoXy5pc09iamVjdChqc29uT2JqKSkge1xuICAgIC8vIHNvbWUgY2xpZW50cywgbGlrZSBydWJ5LCBkb24ndCB3cmFwXG4gICAgaWYgKGpzb25PYmpbcGFyYW1TZXRzLnVud3JhcF0pIHtcbiAgICAgIHJlcyA9IGpzb25PYmpbcGFyYW1TZXRzLnVud3JhcF07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUGFyYW1zIChwYXJhbVNldHMsIGpzb25PYmopIHtcbiAgbGV0IHJlcXVpcmVkUGFyYW1zID0gW107XG4gIGxldCBvcHRpb25hbFBhcmFtcyA9IFtdO1xuICBsZXQgcmVjZWl2ZWRQYXJhbXMgPSBfLmtleXMoanNvbk9iaik7XG5cbiAgaWYgKHBhcmFtU2V0cykge1xuICAgIGlmIChwYXJhbVNldHMucmVxdWlyZWQpIHtcbiAgICAgIC8vIHdlIG1pZ2h0IGhhdmUgYW4gYXJyYXkgb2YgcGFyYW1ldGVycyxcbiAgICAgIC8vIG9yIGFuIGFycmF5IG9mIGFycmF5cyBvZiBwYXJhbWV0ZXJzLCBzbyBzdGFuZGFyZGl6ZVxuICAgICAgaWYgKCFfLmlzQXJyYXkoXy5maXJzdChwYXJhbVNldHMucmVxdWlyZWQpKSkge1xuICAgICAgICByZXF1aXJlZFBhcmFtcyA9IFtwYXJhbVNldHMucmVxdWlyZWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWlyZWRQYXJhbXMgPSBwYXJhbVNldHMucmVxdWlyZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9wdGlvbmFsIHBhcmFtZXRlcnMgYXJlIGp1c3QgYW4gYXJyYXlcbiAgICBpZiAocGFyYW1TZXRzLm9wdGlvbmFsKSB7XG4gICAgICBvcHRpb25hbFBhcmFtcyA9IHBhcmFtU2V0cy5vcHRpb25hbDtcbiAgICB9XG5cbiAgICAvLyBJZiBhIGZ1bmN0aW9uIHdhcyBwcm92aWRlZCBhcyB0aGUgJ3ZhbGlkYXRlJyBrZXksIGl0IHdpbGwgaGVyZSBiZSBjYWxsZWQgd2l0aFxuICAgIC8vIGpzb25PYmogYXMgdGhlIHBhcmFtLiBJZiBpdCByZXR1cm5zIHNvbWV0aGluZyBmYWxzeSwgdmVyaWZpY2F0aW9uIHdpbGwgYmVcbiAgICAvLyBjb25zaWRlcmVkIHRvIGhhdmUgcGFzc2VkLiBJZiBpdCByZXR1cm5zIHNvbWV0aGluZyBlbHNlLCB0aGF0IHdpbGwgYmUgdGhlXG4gICAgLy8gYXJndW1lbnQgdG8gYW4gZXJyb3Igd2hpY2ggaXMgdGhyb3duIHRvIHRoZSB1c2VyXG4gICAgaWYgKHBhcmFtU2V0cy52YWxpZGF0ZSkge1xuICAgICAgbGV0IG1lc3NhZ2UgPSBwYXJhbVNldHMudmFsaWRhdGUoanNvbk9iaik7XG4gICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkJhZFBhcmFtZXRlcnNFcnJvcihtZXNzYWdlLCBqc29uT2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBpZiB3ZSBoYXZlIG5vIHJlcXVpcmVkIHBhcmFtZXRlcnMsIGFsbCBpcyB3ZWxsXG4gIGlmIChyZXF1aXJlZFBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzb21lIGNsaWVudHMgcGFzcyBpbiB0aGUgc2Vzc2lvbiBpZCBpbiB0aGUgcGFyYW1zXG4gIGlmIChvcHRpb25hbFBhcmFtcy5pbmRleE9mKCdzZXNzaW9uSWQnKSA9PT0gLTEpIHtcbiAgICBvcHRpb25hbFBhcmFtcy5wdXNoKCdzZXNzaW9uSWQnKTtcbiAgfVxuXG4gIC8vIHNvbWUgY2xpZW50cyBwYXNzIGluIGFuIGVsZW1lbnQgaWQgaW4gdGhlIHBhcmFtc1xuICBpZiAob3B0aW9uYWxQYXJhbXMuaW5kZXhPZignaWQnKSA9PT0gLTEpIHtcbiAgICBvcHRpb25hbFBhcmFtcy5wdXNoKCdpZCcpO1xuICB9XG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgcmVxdWlyZWQgcGFyYW1ldGVycyBhbmQgY2hlY2sgYWdhaW5zdCBvdXIgYXJndW1lbnRzXG4gIGZvciAobGV0IHBhcmFtcyBvZiByZXF1aXJlZFBhcmFtcykge1xuICAgIGlmIChfLmRpZmZlcmVuY2UocmVjZWl2ZWRQYXJhbXMsIHBhcmFtcywgb3B0aW9uYWxQYXJhbXMpLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICBfLmRpZmZlcmVuY2UocGFyYW1zLCByZWNlaXZlZFBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyB3ZSBoYXZlIGEgc2V0IG9mIHBhcmFtZXRlcnMgdGhhdCBpcyBjb3JyZWN0XG4gICAgICAvLyBzbyBzaG9ydC1jaXJjdWl0XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBlcnJvcnMuQmFkUGFyYW1ldGVyc0Vycm9yKHBhcmFtU2V0cywgcmVjZWl2ZWRQYXJhbXMpO1xufVxuXG4vKlxuICogVGhpcyBtZXRob2QgdGFrZXMgMyBwaWVjZXMgb2YgZGF0YTogcmVxdWVzdCBwYXJhbWV0ZXJzICgncmVxdWVzdFBhcmFtcycpLFxuICogYSByZXF1ZXN0IEpTT04gYm9keSAoJ2pzb25PYmonKSwgYW5kICdwYXlsb2FkUGFyYW1zJywgd2hpY2ggaXMgdGhlIHNlY3Rpb25cbiAqIGZyb20gdGhlIHJvdXRlIGRlZmluaXRpb24gZm9yIGEgcGFydGljdWxhciBlbmRwb2ludCB3aGljaCBoYXMgaW5zdHJ1Y3Rpb25zXG4gKiBvbiBoYW5kbGluZyBwYXJhbWV0ZXJzLiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGFycmF5IG9mIGFyZ3VtZW50cyB3aGljaCB3aWxsXG4gKiBiZSBhcHBsaWVkIHRvIGEgY29tbWFuZC5cbiAqL1xuZnVuY3Rpb24gbWFrZUFyZ3MgKHJlcXVlc3RQYXJhbXMsIGpzb25PYmosIHBheWxvYWRQYXJhbXMpIHtcbiAgLy8gV2Ugd2FudCB0byBwYXNzIHRoZSBcInVybFwiIHBhcmFtZXRlcnMgdG8gdGhlIGNvbW1hbmRzIGluIHJldmVyc2Ugb3JkZXJcbiAgLy8gc2luY2UgdGhlIGNvbW1hbmQgd2lsbCBzb21ldGltZXMgd2FudCB0byBpZ25vcmUsIHNheSwgdGhlIHNlc3Npb25JZC5cbiAgLy8gVGhpcyBoYXMgdGhlIGVmZmVjdCBvZiBwdXR0aW5nIHNlc3Npb25JZCBsYXN0LCB3aGljaCBtZWFucyBpbiBKUyB3ZSBjYW5cbiAgLy8gb21pdCBpdCBmcm9tIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgaWYgd2UncmUgbm90IGdvaW5nIHRvIHVzZSBpdC5cbiAgbGV0IHVybFBhcmFtcyA9IF8ua2V5cyhyZXF1ZXN0UGFyYW1zKS5yZXZlcnNlKCk7XG5cbiAgLy8gSW4gdGhlIHNpbXBsZSBjYXNlLCB0aGUgcmVxdWlyZWQgcGFyYW1ldGVycyBhcmUgYSBiYXNpYyBhcnJheSBpblxuICAvLyBwYXlsb2FkUGFyYW1zLnJlcXVpcmVkLCBzbyBzdGFydCB0aGVyZS4gSXQncyBwb3NzaWJsZSB0aGF0IHRoZXJlIGFyZVxuICAvLyBtdWx0aXBsZSBvcHRpb25hbCBzZXRzIG9mIHJlcXVpcmVkIHBhcmFtcywgdGhvdWdoLCBzbyBoYW5kbGUgdGhhdCBjYXNlXG4gIC8vIHRvby5cbiAgbGV0IHJlcXVpcmVkUGFyYW1zID0gcGF5bG9hZFBhcmFtcy5yZXF1aXJlZDtcbiAgaWYgKF8uaXNBcnJheShfLmZpcnN0KHBheWxvYWRQYXJhbXMucmVxdWlyZWQpKSkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBvcHRpb25hbCBzZXRzIG9mIHJlcXVpcmVkIHBhcmFtcywgdGhlbiB3ZSB3aWxsIGhhdmUgYW5cbiAgICAvLyBhcnJheSBvZiBhcnJheXMgaW4gcGF5bG9hZFBhcmFtcy5yZXF1aXJlZCwgc28gbG9vcCB0aHJvdWdoIGVhY2ggc2V0IGFuZFxuICAgIC8vIHBpY2sgdGhlIG9uZSB0aGF0IG1hdGNoZXMgd2hpY2ggSlNPTiBwYXJhbXMgd2VyZSBhY3R1YWxseSBzZW50LiBXZSd2ZVxuICAgIC8vIGFscmVhZHkgYmVlbiB0aHJvdWdoIHZhbGlkYXRpb24gc28gd2UncmUgZ3VhcmFudGVlZCB0byBmaW5kIGEgbWF0Y2guXG4gICAgbGV0IGtleXMgPSBfLmtleXMoanNvbk9iaik7XG4gICAgZm9yIChsZXQgcGFyYW1zIG9mIHBheWxvYWRQYXJhbXMucmVxdWlyZWQpIHtcbiAgICAgIGlmIChfLndpdGhvdXQocGFyYW1zLCAuLi5rZXlzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVxdWlyZWRQYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyB3ZSBjb25zdHJ1Y3Qgb3VyIGxpc3Qgb2YgYXJndW1lbnRzIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjb21tYW5kXG4gIGxldCBhcmdzO1xuICBpZiAoXy5pc0Z1bmN0aW9uKHBheWxvYWRQYXJhbXMubWFrZUFyZ3MpKSB7XG4gICAgLy8gSW4gdGhlIHJvdXRlIHNwZWMsIGEgcGFydGljdWxhciByb3V0ZSBtaWdodCBkZWZpbmUgYSAnbWFrZUFyZ3MnIGZ1bmN0aW9uXG4gICAgLy8gaWYgaXQgd2FudHMgZnVsbCBjb250cm9sIG92ZXIgaG93IHRvIHR1cm4gSlNPTiBwYXJhbWV0ZXJzIGludG8gY29tbWFuZFxuICAgIC8vIGFyZ3VtZW50cy4gU28gd2UgcGFzcyBpdCB0aGUgSlNPTiBwYXJhbWV0ZXJzIGFuZCBpdCByZXR1cm5zIGFuIGFycmF5XG4gICAgLy8gd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBoYW5kbGluZyBjb21tYW5kLiBGb3IgZXhhbXBsZSBpZiBpdCByZXR1cm5zXG4gICAgLy8gWzEsIDIsIDNdLCB3ZSB3aWxsIGNhbGwgYGNvbW1hbmQoMSwgMiwgMywgLi4uKWAgKHVybCBwYXJhbXMgYXJlIHNlcGFyYXRlXG4gICAgLy8gZnJvbSBKU09OIHBhcmFtcyBhbmQgZ2V0IGNvbmNhdGVuYXRlZCBiZWxvdykuXG4gICAgYXJncyA9IHBheWxvYWRQYXJhbXMubWFrZUFyZ3MoanNvbk9iaik7XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCBjb2xsZWN0IGFsbCB0aGUgcmVxdWlyZWQgYW5kIG9wdGlvbmFsIHBhcmFtcyBhbmQgZmxhdHRlbiB0aGVtXG4gICAgLy8gaW50byBhbiBhcmd1bWVudCBhcnJheVxuICAgIGFyZ3MgPSBfLmZsYXR0ZW4ocmVxdWlyZWRQYXJhbXMpLm1hcCgocCkgPT4ganNvbk9ialtwXSk7XG4gICAgaWYgKHBheWxvYWRQYXJhbXMub3B0aW9uYWwpIHtcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChfLmZsYXR0ZW4ocGF5bG9hZFBhcmFtcy5vcHRpb25hbCkubWFwKChwKSA9PiBqc29uT2JqW3BdKSk7XG4gICAgfVxuICB9XG4gIC8vIEZpbmFsbHksIGdldCBvdXIgdXJsIHBhcmFtcyAoc2Vzc2lvbiBpZCwgZWxlbWVudCBpZCwgZXRjLi4uKSBvbiB0aGUgZW5kIG9mXG4gIC8vIHRoZSBsaXN0XG4gIGFyZ3MgPSBhcmdzLmNvbmNhdCh1cmxQYXJhbXMubWFwKCh1KSA9PiByZXF1ZXN0UGFyYW1zW3VdKSk7XG4gIHJldHVybiBhcmdzO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZUZvckpzb253cEVycm9yIChlcnIpIHtcbiAgbGV0IGh0dHBTdGF0dXMgPSA1MDA7XG4gIGxldCBodHRwUmVzQm9keSA9IHtcbiAgICBzdGF0dXM6IGVyci5qc29ud3BDb2RlLFxuICAgIHZhbHVlOiB7XG4gICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZVxuICAgIH1cbiAgfTtcblxuICBpZiAoaXNFcnJvclR5cGUoZXJyLCBlcnJvcnMuQmFkUGFyYW1ldGVyc0Vycm9yKSkge1xuICAgIC8vIHJlc3BvbmQgd2l0aCBhIDQwMCBpZiB3ZSBoYXZlIGJhZCBwYXJhbWV0ZXJzXG4gICAgbG9nLmRlYnVnKGBCYWQgcGFyYW1ldGVyczogJHtlcnJ9YCk7XG4gICAgaHR0cFN0YXR1cyA9IDQwMDtcbiAgICBodHRwUmVzQm9keSA9IGVyci5tZXNzYWdlO1xuICB9IGVsc2UgaWYgKGlzRXJyb3JUeXBlKGVyciwgZXJyb3JzLk5vdFlldEltcGxlbWVudGVkRXJyb3IpIHx8XG4gICAgICAgICAgICAgaXNFcnJvclR5cGUoZXJyLCBlcnJvcnMuTm90SW1wbGVtZW50ZWRFcnJvcikpIHtcbiAgICAvLyByZXNwb25kIHdpdGggYSA1MDEgaWYgdGhlIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWRcbiAgICBodHRwU3RhdHVzID0gNTAxO1xuICB9IGVsc2UgaWYgKGlzRXJyb3JUeXBlKGVyciwgZXJyb3JzLk5vU3VjaERyaXZlckVycm9yKSkge1xuICAgIC8vIHJlc3BvbmQgd2l0aCBhIDQwNCBpZiB0aGVyZSBpcyBubyBkcml2ZXIgZm9yIHRoZSBzZXNzaW9uXG4gICAgaHR0cFN0YXR1cyA9IDQwNDtcbiAgfVxuXG5cbiAgcmV0dXJuIFtodHRwU3RhdHVzLCBodHRwUmVzQm9keV07XG59XG5cbmZ1bmN0aW9uIGdldFJlc3BvbnNlRm9yVzNDRXJyb3IgKGVycikge1xuICBsZXQgaHR0cFN0YXR1cyA9IGVyci53M2NTdGF0dXM7XG4gIGxldCBodHRwUmVzQm9keSA9IGVyci5tZXNzYWdlO1xuICByZXR1cm4gW2h0dHBTdGF0dXMsIGh0dHBSZXNCb2R5XTtcbn1cblxuXG5cbmZ1bmN0aW9uIHJvdXRlQ29uZmlndXJpbmdGdW5jdGlvbiAoZHJpdmVyKSB7XG4gIGlmICghZHJpdmVyLnNlc3Npb25FeGlzdHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyaXZlcnMgdXNlZCB3aXRoIE1KU09OV1AgbXVzdCBpbXBsZW1lbnQgYHNlc3Npb25FeGlzdHNgJyk7XG4gIH1cblxuICBpZiAoIShkcml2ZXIuZXhlY3V0ZUNvbW1hbmQgfHwgZHJpdmVyLmV4ZWN1dGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEcml2ZXJzIHVzZWQgd2l0aCBNSlNPTldQIG11c3QgaW1wbGVtZW50IGBleGVjdXRlQ29tbWFuZGAgb3IgYGV4ZWN1dGVgJyk7XG4gIH1cblxuICAvLyByZXR1cm4gYSBmdW5jdGlvbiB3aGljaCB3aWxsIGFkZCBhbGwgdGhlIHJvdXRlcyB0byB0aGUgZHJpdmVyXG4gIHJldHVybiBmdW5jdGlvbiAoYXBwKSB7XG4gICAgZm9yIChsZXQgW3BhdGgsIG1ldGhvZHNdIG9mIF8udG9QYWlycyhNRVRIT0RfTUFQKSkge1xuICAgICAgZm9yIChsZXQgW21ldGhvZCwgc3BlY10gb2YgXy50b1BhaXJzKG1ldGhvZHMpKSB7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgZXhwcmVzcyByb3V0ZSBoYW5kbGVyXG4gICAgICAgIGJ1aWxkSGFuZGxlcihhcHAsIG1ldGhvZCwgcGF0aCwgc3BlYywgZHJpdmVyLCBpc1Nlc3Npb25Db21tYW5kKHNwZWMuY29tbWFuZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRIYW5kbGVyIChhcHAsIG1ldGhvZCwgcGF0aCwgc3BlYywgZHJpdmVyLCBpc1Nlc3NDbWQpIHtcbiAgbGV0IGFzeW5jSGFuZGxlciA9IGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICAgIGxldCBqc29uT2JqID0gcmVxLmJvZHk7XG4gICAgbGV0IGh0dHBSZXNCb2R5ID0ge307XG4gICAgbGV0IGh0dHBTdGF0dXMgPSAyMDA7XG4gICAgbGV0IG5ld1Nlc3Npb25JZDtcbiAgICB0cnkge1xuICAgICAgLy8gaWYgdGhpcyBpcyBhIHNlc3Npb24gY29tbWFuZCBidXQgd2UgZG9uJ3QgaGF2ZSBhIHNlc3Npb24sXG4gICAgICAvLyBlcnJvciBvdXQgZWFybHkgKGVzcGVjaWFsbHkgYmVmb3JlIHByb3h5aW5nKVxuICAgICAgaWYgKGlzU2Vzc0NtZCAmJiAhZHJpdmVyLnNlc3Npb25FeGlzdHMocmVxLnBhcmFtcy5zZXNzaW9uSWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuTm9TdWNoRHJpdmVyRXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIGRyaXZlciBpcyBjdXJyZW50bHkgcHJveHlpbmcgY29tbWFuZHMgdG8gYW5vdGhlciBKU09OV1BcbiAgICAgIC8vIHNlcnZlciwgYnlwYXNzIGFsbCBvdXIgY2hlY2tzIGFuZCBhc3N1bWUgdGhlIHVwc3RyZWFtIHNlcnZlciBrbm93c1xuICAgICAgLy8gd2hhdCBpdCdzIGRvaW5nLiBCdXQga2VlcCB0aGlzIGluIHRoZSB0cnkvY2F0Y2ggYmxvY2sgc28gaWYgcHJveHlpbmdcbiAgICAgIC8vIGl0c2VsZiBmYWlscywgd2UgZ2l2ZSBhIG1lc3NhZ2UgdG8gdGhlIGNsaWVudC4gT2YgY291cnNlIHdlIG9ubHlcbiAgICAgIC8vIHdhbnQgdG8gZG8gdGhlc2Ugd2hlbiB3ZSBoYXZlIGEgc2Vzc2lvbiBjb21tYW5kOyB0aGUgQXBwaXVtIGRyaXZlclxuICAgICAgLy8gbXVzdCBiZSByZXNwb25zaWJsZSBmb3Igc3RhcnQvc3RvcCBzZXNzaW9uLCBldGMuLi5cbiAgICAgIGlmIChpc1Nlc3NDbWQgJiYgZHJpdmVyU2hvdWxkRG9Kd3BQcm94eShkcml2ZXIsIHJlcSwgc3BlYy5jb21tYW5kKSkge1xuICAgICAgICBhd2FpdCBkb0p3cFByb3h5KGRyaXZlciwgcmVxLCByZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGEgY29tbWFuZCBpcyBub3QgaW4gb3VyIG1ldGhvZCBtYXAsIGl0J3MgYmVjYXVzZSB3ZVxuICAgICAgLy8gaGF2ZSBubyBwbGFucyB0byBldmVyIGltcGxlbWVudCBpdFxuICAgICAgaWYgKCFzcGVjLmNvbW1hbmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5Ob3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdyYXAgcGFyYW1zIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHNwZWMucGF5bG9hZFBhcmFtcyAmJiBzcGVjLnBheWxvYWRQYXJhbXMud3JhcCkge1xuICAgICAgICBqc29uT2JqID0gd3JhcFBhcmFtcyhzcGVjLnBheWxvYWRQYXJhbXMsIGpzb25PYmopO1xuICAgICAgfVxuXG4gICAgICAvLyB1bndyYXAgcGFyYW1zIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHNwZWMucGF5bG9hZFBhcmFtcyAmJiBzcGVjLnBheWxvYWRQYXJhbXMudW53cmFwKSB7XG4gICAgICAgIGpzb25PYmogPSB1bndyYXBQYXJhbXMoc3BlYy5wYXlsb2FkUGFyYW1zLCBqc29uT2JqKTtcbiAgICAgIH1cblxuICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGpzb24gcGF5bG9hZCBjb25mb3JtcyB0byB0aGUgc3BlY1xuICAgICAgY2hlY2tQYXJhbXMoc3BlYy5wYXlsb2FkUGFyYW1zLCBqc29uT2JqKTtcbiAgICAgIC8vIGVuc3VyZSB0aGUgc2Vzc2lvbiB0aGUgdXNlciBpcyB0cnlpbmcgdG8gdXNlIGlzIHZhbGlkXG5cbiAgICAgIC8vIHR1cm4gdGhlIGNvbW1hbmQgYW5kIGpzb24gcGF5bG9hZCBpbnRvIGFuIGFyZ3VtZW50IGxpc3QgZm9yXG4gICAgICAvLyB0aGUgZHJpdmVyIG1ldGhvZHNcbiAgICAgIGxldCBhcmdzID0gbWFrZUFyZ3MocmVxLnBhcmFtcywganNvbk9iaiwgc3BlYy5wYXlsb2FkUGFyYW1zIHx8IFtdKTtcbiAgICAgIGxldCBkcml2ZXJSZXM7XG4gICAgICAvLyB2YWxpZGF0ZSBjb21tYW5kIGFyZ3MgYWNjb3JkaW5nIHRvIE1KU09OV1BcbiAgICAgIGlmICh2YWxpZGF0b3JzW3NwZWMuY29tbWFuZF0pIHtcbiAgICAgICAgdmFsaWRhdG9yc1tzcGVjLmNvbW1hbmRdKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgICAgLy8gcnVuIHRoZSBkcml2ZXIgY29tbWFuZCB3cmFwcGVkIGluc2lkZSB0aGUgYXJndW1lbnQgdmFsaWRhdG9yc1xuICAgICAgbG9nLmRlYnVnKGBDYWxsaW5nICR7ZHJpdmVyLmNvbnN0cnVjdG9yLm5hbWV9LiR7c3BlYy5jb21tYW5kfSgpIHdpdGggYXJnczogYCArXG4gICAgICAgICAgICAgICAgXy50cnVuY2F0ZShKU09OLnN0cmluZ2lmeShhcmdzKSwge2xlbmd0aDogTE9HX09CSl9MRU5HVEh9KSk7XG5cbiAgICAgIGlmIChkcml2ZXIuZXhlY3V0ZUNvbW1hbmQpIHtcbiAgICAgICAgZHJpdmVyUmVzID0gYXdhaXQgZHJpdmVyLmV4ZWN1dGVDb21tYW5kKHNwZWMuY29tbWFuZCwgLi4uYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcml2ZXJSZXMgPSBhd2FpdCBkcml2ZXIuZXhlY3V0ZShzcGVjLmNvbW1hbmQsIC4uLmFyZ3MpO1xuICAgICAgfVxuXG4gICAgICAvLyB1bnBhY2sgY3JlYXRlU2Vzc2lvbiByZXNwb25zZVxuICAgICAgaWYgKHNwZWMuY29tbWFuZCA9PT0gJ2NyZWF0ZVNlc3Npb24nKSB7XG4gICAgICAgIG5ld1Nlc3Npb25JZCA9IGRyaXZlclJlc1swXTtcbiAgICAgICAgaWYgKGRyaXZlci5wcm90b2NvbCA9PT0gQmFzZURyaXZlci5EUklWRVJfUFJPVE9DT0wuTUpTT05XUCkge1xuICAgICAgICAgIGRyaXZlclJlcyA9IGRyaXZlclJlc1sxXTtcbiAgICAgICAgfSBlbHNlIGlmIChkcml2ZXIucHJvdG9jb2wgPT09IEJhc2VEcml2ZXIuRFJJVkVSX1BST1RPQ09MLlczQykge1xuICAgICAgICAgIGRyaXZlclJlcyA9IHtcbiAgICAgICAgICAgIGNhcGFiaWxpdGllczogZHJpdmVyUmVzWzFdLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNvbnZlcnQgdW5kZWZpbmVkIHRvIG51bGwsIGJ1dCBsZWF2ZSBhbGwgb3RoZXIgdmFsdWVzIHRoZSBzYW1lXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChkcml2ZXJSZXMpKSB7XG4gICAgICAgIGRyaXZlclJlcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIGRlbGV0ZSBzaG91bGQgbm90IHJldHVybiBhbnl0aGluZyBldmVuIGlmIHN1Y2Nlc3NmdWxcbiAgICAgIGlmIChzcGVjLmNvbW1hbmQgPT09ICdkZWxldGVTZXNzaW9uJykge1xuICAgICAgICBsb2cuZGVidWcoYFJlY2VpdmVkIHJlc3BvbnNlOiAke18udHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoZHJpdmVyUmVzKSwge2xlbmd0aDogTE9HX09CSl9MRU5HVEh9KX1gKTtcbiAgICAgICAgbG9nLmRlYnVnKCdCdXQgZGVsZXRpbmcgc2Vzc2lvbiwgc28gbm90IHJldHVybmluZycpO1xuICAgICAgICBkcml2ZXJSZXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGUgc3RhdHVzIGlzIG5vdCAwLCAgdGhyb3cgdGhlIGFwcHJvcHJpYXRlIGVycm9yIGZvciBzdGF0dXMgY29kZS5cbiAgICAgIGlmICh1dGlsLmhhc1ZhbHVlKGRyaXZlclJlcykgJiYgdXRpbC5oYXNWYWx1ZShkcml2ZXJSZXMuc3RhdHVzKSAmJiBwYXJzZUludChkcml2ZXJSZXMuc3RhdHVzLCAxMCkgIT09IDApIHtcbiAgICAgICAgdGhyb3cgZXJyb3JGcm9tQ29kZShkcml2ZXJSZXMuc3RhdHVzLCBkcml2ZXJSZXMudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXNwb25zZSBzdGF0dXMgc2hvdWxkIGJlIHRoZSBzdGF0dXMgc2V0IGJ5IHRoZSBkcml2ZXIgcmVzcG9uc2UuXG4gICAgICBpZiAoZHJpdmVyLnByb3RvY29sID09PSBCYXNlRHJpdmVyLkRSSVZFUl9QUk9UT0NPTC5NSlNPTldQKSB7XG4gICAgICAgIGh0dHBSZXNCb2R5LnN0YXR1cyA9IChfLmlzTmlsKGRyaXZlclJlcykgfHwgXy5pc1VuZGVmaW5lZChkcml2ZXJSZXMuc3RhdHVzKSkgPyBKU09OV1BfU1VDQ0VTU19TVEFUVVNfQ09ERSA6IGRyaXZlclJlcy5zdGF0dXM7XG4gICAgICB9XG4gICAgICBodHRwUmVzQm9keS52YWx1ZSA9IGRyaXZlclJlcztcbiAgICAgIGxvZy5kZWJ1ZyhgUmVzcG9uZGluZyB0byBjbGllbnQgd2l0aCBkcml2ZXIuJHtzcGVjLmNvbW1hbmR9KCkgYCArXG4gICAgICAgICAgICAgICBgcmVzdWx0OiAke18udHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoZHJpdmVyUmVzKSwge2xlbmd0aDogTE9HX09CSl9MRU5HVEh9KX1gKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxldCBhY3R1YWxFcnIgPSBlcnI7XG4gICAgICBpZiAoaXNFcnJvclR5cGUoZXJyLCBlcnJvcnMuUHJveHlSZXF1ZXN0RXJyb3IpKSB7XG4gICAgICAgIGxvZy5lcnJvcihgRW5jb3VudGVyZWQgaW50ZXJuYWwgZXJyb3IgcnVubmluZyBjb21tYW5kOiAgJHtKU09OLnN0cmluZ2lmeShlcnIpfSAke2Vyci5zdGFja31gKTtcbiAgICAgICAgYWN0dWFsRXJyID0gZXJyLmdldEFjdHVhbEVycm9yKCk7XG4gICAgICB9IGVsc2UgaWYgKCEoaXNFcnJvclR5cGUoZXJyLCBNSlNPTldQRXJyb3IpIHx8XG4gICAgICAgICAgICBpc0Vycm9yVHlwZShlcnIsIGVycm9ycy5CYWRQYXJhbWV0ZXJzRXJyb3IpKSkge1xuICAgICAgICBsb2cuZXJyb3IoYEVuY291bnRlcmVkIGludGVybmFsIGVycm9yIHJ1bm5pbmcgY29tbWFuZDogJHtlcnIuc3RhY2t9YCk7XG4gICAgICAgIGFjdHVhbEVyciA9IG5ldyBlcnJvcnMuVW5rbm93bkVycm9yKGVycik7XG4gICAgICB9XG4gICAgICAvLyBpZiBhbnl0aGluZyBnb2VzIHdyb25nLCBmaWd1cmUgb3V0IHdoYXQgb3VyIHJlc3BvbnNlIHNob3VsZCBiZVxuICAgICAgLy8gYmFzZWQgb24gdGhlIHR5cGUgb2YgZXJyb3IgdGhhdCB3ZSBlbmNvdW50ZXJlZFxuICAgICAgaWYgKGRyaXZlci5wcm90b2NvbCA9PT0gQmFzZURyaXZlci5EUklWRVJfUFJPVE9DT0wuVzNDKSB7XG4gICAgICAgIFtodHRwU3RhdHVzLCBodHRwUmVzQm9keV0gPSBnZXRSZXNwb25zZUZvclczQ0Vycm9yKGFjdHVhbEVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbaHR0cFN0YXR1cywgaHR0cFJlc0JvZHldID0gZ2V0UmVzcG9uc2VGb3JKc29ud3BFcnJvcihhY3R1YWxFcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRlY29kZSB0aGUgcmVzcG9uc2UsIHdoaWNoIGlzIGVpdGhlciBhIHN0cmluZyBvciBqc29uXG4gICAgaWYgKF8uaXNTdHJpbmcoaHR0cFJlc0JvZHkpKSB7XG4gICAgICByZXMuc3RhdHVzKGh0dHBTdGF0dXMpLnNlbmQoaHR0cFJlc0JvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV3U2Vzc2lvbklkKSB7XG4gICAgICAgIGlmIChkcml2ZXIucHJvdG9jb2wgPT09IEJhc2VEcml2ZXIuRFJJVkVSX1BST1RPQ09MLlczQykge1xuICAgICAgICAgIGh0dHBSZXNCb2R5LnZhbHVlLnNlc3Npb25JZCA9IG5ld1Nlc3Npb25JZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBodHRwUmVzQm9keS5zZXNzaW9uSWQgPSBuZXdTZXNzaW9uSWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0dHBSZXNCb2R5LnNlc3Npb25JZCA9IHJlcS5wYXJhbXMuc2Vzc2lvbklkIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJlcy5zdGF0dXMoaHR0cFN0YXR1cykuanNvbihodHRwUmVzQm9keSk7XG4gICAgfVxuICB9O1xuICAvLyBhZGQgdGhlIG1ldGhvZCB0byB0aGUgYXBwXG4gIGFwcFttZXRob2QudG9Mb3dlckNhc2UoKV0ocGF0aCwgKHJlcSwgcmVzKSA9PiB7XG4gICAgQi5yZXNvbHZlKGFzeW5jSGFuZGxlcihyZXEsIHJlcykpLmRvbmUoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRyaXZlclNob3VsZERvSndwUHJveHkgKGRyaXZlciwgcmVxLCBjb21tYW5kKSB7XG4gIC8vIGRyaXZlcnMgbmVlZCB0byBleHBsaWNpdGx5IHNheSB3aGVuIHRoZSBwcm94eSBpcyBhY3RpdmVcbiAgaWYgKCFkcml2ZXIucHJveHlBY3RpdmUocmVxLnBhcmFtcy5zZXNzaW9uSWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gd2Ugc2hvdWxkIG5ldmVyIHByb3h5IGRlbGV0ZVNlc3Npb24gYmVjYXVzZSB3ZSBuZWVkIHRvIGdpdmUgdGhlIGNvbnRhaW5pbmdcbiAgLy8gZHJpdmVyIGFuIG9wcG9ydHVuaXR5IHRvIGNsZWFuIGl0c2VsZiB1cFxuICBpZiAoY29tbWFuZCA9PT0gJ2RlbGV0ZVNlc3Npb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdmFsaWRhdGUgYXZvaWRhbmNlIHNjaGVtYSwgYW5kIHNheSB3ZSBzaG91bGRuJ3QgcHJveHkgaWYgYW55dGhpbmcgaW4gdGhlXG4gIC8vIGF2b2lkIGxpc3QgbWF0Y2hlcyBvdXIgcmVxXG4gIGxldCBwcm94eUF2b2lkTGlzdCA9IGRyaXZlci5nZXRQcm94eUF2b2lkTGlzdChyZXEucGFyYW1zLnNlc3Npb25JZCk7XG4gIGZvciAobGV0IGF2b2lkU2NoZW1hIG9mIHByb3h5QXZvaWRMaXN0KSB7XG4gICAgaWYgKCFfLmlzQXJyYXkoYXZvaWRTY2hlbWEpIHx8IGF2b2lkU2NoZW1hLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm94eSBhdm9pZGFuY2UgbXVzdCBiZSBhIGxpc3Qgb2YgcGFpcnMnKTtcbiAgICB9XG4gICAgbGV0IFthdm9pZE1ldGhvZCwgYXZvaWRQYXRoUmVnZXhdID0gYXZvaWRTY2hlbWE7XG4gICAgaWYgKCFfLmluY2x1ZGVzKFsnR0VUJywgJ1BPU1QnLCAnREVMRVRFJ10sIGF2b2lkTWV0aG9kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgcHJveHkgYXZvaWRhbmNlIG1ldGhvZCAnJHthdm9pZE1ldGhvZH0nYCk7XG4gICAgfVxuICAgIGlmICghKGF2b2lkUGF0aFJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm94eSBhdm9pZGFuY2UgcGF0aCBtdXN0IGJlIGEgcmVndWxhciBleHByZXNzaW9uJyk7XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkVXJsID0gcmVxLm9yaWdpbmFsVXJsLnJlcGxhY2UoL15cXC93ZFxcL2h1Yi8sICcnKTtcbiAgICBpZiAoYXZvaWRNZXRob2QgPT09IHJlcS5tZXRob2QgJiYgYXZvaWRQYXRoUmVnZXgudGVzdChub3JtYWxpemVkVXJsKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkb0p3cFByb3h5IChkcml2ZXIsIHJlcSwgcmVzKSB7XG4gIGxvZy5pbmZvKCdEcml2ZXIgcHJveHkgYWN0aXZlLCBwYXNzaW5nIHJlcXVlc3Qgb24gdmlhIEhUVFAgcHJveHknKTtcblxuICAvLyBjaGVjayB0aGF0IHRoZSBpbm5lciBkcml2ZXIgaGFzIGEgcHJveHkgZnVuY3Rpb25cbiAgaWYgKCFkcml2ZXIuY2FuUHJveHkocmVxLnBhcmFtcy5zZXNzaW9uSWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gcHJveHkgdG8gYSBKU09OV1Agc2VydmVyIGJ1dCBkcml2ZXIgaXMgdW5hYmxlIHRvIHByb3h5Jyk7XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCBkcml2ZXIuZXhlY3V0ZUNvbW1hbmQoJ3Byb3h5UmVxUmVzJywgcmVxLCByZXMsIHJlcS5wYXJhbXMuc2Vzc2lvbklkKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGlzRXJyb3JUeXBlKGVyciwgZXJyb3JzLlByb3h5UmVxdWVzdEVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwcm94eS4gUHJveHkgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG59XG5cblxuZXhwb3J0IHsgTUpTT05XUCwgcm91dGVDb25maWd1cmluZ0Z1bmN0aW9uLCBpc1Nlc3Npb25Db21tYW5kIH07XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
