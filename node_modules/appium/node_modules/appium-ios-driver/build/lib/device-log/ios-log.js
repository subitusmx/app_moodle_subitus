'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _appiumSupport = require('appium-support');

var _appiumXcode = require('appium-xcode');

var _appiumXcode2 = _interopRequireDefault(_appiumXcode);

var _teen_process = require('teen_process');

var START_TIMEOUT = 10000;
var DEVICE_CONSOLE_PATH = _path2['default'].resolve(__dirname, '..', '..', '..', 'build', 'deviceconsole');
var SYSTEM_LOG_PATH = '/var/log/system.log';
// We keep only the most recent log entries to avoid out of memory error
var MAX_LOG_ENTRIES_COUNT = 10000;

var IOSLog = (function () {
  function IOSLog(opts) {
    _classCallCheck(this, IOSLog);

    this.sim = opts.sim;
    this.udid = opts.udid;
    this.showLogs = !!opts.showLogs;
    this.realDeviceLogger = opts.realDeviceLogger || 'idevicesyslog';

    this.proc = null;
    this.logs = [];
    this.logRow = '';
    this.logIdxSinceLastRequest = -1;
    this.maxBufferSize = MAX_LOG_ENTRIES_COUNT;
  }

  _createClass(IOSLog, [{
    key: 'startCaptureRealDevice',
    value: function startCaptureRealDevice() {
      var cmd, args, env, deviceconsole, stat;
      return _regeneratorRuntime.async(function startCaptureRealDevice$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            cmd = undefined, args = undefined, env = undefined;

            if (!((this.realDeviceLogger || '').indexOf('idevicesyslog') !== -1)) {
              context$2$0.next = 24;
              break;
            }

            _logger2['default'].debug('Attempting iOS device log capture via libimobiledevice idevicesyslog');

            if (!(this.realDeviceLogger.toLowerCase() === 'idevicesyslog')) {
              context$2$0.next = 15;
              break;
            }

            cmd = 'idevicesyslog';
            context$2$0.prev = 5;
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.which('idevicesyslog'));

          case 8:
            context$2$0.next = 13;
            break;

          case 10:
            context$2$0.prev = 10;
            context$2$0.t0 = context$2$0['catch'](5);
            throw new Error('Unable to find system idevicesyslog: ' + context$2$0.t0.message);

          case 13:
            context$2$0.next = 20;
            break;

          case 15:
            context$2$0.next = 17;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(this.realDeviceLogger));

          case 17:
            if (context$2$0.sent) {
              context$2$0.next = 19;
              break;
            }

            throw new Error('Unable to find idevicesyslog from \'realDeviceLogger\' capability \'' + this.realDeviceLogger + '\'');

          case 19:
            cmd = this.realDeviceLogger;

          case 20:

            args = ['-u', this.udid];
            env = process.env;
            context$2$0.next = 57;
            break;

          case 24:
            if (!((this.realDeviceLogger || '').indexOf('deviceconsole') !== -1)) {
              context$2$0.next = 56;
              break;
            }

            _logger2['default'].debug('Attempting iOS device log capture via deviceconsole');
            deviceconsole = undefined;

            if (!(this.realDeviceLogger.toLowerCase() === 'deviceconsole')) {
              context$2$0.next = 31;
              break;
            }

            deviceconsole = DEVICE_CONSOLE_PATH;
            context$2$0.next = 48;
            break;

          case 31:
            stat = undefined;
            context$2$0.prev = 32;
            context$2$0.next = 35;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(this.realDeviceLogger));

          case 35:
            stat = context$2$0.sent;
            context$2$0.next = 41;
            break;

          case 38:
            context$2$0.prev = 38;
            context$2$0.t1 = context$2$0['catch'](32);
            throw new Error('Unable to find deviceconsole from \'realDeviceLogger\' capability \'' + this.realDeviceLogger + '\': ' + context$2$0.t1.message);

          case 41:
            if (!stat.isDirectory()) {
              context$2$0.next = 45;
              break;
            }

            deviceconsole = this.realDeviceLogger;
            context$2$0.next = 48;
            break;

          case 45:
            if (_lodash2['default'].endsWith(this.realDeviceLogger, 'deviceconsole')) {
              context$2$0.next = 47;
              break;
            }

            throw new Error('Unable to parse \'deviceconsole\' installation directory from \'' + this.realDeviceLogger + '\'');

          case 47:
            // remove the executable, and trailing `/`, to get the install directory
            deviceconsole = _path2['default'].dirname(this.realDeviceLogger);

          case 48:

            _logger2['default'].debug('Using \'deviceconsole\' from \'' + deviceconsole + '\'');

            cmd = deviceconsole + '/deviceconsole';
            args = ['-u', this.udid];

            // set up the environment to be able to run deviceconsole
            env = _lodash2['default'].clone(process.env);
            env.DYLD_LIBRARY_PATH = deviceconsole;
            if (process.env.DYLD_LIBRARY_PATH) {
              env.DYLD_LIBRARY_PATH = env.DYLD_LIBRARY_PATH + ':' + process.env.DYLD_LIBRARY_PATH;
            }
            context$2$0.next = 57;
            break;

          case 56:
            _logger2['default'].errorAndThrow('Unable to capture device log. Unknown \'realDeviceLogger\': \'' + this.realDeviceLogger + '\'');

          case 57:

            _logger2['default'].debug('Starting iOS device log capture with: \'' + cmd + '\'');

            context$2$0.prev = 58;
            context$2$0.next = 61;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkill', ['-xf', [cmd].concat(_toConsumableArray(args)).join(' ')]));

          case 61:
            context$2$0.next = 65;
            break;

          case 63:
            context$2$0.prev = 63;
            context$2$0.t2 = context$2$0['catch'](58);

          case 65:
            this.proc = new _teen_process.SubProcess(cmd, args, { env: env });

            context$2$0.next = 68;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 68:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[5, 10], [32, 38], [58, 63]]);
    }
  }, {
    key: 'startCaptureSimulator',
    value: function startCaptureSimulator() {
      var xCodeVersion, logPath, systemLogPath, files, lastModifiedLogPath, lastModifiedLogTime, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, file, mtime, tailArgs;

      return _regeneratorRuntime.async(function startCaptureSimulator$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(_appiumXcode2['default'].getVersion(true));

          case 2:
            xCodeVersion = context$2$0.sent;
            context$2$0.t0 = _logger2['default'];
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.sim.getPlatformVersion());

          case 6:
            context$2$0.t1 = context$2$0.sent;
            context$2$0.t2 = 'Starting iOS ' + context$2$0.t1;
            context$2$0.t3 = context$2$0.t2 + ' simulator log capture';
            context$2$0.t0.debug.call(context$2$0.t0, context$2$0.t3);

            if (!(xCodeVersion.major < 5)) {
              context$2$0.next = 15;
              break;
            }

            this.proc = new _teen_process.SubProcess('tail', ['-f', '-n', '1', SYSTEM_LOG_PATH]);
            context$2$0.next = 14;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 14:
            return context$2$0.abrupt('return');

          case 15:

            // this is xcode 6+
            if (_lodash2['default'].isUndefined(this.sim.udid)) {
              _logger2['default'].errorAndThrow('iOS ' + xCodeVersion.versionString + ' log capture requires a sim udid');
            }

            logPath = this.sim.getLogDir();
            context$2$0.prev = 17;

            if (!(logPath.indexOf('*') >= 0)) {
              context$2$0.next = 21;
              break;
            }

            _logger2['default'].error('Log path has * in it. Unable to start log capture: ' + logPath);
            return context$2$0.abrupt('return');

          case 21:
            systemLogPath = _path2['default'].resolve(logPath, 'system.log');

            _logger2['default'].debug('System log path: ' + systemLogPath);
            context$2$0.next = 25;
            return _regeneratorRuntime.awrap((0, _appiumSupport.mkdirp)(logPath));

          case 25:
            context$2$0.next = 27;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(systemLogPath, 'A new Appium session is about to start!\n', { flag: 'a' }));

          case 27:
            files = undefined;
            context$2$0.prev = 28;
            context$2$0.next = 31;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.glob(systemLogPath));

          case 31:
            files = context$2$0.sent;

            if (!(files.length < 1)) {
              context$2$0.next = 34;
              break;
            }

            throw new Error('Could not start log capture');

          case 34:
            context$2$0.next = 39;
            break;

          case 36:
            context$2$0.prev = 36;
            context$2$0.t4 = context$2$0['catch'](28);

            _logger2['default'].error('Could not start log capture because no iOS ' + ('simulator logs could be found at ' + systemLogPath + '. ') + 'Logging will not be functional for this run');

          case 39:
            lastModifiedLogPath = files[0];
            context$2$0.next = 42;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(lastModifiedLogPath).mtime);

          case 42:
            lastModifiedLogTime = context$2$0.sent;
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            context$2$0.prev = 46;
            _iterator = _getIterator(files);

          case 48:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              context$2$0.next = 57;
              break;
            }

            file = _step.value;
            context$2$0.next = 52;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(file).mtime);

          case 52:
            mtime = context$2$0.sent;

            if (mtime > lastModifiedLogTime) {
              lastModifiedLogPath = file;
              lastModifiedLogTime = mtime;
            }

          case 54:
            _iteratorNormalCompletion = true;
            context$2$0.next = 48;
            break;

          case 57:
            context$2$0.next = 63;
            break;

          case 59:
            context$2$0.prev = 59;
            context$2$0.t5 = context$2$0['catch'](46);
            _didIteratorError = true;
            _iteratorError = context$2$0.t5;

          case 63:
            context$2$0.prev = 63;
            context$2$0.prev = 64;

            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }

          case 66:
            context$2$0.prev = 66;

            if (!_didIteratorError) {
              context$2$0.next = 69;
              break;
            }

            throw _iteratorError;

          case 69:
            return context$2$0.finish(66);

          case 70:
            return context$2$0.finish(63);

          case 71:
            tailArgs = ['-f', '-n', '1', lastModifiedLogPath];
            context$2$0.prev = 72;
            context$2$0.next = 75;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkill', ['-xf', ['tail'].concat(tailArgs).join(' ')]));

          case 75:
            context$2$0.next = 79;
            break;

          case 77:
            context$2$0.prev = 77;
            context$2$0.t6 = context$2$0['catch'](72);

          case 79:
            this.proc = new _teen_process.SubProcess('tail', tailArgs);
            context$2$0.next = 82;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 82:
            context$2$0.next = 87;
            break;

          case 84:
            context$2$0.prev = 84;
            context$2$0.t7 = context$2$0['catch'](17);

            _logger2['default'].errorAndThrow('Simulator log capture failed: ' + context$2$0.t7.message);

          case 87:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[17, 84], [28, 36], [46, 59, 63, 71], [64,, 66, 70], [72, 77]]);
    }
  }, {
    key: 'startCapture',
    value: function startCapture() {
      return _regeneratorRuntime.async(function startCapture$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.udid) {
              context$2$0.next = 4;
              break;
            }

            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.startCaptureRealDevice());

          case 3:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 4:
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.startCaptureSimulator());

          case 6:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 7:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'finishStartingLogCapture',
    value: function finishStartingLogCapture() {
      var firstLine, sd;
      return _regeneratorRuntime.async(function finishStartingLogCapture$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.proc) {
              _logger2['default'].errorAndThrow('Could not capture device log');
            }
            firstLine = true;

            this.proc.on('output', function (stdout, stderr) {
              if (stdout) {
                if (firstLine) {
                  if (stdout.substr(-1, 1) === '\n') {
                    // don't store the first line of the log because it came before the sim or device was launched
                    firstLine = false;
                  }
                } else {
                  _this.logRow += stdout;
                  if (stdout.substr(-1, 1) === '\n') {
                    _this.onOutput();
                    _this.logRow = '';
                  }
                }
              }
              if (stderr) {
                _this.onOutput('STDERR');
              }
            });

            sd = function sd(stdout, stderr) {
              if (/execvp\(\)/.test(stderr)) {
                throw new Error('iOS log capture process failed to start');
              }
              return stdout || stderr;
            };

            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.proc.start(sd, START_TIMEOUT));

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'stopCapture',
    value: function stopCapture() {
      return _regeneratorRuntime.async(function stopCapture$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Stopping iOS log capture');

            if (!(this.proc && this.proc.isRunning)) {
              context$2$0.next = 12;
              break;
            }

            context$2$0.prev = 2;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.proc.stop('SIGTERM', 1000));

          case 5:
            context$2$0.next = 12;
            break;

          case 7:
            context$2$0.prev = 7;
            context$2$0.t0 = context$2$0['catch'](2);

            _logger2['default'].error('Cannot stop log capture process. Sending SIGKILL...');
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap(this.proc.stop('SIGKILL'));

          case 12:
            this.proc = null;

          case 13:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[2, 7]]);
    }
  }, {
    key: 'onOutput',
    value: function onOutput() {
      var prefix = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

      var logs = this.logRow.split('\n');
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _getIterator(logs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var log = _step2.value;

          if (!log) continue; // eslint-disable-line curly
          var logObj = {
            timestamp: Date.now(),
            level: 'ALL',
            message: log
          };
          this.logs.push(logObj);
          if (this.logs.length > this.maxBufferSize) {
            this.logs.shift();
            if (this.logIdxSinceLastRequest > 0) {
              --this.logIdxSinceLastRequest;
            }
          }
          if (this.showLogs) {
            var space = prefix.length > 0 ? ' ' : '';
            _logger2['default'].info('[IOS_SYSLOG_ROW' + space + prefix + '] ' + log);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2['return']) {
            _iterator2['return']();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'getLogs',
    value: function getLogs() {
      var result;
      return _regeneratorRuntime.async(function getLogs$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!(this.logs.length && this.logIdxSinceLastRequest < this.logs.length)) {
              context$2$0.next = 5;
              break;
            }

            result = this.logs;

            if (this.logIdxSinceLastRequest > 0) {
              result = result.slice(this.logIdxSinceLastRequest);
            }
            this.logIdxSinceLastRequest = this.logs.length;
            return context$2$0.abrupt('return', result);

          case 5:
            return context$2$0.abrupt('return', []);

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'getAllLogs',
    value: function getAllLogs() {
      return _regeneratorRuntime.async(function getAllLogs$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.abrupt('return', this.logs);

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }]);

  return IOSLog;
})();

exports.IOSLog = IOSLog;
exports.DEVICE_CONSOLE_PATH = DEVICE_CONSOLE_PATH;
exports['default'] = IOSLog;

// make sure it is available on the PATH

// make sure the executable exists

// make sure that we have the path to the directory,
// not the actual executable

// make sure they've passed in `deviceconsole` and not something random

// cleanup existing listeners if the previous session has not been terminated properly

// otherwise, if we have a simulator...

// cleanup existing listeners if the previous session has not been terminated properly

// if we have a real device
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9kZXZpY2UtbG9nL2lvcy1sb2cuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFpQixNQUFNOzs7O3NCQUNULFFBQVE7Ozs7c0JBQ0gsVUFBVTs7Ozs2QkFDRixnQkFBZ0I7OzJCQUN6QixjQUFjOzs7OzRCQUNDLGNBQWM7O0FBRS9DLElBQU0sYUFBYSxHQUFHLEtBQUssQ0FBQztBQUM1QixJQUFNLG1CQUFtQixHQUFHLGtCQUFLLE9BQU8sQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLGVBQWUsQ0FBQyxDQUFDO0FBQ2hHLElBQU0sZUFBZSxHQUFHLHFCQUFxQixDQUFDOztBQUU5QyxJQUFNLHFCQUFxQixHQUFHLEtBQUssQ0FBQzs7SUFFOUIsTUFBTTtBQUNFLFdBRFIsTUFBTSxDQUNHLElBQUksRUFBRTswQkFEZixNQUFNOztBQUVSLFFBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztBQUNwQixRQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDdEIsUUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztBQUNoQyxRQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixJQUFJLGVBQWUsQ0FBQzs7QUFFakUsUUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDakIsUUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7QUFDZixRQUFJLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUNqQixRQUFJLENBQUMsc0JBQXNCLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDakMsUUFBSSxDQUFDLGFBQWEsR0FBRyxxQkFBcUIsQ0FBQztHQUM1Qzs7ZUFaRyxNQUFNOztXQWNtQjtVQUN2QixHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUF1QlosYUFBYSxFQU1Y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QkFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUM7YUFDL0I7V0FDRjtBQUNELGNBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNqQixnQkFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUN6QyxnQ0FBTyxJQUFJLHFCQUFtQixLQUFLLEdBQUcsTUFBTSxVQUFLLEdBQUcsQ0FBRyxDQUFDO1dBQ3pEO1NBQ0Y7Ozs7Ozs7Ozs7Ozs7OztLQUNGOzs7V0FFYTtVQUVOLE1BQU07Ozs7a0JBRFIsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFBOzs7OztBQUNoRSxrQkFBTSxHQUFHLElBQUksQ0FBQyxJQUFJOztBQUN0QixnQkFBSSxJQUFJLENBQUMsc0JBQXNCLEdBQUcsQ0FBQyxFQUFFO0FBQ25DLG9CQUFNLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQzthQUNwRDtBQUNELGdCQUFJLENBQUMsc0JBQXNCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7Z0RBQ3hDLE1BQU07OztnREFFUixFQUFFOzs7Ozs7O0tBQ1Y7OztXQUVnQjs7OztnREFDUixJQUFJLENBQUMsSUFBSTs7Ozs7OztLQUNqQjs7O1NBL09HLE1BQU07OztRQWtQSCxNQUFNLEdBQU4sTUFBTTtRQUFFLG1CQUFtQixHQUFuQixtQkFBbUI7cUJBQ3JCLE1BQU0iLCJmaWxlIjoibGliL2RldmljZS1sb2cvaW9zLWxvZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBsb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgZnMsIG1rZGlycCB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCB4Y29kZSBmcm9tICdhcHBpdW0teGNvZGUnO1xuaW1wb3J0IHsgU3ViUHJvY2VzcywgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5cbmNvbnN0IFNUQVJUX1RJTUVPVVQgPSAxMDAwMDtcbmNvbnN0IERFVklDRV9DT05TT0xFX1BBVEggPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nLCAnYnVpbGQnLCAnZGV2aWNlY29uc29sZScpO1xuY29uc3QgU1lTVEVNX0xPR19QQVRIID0gJy92YXIvbG9nL3N5c3RlbS5sb2cnO1xuLy8gV2Uga2VlcCBvbmx5IHRoZSBtb3N0IHJlY2VudCBsb2cgZW50cmllcyB0byBhdm9pZCBvdXQgb2YgbWVtb3J5IGVycm9yXG5jb25zdCBNQVhfTE9HX0VOVFJJRVNfQ09VTlQgPSAxMDAwMDtcblxuY2xhc3MgSU9TTG9nIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICB0aGlzLnNpbSA9IG9wdHMuc2ltO1xuICAgIHRoaXMudWRpZCA9IG9wdHMudWRpZDtcbiAgICB0aGlzLnNob3dMb2dzID0gISFvcHRzLnNob3dMb2dzO1xuICAgIHRoaXMucmVhbERldmljZUxvZ2dlciA9IG9wdHMucmVhbERldmljZUxvZ2dlciB8fCAnaWRldmljZXN5c2xvZyc7XG5cbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgIHRoaXMubG9ncyA9IFtdO1xuICAgIHRoaXMubG9nUm93ID0gJyc7XG4gICAgdGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0ID0gLTE7XG4gICAgdGhpcy5tYXhCdWZmZXJTaXplID0gTUFYX0xPR19FTlRSSUVTX0NPVU5UO1xuICB9XG5cbiAgYXN5bmMgc3RhcnRDYXB0dXJlUmVhbERldmljZSAoKSB7XG4gICAgbGV0IGNtZCwgYXJncywgZW52O1xuICAgIGlmICgodGhpcy5yZWFsRGV2aWNlTG9nZ2VyIHx8ICcnKS5pbmRleE9mKCdpZGV2aWNlc3lzbG9nJykgIT09IC0xKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ0F0dGVtcHRpbmcgaU9TIGRldmljZSBsb2cgY2FwdHVyZSB2aWEgbGliaW1vYmlsZWRldmljZSBpZGV2aWNlc3lzbG9nJyk7XG4gICAgICBpZiAodGhpcy5yZWFsRGV2aWNlTG9nZ2VyLnRvTG93ZXJDYXNlKCkgPT09ICdpZGV2aWNlc3lzbG9nJykge1xuICAgICAgICBjbWQgPSAnaWRldmljZXN5c2xvZyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIGl0IGlzIGF2YWlsYWJsZSBvbiB0aGUgUEFUSFxuICAgICAgICAgIGF3YWl0IGZzLndoaWNoKCdpZGV2aWNlc3lzbG9nJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgc3lzdGVtIGlkZXZpY2VzeXNsb2c6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgZXhlY3V0YWJsZSBleGlzdHNcbiAgICAgICAgaWYgKCFhd2FpdCBmcy5leGlzdHModGhpcy5yZWFsRGV2aWNlTG9nZ2VyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgaWRldmljZXN5c2xvZyBmcm9tICdyZWFsRGV2aWNlTG9nZ2VyJyBjYXBhYmlsaXR5ICcke3RoaXMucmVhbERldmljZUxvZ2dlcn0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgY21kID0gdGhpcy5yZWFsRGV2aWNlTG9nZ2VyO1xuICAgICAgfVxuXG4gICAgICBhcmdzID0gWyctdScsIHRoaXMudWRpZF07XG4gICAgICBlbnYgPSBwcm9jZXNzLmVudjtcbiAgICB9IGVsc2UgaWYgKCh0aGlzLnJlYWxEZXZpY2VMb2dnZXIgfHwgJycpLmluZGV4T2YoJ2RldmljZWNvbnNvbGUnKSAhPT0gLTEpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQXR0ZW1wdGluZyBpT1MgZGV2aWNlIGxvZyBjYXB0dXJlIHZpYSBkZXZpY2Vjb25zb2xlJyk7XG4gICAgICBsZXQgZGV2aWNlY29uc29sZTtcbiAgICAgIGlmICh0aGlzLnJlYWxEZXZpY2VMb2dnZXIudG9Mb3dlckNhc2UoKSA9PT0gJ2RldmljZWNvbnNvbGUnKSB7XG4gICAgICAgIGRldmljZWNvbnNvbGUgPSBERVZJQ0VfQ09OU09MRV9QQVRIO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSB0aGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5LFxuICAgICAgICAvLyBub3QgdGhlIGFjdHVhbCBleGVjdXRhYmxlXG4gICAgICAgIGxldCBzdGF0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXQgPSBhd2FpdCBmcy5zdGF0KHRoaXMucmVhbERldmljZUxvZ2dlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgZGV2aWNlY29uc29sZSBmcm9tICdyZWFsRGV2aWNlTG9nZ2VyJyBjYXBhYmlsaXR5ICcke3RoaXMucmVhbERldmljZUxvZ2dlcn0nOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICBkZXZpY2Vjb25zb2xlID0gdGhpcy5yZWFsRGV2aWNlTG9nZ2VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGV5J3ZlIHBhc3NlZCBpbiBgZGV2aWNlY29uc29sZWAgYW5kIG5vdCBzb21ldGhpbmcgcmFuZG9tXG4gICAgICAgICAgaWYgKCFfLmVuZHNXaXRoKHRoaXMucmVhbERldmljZUxvZ2dlciwgJ2RldmljZWNvbnNvbGUnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcGFyc2UgJ2RldmljZWNvbnNvbGUnIGluc3RhbGxhdGlvbiBkaXJlY3RvcnkgZnJvbSAnJHt0aGlzLnJlYWxEZXZpY2VMb2dnZXJ9J2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGV4ZWN1dGFibGUsIGFuZCB0cmFpbGluZyBgL2AsIHRvIGdldCB0aGUgaW5zdGFsbCBkaXJlY3RvcnlcbiAgICAgICAgICBkZXZpY2Vjb25zb2xlID0gcGF0aC5kaXJuYW1lKHRoaXMucmVhbERldmljZUxvZ2dlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbG9nZ2VyLmRlYnVnKGBVc2luZyAnZGV2aWNlY29uc29sZScgZnJvbSAnJHtkZXZpY2Vjb25zb2xlfSdgKTtcblxuICAgICAgY21kID0gYCR7ZGV2aWNlY29uc29sZX0vZGV2aWNlY29uc29sZWA7XG4gICAgICBhcmdzID0gWyctdScsIHRoaXMudWRpZF07XG5cbiAgICAgIC8vIHNldCB1cCB0aGUgZW52aXJvbm1lbnQgdG8gYmUgYWJsZSB0byBydW4gZGV2aWNlY29uc29sZVxuICAgICAgZW52ID0gXy5jbG9uZShwcm9jZXNzLmVudik7XG4gICAgICBlbnYuRFlMRF9MSUJSQVJZX1BBVEggPSBkZXZpY2Vjb25zb2xlO1xuICAgICAgaWYgKHByb2Nlc3MuZW52LkRZTERfTElCUkFSWV9QQVRIKSB7XG4gICAgICAgIGVudi5EWUxEX0xJQlJBUllfUEFUSCA9IGAke2Vudi5EWUxEX0xJQlJBUllfUEFUSH06JHtwcm9jZXNzLmVudi5EWUxEX0xJQlJBUllfUEFUSH1gO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZXJyb3JBbmRUaHJvdyhgVW5hYmxlIHRvIGNhcHR1cmUgZGV2aWNlIGxvZy4gVW5rbm93biAncmVhbERldmljZUxvZ2dlcic6ICcke3RoaXMucmVhbERldmljZUxvZ2dlcn0nYCk7XG4gICAgfVxuXG4gICAgbG9nZ2VyLmRlYnVnKGBTdGFydGluZyBpT1MgZGV2aWNlIGxvZyBjYXB0dXJlIHdpdGg6ICcke2NtZH0nYCk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gY2xlYW51cCBleGlzdGluZyBsaXN0ZW5lcnMgaWYgdGhlIHByZXZpb3VzIHNlc3Npb24gaGFzIG5vdCBiZWVuIHRlcm1pbmF0ZWQgcHJvcGVybHlcbiAgICAgIGF3YWl0IGV4ZWMoJ3BraWxsJywgWycteGYnLCBbY21kLCAuLi5hcmdzXS5qb2luKCcgJyldKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRoaXMucHJvYyA9IG5ldyBTdWJQcm9jZXNzKGNtZCwgYXJncywge2Vudn0pO1xuXG4gICAgYXdhaXQgdGhpcy5maW5pc2hTdGFydGluZ0xvZ0NhcHR1cmUoKTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0Q2FwdHVyZVNpbXVsYXRvciAoKSB7XG4gICAgIC8vIG90aGVyd2lzZSwgaWYgd2UgaGF2ZSBhIHNpbXVsYXRvci4uLlxuICAgIGxldCB4Q29kZVZlcnNpb24gPSBhd2FpdCB4Y29kZS5nZXRWZXJzaW9uKHRydWUpO1xuXG4gICAgbG9nZ2VyLmRlYnVnKGBTdGFydGluZyBpT1MgJHthd2FpdCB0aGlzLnNpbS5nZXRQbGF0Zm9ybVZlcnNpb24oKX0gc2ltdWxhdG9yIGxvZyBjYXB0dXJlYCk7XG4gICAgaWYgKHhDb2RlVmVyc2lvbi5tYWpvciA8IDUpIHtcbiAgICAgIHRoaXMucHJvYyA9IG5ldyBTdWJQcm9jZXNzKCd0YWlsJywgWyctZicsICctbicsICcxJywgU1lTVEVNX0xPR19QQVRIXSk7XG4gICAgICBhd2FpdCB0aGlzLmZpbmlzaFN0YXJ0aW5nTG9nQ2FwdHVyZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHRoaXMgaXMgeGNvZGUgNitcbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLnNpbS51ZGlkKSkge1xuICAgICAgbG9nZ2VyLmVycm9yQW5kVGhyb3coYGlPUyAke3hDb2RlVmVyc2lvbi52ZXJzaW9uU3RyaW5nfSBsb2cgY2FwdHVyZSByZXF1aXJlcyBhIHNpbSB1ZGlkYCk7XG4gICAgfVxuXG4gICAgbGV0IGxvZ1BhdGggPSB0aGlzLnNpbS5nZXRMb2dEaXIoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKGxvZ1BhdGguaW5kZXhPZignKicpID49IDApIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBMb2cgcGF0aCBoYXMgKiBpbiBpdC4gVW5hYmxlIHRvIHN0YXJ0IGxvZyBjYXB0dXJlOiAke2xvZ1BhdGh9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzeXN0ZW1Mb2dQYXRoID0gcGF0aC5yZXNvbHZlKGxvZ1BhdGgsICdzeXN0ZW0ubG9nJyk7XG4gICAgICBsb2dnZXIuZGVidWcoYFN5c3RlbSBsb2cgcGF0aDogJHtzeXN0ZW1Mb2dQYXRofWApO1xuICAgICAgYXdhaXQgbWtkaXJwKGxvZ1BhdGgpO1xuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHN5c3RlbUxvZ1BhdGgsICdBIG5ldyBBcHBpdW0gc2Vzc2lvbiBpcyBhYm91dCB0byBzdGFydCFcXG4nLCB7ZmxhZzogJ2EnfSk7XG4gICAgICBsZXQgZmlsZXM7XG4gICAgICB0cnkge1xuICAgICAgICBmaWxlcyA9IGF3YWl0IGZzLmdsb2Ioc3lzdGVtTG9nUGF0aCk7XG4gICAgICAgIGlmIChmaWxlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3Qgc3RhcnQgbG9nIGNhcHR1cmUnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYENvdWxkIG5vdCBzdGFydCBsb2cgY2FwdHVyZSBiZWNhdXNlIG5vIGlPUyBgICtcbiAgICAgICAgICAgICAgICAgICAgIGBzaW11bGF0b3IgbG9ncyBjb3VsZCBiZSBmb3VuZCBhdCAke3N5c3RlbUxvZ1BhdGh9LiBgICtcbiAgICAgICAgICAgICAgICAgICAgIGBMb2dnaW5nIHdpbGwgbm90IGJlIGZ1bmN0aW9uYWwgZm9yIHRoaXMgcnVuYCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBsYXN0TW9kaWZpZWRMb2dQYXRoID0gZmlsZXNbMF07XG4gICAgICBsZXQgbGFzdE1vZGlmaWVkTG9nVGltZSA9IGF3YWl0IGZzLnN0YXQobGFzdE1vZGlmaWVkTG9nUGF0aCkubXRpbWU7XG4gICAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgIGxldCBtdGltZSA9IGF3YWl0IGZzLnN0YXQoZmlsZSkubXRpbWU7XG4gICAgICAgIGlmIChtdGltZSA+IGxhc3RNb2RpZmllZExvZ1RpbWUpIHtcbiAgICAgICAgICBsYXN0TW9kaWZpZWRMb2dQYXRoID0gZmlsZTtcbiAgICAgICAgICBsYXN0TW9kaWZpZWRMb2dUaW1lID0gbXRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhaWxBcmdzID0gWyctZicsICctbicsICcxJywgbGFzdE1vZGlmaWVkTG9nUGF0aF07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBjbGVhbnVwIGV4aXN0aW5nIGxpc3RlbmVycyBpZiB0aGUgcHJldmlvdXMgc2Vzc2lvbiBoYXMgbm90IGJlZW4gdGVybWluYXRlZCBwcm9wZXJseVxuICAgICAgICBhd2FpdCBleGVjKCdwa2lsbCcsIFsnLXhmJywgWyd0YWlsJywgLi4udGFpbEFyZ3NdLmpvaW4oJyAnKV0pO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIHRoaXMucHJvYyA9IG5ldyBTdWJQcm9jZXNzKCd0YWlsJywgdGFpbEFyZ3MpO1xuICAgICAgYXdhaXQgdGhpcy5maW5pc2hTdGFydGluZ0xvZ0NhcHR1cmUoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlci5lcnJvckFuZFRocm93KGBTaW11bGF0b3IgbG9nIGNhcHR1cmUgZmFpbGVkOiAke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN0YXJ0Q2FwdHVyZSAoKSB7XG4gICAgaWYgKHRoaXMudWRpZCkge1xuICAgICAgLy8gaWYgd2UgaGF2ZSBhIHJlYWwgZGV2aWNlXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zdGFydENhcHR1cmVSZWFsRGV2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnN0YXJ0Q2FwdHVyZVNpbXVsYXRvcigpO1xuICB9XG5cbiAgYXN5bmMgZmluaXNoU3RhcnRpbmdMb2dDYXB0dXJlICgpIHtcbiAgICBpZiAoIXRoaXMucHJvYykge1xuICAgICAgbG9nZ2VyLmVycm9yQW5kVGhyb3coJ0NvdWxkIG5vdCBjYXB0dXJlIGRldmljZSBsb2cnKTtcbiAgICB9XG4gICAgbGV0IGZpcnN0TGluZSA9IHRydWU7XG4gICAgdGhpcy5wcm9jLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgaWYgKGZpcnN0TGluZSkge1xuICAgICAgICAgIGlmIChzdGRvdXQuc3Vic3RyKC0xLCAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IHN0b3JlIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBsb2cgYmVjYXVzZSBpdCBjYW1lIGJlZm9yZSB0aGUgc2ltIG9yIGRldmljZSB3YXMgbGF1bmNoZWRcbiAgICAgICAgICAgIGZpcnN0TGluZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ1JvdyArPSBzdGRvdXQ7XG4gICAgICAgICAgaWYgKHN0ZG91dC5zdWJzdHIoLTEsIDEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgdGhpcy5vbk91dHB1dCgpO1xuICAgICAgICAgICAgdGhpcy5sb2dSb3cgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGRlcnIpIHtcbiAgICAgICAgdGhpcy5vbk91dHB1dCgnU1RERVJSJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgc2QgPSAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgIGlmICgvZXhlY3ZwXFwoXFwpLy50ZXN0KHN0ZGVycikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpT1MgbG9nIGNhcHR1cmUgcHJvY2VzcyBmYWlsZWQgdG8gc3RhcnQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGRvdXQgfHwgc3RkZXJyO1xuICAgIH07XG4gICAgYXdhaXQgdGhpcy5wcm9jLnN0YXJ0KHNkLCBTVEFSVF9USU1FT1VUKTtcbiAgfVxuXG4gIGFzeW5jIHN0b3BDYXB0dXJlICgpIHtcbiAgICBsb2dnZXIuZGVidWcoJ1N0b3BwaW5nIGlPUyBsb2cgY2FwdHVyZScpO1xuICAgIGlmICh0aGlzLnByb2MgJiYgdGhpcy5wcm9jLmlzUnVubmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoJ1NJR1RFUk0nLCAxMDAwKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3Qgc3RvcCBsb2cgY2FwdHVyZSBwcm9jZXNzLiBTZW5kaW5nIFNJR0tJTEwuLi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoJ1NJR0tJTEwnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcm9jID0gbnVsbDtcbiAgfVxuXG4gIG9uT3V0cHV0IChwcmVmaXggPSAnJykge1xuICAgIGxldCBsb2dzID0gdGhpcy5sb2dSb3cuc3BsaXQoJ1xcbicpO1xuICAgIGZvciAobGV0IGxvZyBvZiBsb2dzKSB7XG4gICAgICBpZiAoIWxvZykgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcbiAgICAgIGxldCBsb2dPYmogPSB7XG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgbGV2ZWw6ICdBTEwnLFxuICAgICAgICBtZXNzYWdlOiBsb2dcbiAgICAgIH07XG4gICAgICB0aGlzLmxvZ3MucHVzaChsb2dPYmopO1xuICAgICAgaWYgKHRoaXMubG9ncy5sZW5ndGggPiB0aGlzLm1heEJ1ZmZlclNpemUpIHtcbiAgICAgICAgdGhpcy5sb2dzLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPiAwKSB7XG4gICAgICAgICAgLS10aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNob3dMb2dzKSB7XG4gICAgICAgIGxldCBzcGFjZSA9IHByZWZpeC5sZW5ndGggPiAwID8gJyAnIDogJyc7XG4gICAgICAgIGxvZ2dlci5pbmZvKGBbSU9TX1NZU0xPR19ST1cke3NwYWNlfSR7cHJlZml4fV0gJHtsb2d9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0TG9ncyAoKSB7XG4gICAgaWYgKHRoaXMubG9ncy5sZW5ndGggJiYgdGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0IDwgdGhpcy5sb2dzLmxlbmd0aCkge1xuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubG9ncztcbiAgICAgIGlmICh0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPiAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSh0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0ID0gdGhpcy5sb2dzLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGFzeW5jIGdldEFsbExvZ3MgKCkge1xuICAgIHJldHVybiB0aGlzLmxvZ3M7XG4gIH1cbn1cblxuZXhwb3J0IHsgSU9TTG9nLCBERVZJQ0VfQ09OU09MRV9QQVRIIH07XG5leHBvcnQgZGVmYXVsdCBJT1NMb2c7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
