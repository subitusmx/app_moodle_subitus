'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _appiumBaseDriver = require('appium-base-driver');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _teen_process = require('teen_process');

var _installer = require('./installer');

var _asyncbox = require('asyncbox');

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var REQD_PARAMS = ['app'];
var DEFAULT_WAD_HOST = '127.0.0.1';
var DEFAULT_WAD_PORT = 4724; //  should be non-4723 to avoid conflict on the same box

var WinAppDriver = (function (_events$EventEmitter) {
  _inherits(WinAppDriver, _events$EventEmitter);

  function WinAppDriver() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, WinAppDriver);

    var host = opts.host;
    var port = opts.port;

    _get(Object.getPrototypeOf(WinAppDriver.prototype), 'constructor', this).call(this);

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(REQD_PARAMS), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var req = _step.value;

        if (!opts || !opts[req]) {
          throw new Error('Option \'' + req + '\' is required!');
        }
        this[req] = opts[req];
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    this.proxyHost = host || DEFAULT_WAD_HOST;
    this.proxyPort = port || DEFAULT_WAD_PORT;
    this.proc = null;
    this.state = WinAppDriver.STATE_STOPPED;
    this.jwproxy = new _appiumBaseDriver.JWProxy({ server: this.proxyHost, port: this.proxyPort });
  }

  _createClass(WinAppDriver, [{
    key: 'start',
    value: function start() {
      var args, startDetector, processIsAlive, _arr, _loop, _i;

      return _regeneratorRuntime.async(function start$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap((0, _installer.verifyWAD)());

          case 2:
            if (context$2$0.sent) {
              context$2$0.next = 4;
              break;
            }

            throw new Error("Could not verify WinAppDriver install; re-run install");

          case 4:

            this.changeState(WinAppDriver.STATE_STARTING);

            // XXXYD TODO: would be better if WinAppDriver didn't require passing in /wd/hub as a param
            args = [this.proxyPort + "/wd/hub"];

            startDetector = function startDetector(stdout) {
              return stdout.indexOf("listening for requests") !== -1;
            };

            processIsAlive = false;
            context$2$0.prev = 8;
            context$2$0.next = 11;
            return _regeneratorRuntime.awrap(this.killAll());

          case 11:

            // set up our subprocess object
            this.proc = new _teen_process.SubProcess(_installer.WAD_INSTALL_PATH, args, {
              encoding: 'ucs2'
            });
            processIsAlive = true;

            // handle log output
            _arr = ['STDOUT', 'STDERR'];

            _loop = function () {
              var stream = _arr[_i];
              _this.proc.on('lines-' + stream.toLowerCase(), function (lines) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                  for (var _iterator2 = _getIterator(lines), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var l = _step2.value;

                    _logger2['default'].info('[' + stream + '] ' + l.trim());
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                      _iterator2['return']();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }
              });
            };

            for (_i = 0; _i < _arr.length; _i++) {
              _loop();
            }

            // handle out-of-bound exit by simply emitting a stopped state
            this.proc.on('exit', function (code, signal) {
              processIsAlive = false;
              if (_this.state !== WinAppDriver.STATE_STOPPED && _this.state !== WinAppDriver.STATE_STOPPING) {
                var msg = 'WinAppDriver exited unexpectedly with code ' + code + ', ' + ('signal ' + signal);
                _logger2['default'].error(msg);
                _this.changeState(WinAppDriver.STATE_STOPPED);
              }
            });
            _logger2['default'].info('Spawning winappdriver with: ' + args.join(' '));

            // start subproc and wait for startDetector
            context$2$0.next = 20;
            return _regeneratorRuntime.awrap(this.proc.start(startDetector));

          case 20:
            context$2$0.next = 22;
            return _regeneratorRuntime.awrap(this.waitForOnline());

          case 22:
            context$2$0.next = 31;
            break;

          case 24:
            context$2$0.prev = 24;
            context$2$0.t0 = context$2$0['catch'](8);

            this.emit(WinAppDriver.EVENT_ERROR, context$2$0.t0);
            // just because we had an error doesn't mean the winappdriver process
            // finished; we should clean up if necessary

            if (!processIsAlive) {
              context$2$0.next = 30;
              break;
            }

            context$2$0.next = 30;
            return _regeneratorRuntime.awrap(this.proc.stop());

          case 30:
            _logger2['default'].errorAndThrow(context$2$0.t0);

          case 31:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[8, 24]]);
    }
  }, {
    key: 'sessionId',
    value: function sessionId() {
      if (this.state !== WinAppDriver.STATE_ONLINE) {
        return null;
      }

      return this.jwproxy.sessionId;
    }
  }, {
    key: 'waitForOnline',
    value: function waitForOnline() {
      var winappdriverStopped;
      return _regeneratorRuntime.async(function waitForOnline$(context$2$0) {
        var _this2 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            winappdriverStopped = false;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(20, 200, function callee$2$0() {
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    if (!([WinAppDriver.STATE_STOPPED, WinAppDriver.STATE_ONLINE].indexOf(this.state) >= 0)) {
                      context$3$0.next = 3;
                      break;
                    }

                    // we are either stopped, stopping, or we're online
                    winappdriverStopped = this.state === WinAppDriver.STATE_STOPPED;
                    return context$3$0.abrupt('return');

                  case 3:
                    context$3$0.next = 5;
                    return _regeneratorRuntime.awrap(this.getStatus());

                  case 5:
                    if (!context$3$0.sent) {
                      context$3$0.next = 7;
                      break;
                    }

                    this.changeState(WinAppDriver.STATE_ONLINE);

                  case 7:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this2);
            }));

          case 3:
            if (!winappdriverStopped) {
              context$2$0.next = 5;
              break;
            }

            throw new Error('WinAppDriver crashed during startup.');

          case 5:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'getStatus',
    value: function getStatus() {
      var resBlock;
      return _regeneratorRuntime.async(function getStatus$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.proxy('/status', 'GET'));

          case 2:
            resBlock = context$2$0.sent;

            if (!(resBlock[0].statusCode === 200)) {
              context$2$0.next = 6;
              break;
            }

            _logger2['default'].info('Status call returned 200. we\'re online and ready to run tests');
            return context$2$0.abrupt('return', true);

          case 6:
            return context$2$0.abrupt('return', false);

          case 7:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'startSession',
    value: function startSession(caps) {
      return _regeneratorRuntime.async(function startSession$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.proxyReqRes = this.jwproxy.proxyReqRes.bind(this.jwproxy);
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/session', 'POST', { desiredCapabilities: caps }));

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'stop',
    value: function stop() {
      var emitStates = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
      return _regeneratorRuntime.async(function stop$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (emitStates) {
              this.changeState(WinAppDriver.STATE_STOPPING);
            }
            context$2$0.prev = 1;

            if (!this.proc) {
              context$2$0.next = 5;
              break;
            }

            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.proc.stop());

          case 5:
            if (emitStates) {
              this.changeState(WinAppDriver.STATE_STOPPED);
            }
            context$2$0.next = 11;
            break;

          case 8:
            context$2$0.prev = 8;
            context$2$0.t0 = context$2$0['catch'](1);

            _logger2['default'].error(context$2$0.t0);

          case 11:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[1, 8]]);
    }
  }, {
    key: 'changeState',
    value: function changeState(state) {
      this.state = state;
      _logger2['default'].debug('WinAppDriver changed state to \'' + state + '\'');
      this.emit(WinAppDriver.EVENT_CHANGED, { state: state });
    }
  }, {
    key: 'sendCommand',
    value: function sendCommand(url, method, body) {
      return _regeneratorRuntime.async(function sendCommand$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.command(url, method, body));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'proxyReq',
    value: function proxyReq(req, res) {
      return _regeneratorRuntime.async(function proxyReq$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.proxyReqRes(req, res));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'killAll',
    value: function killAll() {
      var cmd;
      return _regeneratorRuntime.async(function killAll$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            cmd = undefined;

            // js hint cannot handle backticks, even escaped, within template literals
            cmd = "FOR /F \"usebackq tokens=5\" %a in (`netstat -nao ^| " + "findstr /R /C:\"" + this.proxyPort + " \"`) do (" + "FOR /F \"usebackq\" %b in (`TASKLIST /FI \"PID eq %a\" ^| " + "findstr /I winappdriver.exe`) do (IF NOT %b==\"\" TASKKILL " + "/F /PID %a))";
            _logger2['default'].info('Killing any old WinAppDrivers on same port, running: ' + cmd);
            context$2$0.prev = 3;
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(_bluebird2['default'].promisify(_child_process2['default'].exec)(cmd));

          case 6:
            _logger2['default'].info("Successfully cleaned up old WinAppDrivers");
            context$2$0.next = 12;
            break;

          case 9:
            context$2$0.prev = 9;
            context$2$0.t0 = context$2$0['catch'](3);

            _logger2['default'].info("No old WinAppDrivers seemed to exist");

          case 12:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[3, 9]]);
    }
  }, {
    key: 'deleteSession',
    value: function deleteSession() {
      return _regeneratorRuntime.async(function deleteSession$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Deleting WinAppDriver server session');
            // rely on jwproxy's intelligence to know what we're talking about and
            // delete the current session
            context$2$0.prev = 1;
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/', 'DELETE'));

          case 4:
            context$2$0.next = 9;
            break;

          case 6:
            context$2$0.prev = 6;
            context$2$0.t0 = context$2$0['catch'](1);

            _logger2['default'].warn('Did not get confirmation WinAppDriver deleteSession worked; ' + ('Error was: ' + context$2$0.t0));

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[1, 6]]);
    }
  }]);

  return WinAppDriver;
})(_events2['default'].EventEmitter);

WinAppDriver.EVENT_ERROR = 'winappdriver_error';
WinAppDriver.EVENT_CHANGED = 'stateChanged';
WinAppDriver.STATE_STOPPED = 'stopped';
WinAppDriver.STATE_STARTING = 'starting';
WinAppDriver.STATE_ONLINE = 'online';
WinAppDriver.STATE_STOPPING = 'stopping';

exports.WinAppDriver = WinAppDriver;
exports.DEFAULT_WAD_HOST = DEFAULT_WAD_HOST;
exports.DEFAULT_WAD_PORT = DEFAULT_WAD_PORT;
exports['default'] = WinAppDriver;

// we need to make sure WAD hasn't crashed

// use cp.exec instead of teen process because of crazy windows quoting
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi93aW5hcHBkcml2ZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBQW1CLFFBQVE7Ozs7Z0NBQ0gsb0JBQW9COztzQkFDNUIsVUFBVTs7Ozs0QkFDQyxjQUFjOzt5QkFDRyxhQUFhOzt3QkFDM0IsVUFBVTs7NkJBQ3pCLGVBQWU7Ozs7d0JBQ2hCLFVBQVU7Ozs7QUFFeEIsSUFBTSxXQUFXLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM1QixJQUFNLGdCQUFnQixHQUFHLFdBQVcsQ0FBQztBQUNyQyxJQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQzs7SUFFeEIsWUFBWTtZQUFaLFlBQVk7O0FBQ0osV0FEUixZQUFZLEdBQ1E7UUFBWCxJQUFJLHlEQUFHLEVBQUU7OzBCQURsQixZQUFZOztRQUVQLElBQUksR0FBVSxJQUFJLENBQWxCLElBQUk7UUFBRSxJQUFJLEdBQUksSUFBSSxDQUFaLElBQUk7O0FBQ2pCLCtCQUhFLFlBQVksNkNBR047Ozs7Ozs7QUFFUix3Q0FBZ0IsV0FBVyw0R0FBRTtZQUFwQixHQUFHOztBQUNWLFlBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDdkIsZ0JBQU0sSUFBSSxLQUFLLGVBQVksR0FBRyxxQkFBaUIsQ0FBQztTQUNqRDtBQUNELFlBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFRCxRQUFJLENBQUMsU0FBUyxHQUFHLElBQUksSUFBSSxnQkFBZ0IsQ0FBQztBQUMxQyxRQUFJLENBQUMsU0FBUyxHQUFHLElBQUksSUFBSSxnQkFBZ0IsQ0FBQztBQUMxQyxRQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNqQixRQUFJLENBQUMsS0FBSyxHQUFHLFlBQVksQ0FBQyxhQUFhLENBQUM7QUFDeEMsUUFBSSxDQUFDLE9BQU8sR0FBRyw4QkFB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Ozs7Ozs2Q0FJMUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQzs7Ozs7Ozs7OztBQUV6QyxnQ0FBSSxJQUFJLENBQUMsaUdBQ1ksQ0FBQyxDQUFDOzs7Ozs7O0tBRTFCOzs7U0FyTEcsWUFBWTtHQUFTLG9CQUFPLFlBQVk7O0FBd0w5QyxZQUFZLENBQUMsV0FBVyxHQUFHLG9CQUFvQixDQUFDO0FBQ2hELFlBQVksQ0FBQyxhQUFhLEdBQUcsY0FBYyxDQUFDO0FBQzVDLFlBQVksQ0FBQyxhQUFhLEdBQUcsU0FBUyxDQUFDO0FBQ3ZDLFlBQVksQ0FBQyxjQUFjLEdBQUcsVUFBVSxDQUFDO0FBQ3pDLFlBQVksQ0FBQyxZQUFZLEdBQUcsUUFBUSxDQUFDO0FBQ3JDLFlBQVksQ0FBQyxjQUFjLEdBQUcsVUFBVSxDQUFDOztRQUVoQyxZQUFZLEdBQVosWUFBWTtRQUFFLGdCQUFnQixHQUFoQixnQkFBZ0I7UUFBRSxnQkFBZ0IsR0FBaEIsZ0JBQWdCO3FCQUMxQyxZQUFZIiwiZmlsZSI6ImxpYi93aW5hcHBkcml2ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBKV1Byb3h5IH0gZnJvbSAnYXBwaXVtLWJhc2UtZHJpdmVyJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyBXQURfSU5TVEFMTF9QQVRILCB2ZXJpZnlXQUQgfSBmcm9tICcuL2luc3RhbGxlcic7XG5pbXBvcnQgeyByZXRyeUludGVydmFsIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IGNwIGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuXG5jb25zdCBSRVFEX1BBUkFNUyA9IFsnYXBwJ107XG5jb25zdCBERUZBVUxUX1dBRF9IT1NUID0gJzEyNy4wLjAuMSc7XG5jb25zdCBERUZBVUxUX1dBRF9QT1JUID0gNDcyNDsgLy8gIHNob3VsZCBiZSBub24tNDcyMyB0byBhdm9pZCBjb25mbGljdCBvbiB0aGUgc2FtZSBib3hcblxuY2xhc3MgV2luQXBwRHJpdmVyIGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBjb25zdCB7aG9zdCwgcG9ydH0gPSBvcHRzO1xuICAgIHN1cGVyKCk7XG5cbiAgICBmb3IgKGxldCByZXEgb2YgUkVRRF9QQVJBTVMpIHtcbiAgICAgIGlmICghb3B0cyB8fCAhb3B0c1tyZXFdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT3B0aW9uICcke3JlcX0nIGlzIHJlcXVpcmVkIWApO1xuICAgICAgfVxuICAgICAgdGhpc1tyZXFdID0gb3B0c1tyZXFdO1xuICAgIH1cblxuICAgIHRoaXMucHJveHlIb3N0ID0gaG9zdCB8fCBERUZBVUxUX1dBRF9IT1NUO1xuICAgIHRoaXMucHJveHlQb3J0ID0gcG9ydCB8fCBERUZBVUxUX1dBRF9QT1JUO1xuICAgIHRoaXMucHJvYyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IFdpbkFwcERyaXZlci5TVEFURV9TVE9QUEVEO1xuICAgIHRoaXMuandwcm94eSA9IG5ldyBKV1Byb3h5KHtzZXJ2ZXI6IHRoaXMucHJveHlIb3N0LCBwb3J0OiB0aGlzLnByb3h5UG9ydH0pO1xuICB9XG5cbiAgYXN5bmMgc3RhcnQgKCkge1xuICAgIGlmICghYXdhaXQgdmVyaWZ5V0FEKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCB2ZXJpZnkgV2luQXBwRHJpdmVyIGluc3RhbGw7IHJlLXJ1biBpbnN0YWxsXCIpO1xuICAgIH1cbiAgICAgICAgXG4gICAgdGhpcy5jaGFuZ2VTdGF0ZShXaW5BcHBEcml2ZXIuU1RBVEVfU1RBUlRJTkcpO1xuICAgIFxuICAgIC8vIFhYWFlEIFRPRE86IHdvdWxkIGJlIGJldHRlciBpZiBXaW5BcHBEcml2ZXIgZGlkbid0IHJlcXVpcmUgcGFzc2luZyBpbiAvd2QvaHViIGFzIGEgcGFyYW1cbiAgICBsZXQgYXJncyA9IFt0aGlzLnByb3h5UG9ydCArIFwiL3dkL2h1YlwiXTtcblxuICAgIGNvbnN0IHN0YXJ0RGV0ZWN0b3IgPSAoc3Rkb3V0KSA9PiB7XG4gICAgICByZXR1cm4gc3Rkb3V0LmluZGV4T2YoXCJsaXN0ZW5pbmcgZm9yIHJlcXVlc3RzXCIpICE9PSAtMTsgICAgICAgIFxuICAgIH07XG5cbiAgICBsZXQgcHJvY2Vzc0lzQWxpdmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5raWxsQWxsKCk7XG5cbiAgICAgIC8vIHNldCB1cCBvdXIgc3VicHJvY2VzcyBvYmplY3RcbiAgICAgIHRoaXMucHJvYyA9IG5ldyBTdWJQcm9jZXNzKFdBRF9JTlNUQUxMX1BBVEgsIGFyZ3MsIHtcbiAgICAgICAgZW5jb2Rpbmc6ICd1Y3MyJ1xuICAgICAgfSk7XG4gICAgICBwcm9jZXNzSXNBbGl2ZSA9IHRydWU7XG5cbiAgICAgIC8vIGhhbmRsZSBsb2cgb3V0cHV0XG4gICAgICBmb3IgKGxldCBzdHJlYW0gb2YgWydTVERPVVQnLCAnU1RERVJSJ10pIHtcbiAgICAgICAgdGhpcy5wcm9jLm9uKGBsaW5lcy0ke3N0cmVhbS50b0xvd2VyQ2FzZSgpfWAsIChsaW5lcykgPT4ge1xuICAgICAgICAgIGZvciAobGV0IGwgb2YgbGluZXMpIHtcbiAgICAgICAgICAgIGxvZy5pbmZvKGBbJHtzdHJlYW19XSAke2wudHJpbSgpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBvdXQtb2YtYm91bmQgZXhpdCBieSBzaW1wbHkgZW1pdHRpbmcgYSBzdG9wcGVkIHN0YXRlXG4gICAgICB0aGlzLnByb2Mub24oJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgIHByb2Nlc3NJc0FsaXZlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQSU5HKSB7XG4gICAgICAgICAgbGV0IG1zZyA9IGBXaW5BcHBEcml2ZXIgZXhpdGVkIHVuZXhwZWN0ZWRseSB3aXRoIGNvZGUgJHtjb2RlfSwgYCArXG4gICAgICAgICAgICAgICAgICAgIGBzaWduYWwgJHtzaWduYWx9YDtcbiAgICAgICAgICBsb2cuZXJyb3IobXNnKTtcbiAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFdpbkFwcERyaXZlci5TVEFURV9TVE9QUEVEKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsb2cuaW5mbyhgU3Bhd25pbmcgd2luYXBwZHJpdmVyIHdpdGg6ICR7YXJncy5qb2luKCcgJyl9YCk7XG5cbiAgICAgIC8vIHN0YXJ0IHN1YnByb2MgYW5kIHdhaXQgZm9yIHN0YXJ0RGV0ZWN0b3JcbiAgICAgIGF3YWl0IHRoaXMucHJvYy5zdGFydChzdGFydERldGVjdG9yKTtcbiAgICAgIGF3YWl0IHRoaXMud2FpdEZvck9ubGluZSgpO1xuXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5lbWl0KFdpbkFwcERyaXZlci5FVkVOVF9FUlJPUiwgZSk7XG4gICAgICAvLyBqdXN0IGJlY2F1c2Ugd2UgaGFkIGFuIGVycm9yIGRvZXNuJ3QgbWVhbiB0aGUgd2luYXBwZHJpdmVyIHByb2Nlc3NcbiAgICAgIC8vIGZpbmlzaGVkOyB3ZSBzaG91bGQgY2xlYW4gdXAgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAocHJvY2Vzc0lzQWxpdmUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGUpO1xuICAgIH1cbiAgfSAgICAgIFxuXG4gIHNlc3Npb25JZCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFdpbkFwcERyaXZlci5TVEFURV9PTkxJTkUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmp3cHJveHkuc2Vzc2lvbklkO1xuICB9XG5cbiAgYXN5bmMgd2FpdEZvck9ubGluZSAoKSB7XG5cbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBXQUQgaGFzbid0IGNyYXNoZWRcbiAgICBsZXQgd2luYXBwZHJpdmVyU3RvcHBlZCA9IGZhbHNlO1xuICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoMjAsIDIwMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKFtXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRCwgV2luQXBwRHJpdmVyLlNUQVRFX09OTElORV0uaW5kZXhPZih0aGlzLnN0YXRlKSA+PSAwKSB7XG4gICAgICAgIC8vIHdlIGFyZSBlaXRoZXIgc3RvcHBlZCwgc3RvcHBpbmcsIG9yIHdlJ3JlIG9ubGluZVxuICAgICAgICB3aW5hcHBkcml2ZXJTdG9wcGVkID0gdGhpcy5zdGF0ZSA9PT0gV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQRUQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGF3YWl0IHRoaXMuZ2V0U3RhdHVzKCkpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShXaW5BcHBEcml2ZXIuU1RBVEVfT05MSU5FKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh3aW5hcHBkcml2ZXJTdG9wcGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpbkFwcERyaXZlciBjcmFzaGVkIGR1cmluZyBzdGFydHVwLicpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFN0YXR1cyAoKSB7XG4gICAgY29uc3QgcmVzQmxvY2sgPSBhd2FpdCB0aGlzLmp3cHJveHkucHJveHkoJy9zdGF0dXMnLCAnR0VUJyk7XG4gICAgaWYgKHJlc0Jsb2NrWzBdLnN0YXR1c0NvZGUgPT09IDIwMCl7XG4gICAgICAgIGxvZy5pbmZvKGBTdGF0dXMgY2FsbCByZXR1cm5lZCAyMDAuIHdlJ3JlIG9ubGluZSBhbmQgcmVhZHkgdG8gcnVuIHRlc3RzYCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICB9XG4gICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0U2Vzc2lvbiAoY2Fwcykge1xuICAgIHRoaXMucHJveHlSZXFSZXMgPSB0aGlzLmp3cHJveHkucHJveHlSZXFSZXMuYmluZCh0aGlzLmp3cHJveHkpO1xuICAgIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKCcvc2Vzc2lvbicsICdQT1NUJywge2Rlc2lyZWRDYXBhYmlsaXRpZXM6IGNhcHN9KTtcbiAgfVxuXG4gIGFzeW5jIHN0b3AgKGVtaXRTdGF0ZXMgPSB0cnVlKSB7XG4gICAgaWYgKGVtaXRTdGF0ZXMpIHtcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQSU5HKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnByb2MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbWl0U3RhdGVzKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQRUQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZy5lcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VTdGF0ZSAoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgbG9nLmRlYnVnKGBXaW5BcHBEcml2ZXIgY2hhbmdlZCBzdGF0ZSB0byAnJHtzdGF0ZX0nYCk7XG4gICAgdGhpcy5lbWl0KFdpbkFwcERyaXZlci5FVkVOVF9DSEFOR0VELCB7c3RhdGV9KTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRDb21tYW5kICh1cmwsIG1ldGhvZCwgYm9keSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCh1cmwsIG1ldGhvZCwgYm9keSk7XG4gIH1cblxuICBhc3luYyBwcm94eVJlcSAocmVxLCByZXMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5qd3Byb3h5LnByb3h5UmVxUmVzKHJlcSwgcmVzKTtcbiAgfVxuXG4gIGFzeW5jIGtpbGxBbGwgKCkge1xuICAgIGxldCBjbWQ7XG4gICAgLy8ganMgaGludCBjYW5ub3QgaGFuZGxlIGJhY2t0aWNrcywgZXZlbiBlc2NhcGVkLCB3aXRoaW4gdGVtcGxhdGUgbGl0ZXJhbHNcbiAgICBjbWQgPSBcIkZPUiAvRiBcXFwidXNlYmFja3EgdG9rZW5zPTVcXFwiICVhIGluIChgbmV0c3RhdCAtbmFvIF58IFwiICtcbiAgICAgICAgICBcImZpbmRzdHIgL1IgL0M6XFxcIlwiICsgdGhpcy5wcm94eVBvcnQgKyBcIiBcXFwiYCkgZG8gKFwiICtcbiAgICAgICAgICBcIkZPUiAvRiBcXFwidXNlYmFja3FcXFwiICViIGluIChgVEFTS0xJU1QgL0ZJIFxcXCJQSUQgZXEgJWFcXFwiIF58IFwiICtcbiAgICAgICAgICBcImZpbmRzdHIgL0kgd2luYXBwZHJpdmVyLmV4ZWApIGRvIChJRiBOT1QgJWI9PVxcXCJcXFwiIFRBU0tLSUxMIFwiICtcbiAgICAgICAgICBcIi9GIC9QSUQgJWEpKVwiO1xuICAgIGxvZy5pbmZvKGBLaWxsaW5nIGFueSBvbGQgV2luQXBwRHJpdmVycyBvbiBzYW1lIHBvcnQsIHJ1bm5pbmc6ICR7Y21kfWApO1xuICAgIHRyeSB7XG4gICAgICAvLyB1c2UgY3AuZXhlYyBpbnN0ZWFkIG9mIHRlZW4gcHJvY2VzcyBiZWNhdXNlIG9mIGNyYXp5IHdpbmRvd3MgcXVvdGluZ1xuICAgICAgYXdhaXQgKEIucHJvbWlzaWZ5KGNwLmV4ZWMpKShjbWQpO1xuICAgICAgbG9nLmluZm8oXCJTdWNjZXNzZnVsbHkgY2xlYW5lZCB1cCBvbGQgV2luQXBwRHJpdmVyc1wiKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5pbmZvKFwiTm8gb2xkIFdpbkFwcERyaXZlcnMgc2VlbWVkIHRvIGV4aXN0XCIpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZVNlc3Npb24gKCkge1xuICAgIGxvZy5kZWJ1ZygnRGVsZXRpbmcgV2luQXBwRHJpdmVyIHNlcnZlciBzZXNzaW9uJyk7XG4gICAgLy8gcmVseSBvbiBqd3Byb3h5J3MgaW50ZWxsaWdlbmNlIHRvIGtub3cgd2hhdCB3ZSdyZSB0YWxraW5nIGFib3V0IGFuZFxuICAgIC8vIGRlbGV0ZSB0aGUgY3VycmVudCBzZXNzaW9uXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKCcvJywgJ0RFTEVURScpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYERpZCBub3QgZ2V0IGNvbmZpcm1hdGlvbiBXaW5BcHBEcml2ZXIgZGVsZXRlU2Vzc2lvbiB3b3JrZWQ7IGAgK1xuICAgICAgICBgRXJyb3Igd2FzOiAke2Vycn1gKTtcbiAgICB9XG4gIH1cbn1cblxuV2luQXBwRHJpdmVyLkVWRU5UX0VSUk9SID0gJ3dpbmFwcGRyaXZlcl9lcnJvcic7XG5XaW5BcHBEcml2ZXIuRVZFTlRfQ0hBTkdFRCA9ICdzdGF0ZUNoYW5nZWQnO1xuV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQRUQgPSAnc3RvcHBlZCc7XG5XaW5BcHBEcml2ZXIuU1RBVEVfU1RBUlRJTkcgPSAnc3RhcnRpbmcnO1xuV2luQXBwRHJpdmVyLlNUQVRFX09OTElORSA9ICdvbmxpbmUnO1xuV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQSU5HID0gJ3N0b3BwaW5nJztcblxuZXhwb3J0IHsgV2luQXBwRHJpdmVyLCBERUZBVUxUX1dBRF9IT1NULCBERUZBVUxUX1dBRF9QT1JUfTtcbmV4cG9ydCBkZWZhdWx0IFdpbkFwcERyaXZlcjtcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
