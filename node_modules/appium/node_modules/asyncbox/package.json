{
  "name": "asyncbox",
  "description": "A collection of small async/await utilities",
  "tags": [
    "async/await",
    "es7",
    "async"
  ],
  "version": "2.3.2",
  "author": {
    "name": "jlipps@gmail.com"
  },
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jlipps/asyncbox.git"
  },
  "bugs": {
    "url": "https://github.com/jlipps/asyncbox/issues"
  },
  "engines": [
    "node"
  ],
  "main": "./build/lib/asyncbox.js",
  "bin": {},
  "directories": {
    "lib": "./lib"
  },
  "dependencies": {
    "babel-runtime": "=5.8.24",
    "bluebird": "^2.9.34",
    "chai": "^3.2.0",
    "chai-as-promised": "^5.1.0",
    "es6-mapify": "^1.1.0",
    "lodash": "^4.17.4",
    "source-map-support": "^0.3.1"
  },
  "scripts": {
    "prepublish": "gulp prepublish",
    "test": "gulp once",
    "e2e-test": "gulp e2e-test",
    "build": "gulp transpile",
    "lint": "gulp eslint",
    "watch": "gulp watch"
  },
  "devDependencies": {
    "appium-gulp-plugins": "^2.2.0",
    "eslint": "^3.18.0",
    "eslint-config-appium": "^2.0.1",
    "eslint-plugin-babel": "^3.3.0",
    "eslint-plugin-import": "^2.2.0",
    "eslint-plugin-mocha": "^4.7.0",
    "eslint-plugin-promise": "^3.3.1",
    "gulp": "^3.8.11",
    "request": "^2.47.0",
    "should": "^7.0.4"
  },
  "readme": "asyncbox\n========\n\nA collection of ES7 async/await utilities. Install via NPM:\n\n```\nnpm install asyncbox\n```\n\nThen, behold!\n\n### Sleep\n\nAn async/await version of setTimeout\n\n```js\nimport { sleep } from 'asyncbox';\n\nasync function myFn () {\n    // do some stuff\n    await sleep(1000); // wait one second\n    // do some other stuff\n};\n```\n\n### Retry\n\nAn async/await way of running a method until it doesn't throw an error\n\n```js\nimport { sleep, retry } from 'asyncbox';\n\nasync function flakeyFunction (val1, val2) {\n    if (val1 < 10) {\n        throw new Error(\"this is a flakey value\");\n    }\n    await sleep(1000);\n    return val1 + val2;\n}\n\nasync function myFn () {\n    let randVals = [Math.random() * 100, Math.random() * 100];\n\n    // run flakeyFunction up to 3 times until it succeeds.\n    // if it doesn't, we'll get the error thrown in this context\n    let randSum = await retry(3, flakeyFunction, ...randVals);\n}\n```\n\nYou can also use `retryInterval` to add a sleep in between retries. This can be\nuseful if you want to throttle how fast we retry:\n\n```js\nawait retryInterval(3, 1500, expensiveFunction, ...args);\n```\n\n### Filter/Map\n\nFilter and map are pretty handy concepts, and now you can write filter and map\nfunctions that execute asynchronously!\n\n```js\nimport { asyncmap, asyncfilter } from 'asyncbox';\n```\n\nThen in your async functions, you can do:\n\n```js\nconst items = [1, 2, 3, 4];\nconst slowSquare = async (n) => { await sleep(5); return n * 2; };\nlet newItems = await asyncmap(items, async (i) => { return await slowSquare(i); });\nconsole.log(newItems);  // [1, 4, 9, 16];\n\nconst slowEven = async (n) => { await sleep(5); return n % 2 === 0; };\nnewItems = await asyncfilter(items, async (i) => { return await slowEven(i); });\nconsole.log(newItems); // [2, 4];\n```\n\nBy default, `asyncmap` and `asyncfilter` run their operations in parallel; you\ncan pass `false` as a third argument to make sure it happens serially.\n\n### Nodeify\n\nExport async functions (Promises) and import this with your ES5 code to use it\nwith Node.\n\n```js\nvar asyncbox = require('asyncbox')\n  , sleep = asyncbox.sleep\n  , nodeify = asyncbox.nodeify;\n\nnodeify(sleep(1000), function (err, timer) {\n  console.log(err); // null\n  console.log(timer); // timer obj\n});\n```\n\n### nodeifyAll\n\nIf you have a whole library you want to export nodeified versions of, it's pretty easy:\n\n```js\nimport { nodeifyAll } from 'asyncbox';\n\nasync function foo () { ... }\nasync function bar () { ... }\nlet cb = nodeifyAll({foo, bar});\nexport { foo, bar, cb };\n```\n\nThen in my ES5 script I can do:\n\n```js\nvar myLib = require('mylib').cb;\n\nmyLib.foo(function (err) { ... });\nmyLib.bar(function (err) { ... });\n```\n\n### waitForCondition\n\nTakes a condition (a function returning a boolean or boolean promise),\nand waits until the condition is true.\n\nThrows a `/Condition unmet/` error if the condition has not been\nsatisfied within the allocated time.\n\nThe default options are: `{ waitMs: 5000, intervalMs: 500 }`\n\n```js\n// define your own condition\nfunction condFn () { return Math.random()*1000 > 995; }\n\n// with default params\nawait waitForCondition(condFn);\n\n// with options\nawait waitForCondition(condFn, {\n  waitMs: 300000,\n  intervalMs: 10000\n});\n\n// pass a logger to get extra debug info\nawait waitForCondition(condFn, {\n  waitMs: 300000,\n  intervalMs: 10000\n  logger: myLogger // expects a debug method\n});\n```\n\n### Run the tests\n\n```\nnpm test\n```\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/jlipps/asyncbox#readme",
  "_id": "asyncbox@2.3.2",
  "_shasum": "df31086e28825090284480ea92c67ea038dc6f98",
  "_resolved": "https://registry.npmjs.org/asyncbox/-/asyncbox-2.3.2.tgz",
  "_from": "https://registry.npmjs.org/asyncbox/-/asyncbox-2.3.2.tgz"
}
