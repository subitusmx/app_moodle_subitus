'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Symbol$iterator = require('babel-runtime/core-js/symbol/iterator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _nodeSimctl = require('node-simctl');

var simctl = _interopRequireWildcard(_nodeSimctl);

var _appiumXcode = require('appium-xcode');

var _appiumXcode2 = _interopRequireDefault(_appiumXcode);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _appiumSupport = require('appium-support');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _asyncLock = require('async-lock');

var _asyncLock2 = _interopRequireDefault(_asyncLock);

var _utilsJs = require('./utils.js');

var _asyncbox = require('asyncbox');

var _settings = require('./settings');

var settings = _interopRequireWildcard(_settings);

var _teen_process = require('teen_process');

var _tailUntilJs = require('./tail-until.js');

var _extensionsIndex = require('./extensions/index');

var _extensionsIndex2 = _interopRequireDefault(_extensionsIndex);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _calendar = require('./calendar');

var _calendar2 = _interopRequireDefault(_calendar);

var EventEmitter = _events2['default'].EventEmitter;

var STARTUP_TIMEOUT = 60 * 1000;
var EXTRA_STARTUP_TIME = 2000;
var UI_CLIENT_ACCESS_GUARD = new _asyncLock2['default']();

/*
 * This event is emitted as soon as iOS Simulator
 * has finished booting and it is ready to accept xcrun commands.
 * The event handler is called after 'run' method is completed
 * for Xcode 7 and older and is only useful in Xcode 8+,
 * since one can start doing stuff (for example install/uninstall an app) in parallel
 * with Simulator UI startup, which shortens session startup time.
 */
var BOOT_COMPLETED_EVENT = 'bootCompleted';

var SimulatorXcode6 = (function (_EventEmitter) {
  _inherits(SimulatorXcode6, _EventEmitter);

  /**
   * Constructs the object with the `udid` and version of Xcode. Use the exported `getSimulator(udid)` method instead.
   *
   * @param {string} udid - The Simulator ID.
   * @param {object} xcodeVersion - The target Xcode version in format {major, minor, build}.
   */

  function SimulatorXcode6(udid, xcodeVersion) {
    _classCallCheck(this, SimulatorXcode6);

    _get(Object.getPrototypeOf(SimulatorXcode6.prototype), 'constructor', this).call(this);
    this.udid = String(udid);
    this.xcodeVersion = xcodeVersion;

    // platformVersion cannot be found initially, since getting it has side effects for
    // our logic for figuring out if a sim has been run
    // it will be set when it is needed
    this._platformVersion = null;

    this.keychainPath = _path2['default'].resolve(this.getDir(), 'Library', 'Keychains');
    this.simulatorApp = 'iOS Simulator.app';

    this.appDataBundlePaths = {};

    // list of files to check for when seeing if a simulator is "fresh"
    // (meaning it has never been booted).
    // If these files are present, we assume it's been successfully booted
    this.isFreshFiles = ['Library/ConfigurationProfiles', 'Library/Cookies', 'Library/Preferences/.GlobalPreferences.plist', 'Library/Preferences/com.apple.springboard.plist', 'var/run/syslog.pid'];

    // extra time to wait for simulator to be deemed booted
    this.extraStartupTime = EXTRA_STARTUP_TIME;

    this.calendar = new _calendar2['default'](this.getDir());
  }

  /**
   * Check the state of Simulator UI client.
   *
   * @return {boolean} True of if UI client is running or false otherwise.
   */

  _createClass(SimulatorXcode6, [{
    key: 'isUIClientRunning',
    value: function isUIClientRunning() {
      return _regeneratorRuntime.async(function isUIClientRunning$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.prev = 0;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('pgrep', ['-x', this.simulatorApp.split('.')[0]]));

          case 3:
            return context$2$0.abrupt('return', true);

          case 6:
            context$2$0.prev = 6;
            context$2$0.t0 = context$2$0['catch'](0);
            return context$2$0.abrupt('return', false);

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[0, 6]]);
    }

    /**
     * How long to wait before throwing an error about Simulator startup timeout happened.
     *
     * @return {number} The number of milliseconds.
     */
  }, {
    key: 'getPlatformVersion',

    /**
     * Get the platform version of the current Simulator.
     *
     * @return {string} SDK version, for example '8.3'.
     */
    value: function getPlatformVersion() {
      var _ref, sdk;

      return _regeneratorRuntime.async(function getPlatformVersion$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this._platformVersion) {
              context$2$0.next = 6;
              break;
            }

            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.stat());

          case 3:
            _ref = context$2$0.sent;
            sdk = _ref.sdk;

            this._platformVersion = sdk;

          case 6:
            return context$2$0.abrupt('return', this._platformVersion);

          case 7:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Retrieve the full path to the directory where Simulator stuff is located.
     *
     * @return {string} The path string.
     */
  }, {
    key: 'getRootDir',
    value: function getRootDir() {
      var home = process.env.HOME;
      return _path2['default'].resolve(home, 'Library', 'Developer', 'CoreSimulator', 'Devices');
    }

    /**
     * Retrieve the full path to the directory where Simulator applications data is located.
     *
     * @return {string} The path string.
     */
  }, {
    key: 'getDir',
    value: function getDir() {
      return _path2['default'].resolve(this.getRootDir(), this.udid, 'data');
    }

    /**
     * Retrieve the full path to the directory where Simulator logs are stored.
     *
     * @return {string} The path string.
     */
  }, {
    key: 'getLogDir',
    value: function getLogDir() {
      var home = process.env.HOME;
      return _path2['default'].resolve(home, 'Library', 'Logs', 'CoreSimulator', this.udid);
    }

    /**
     * Install valid .app package on Simulator.
     *
     * @param {string} app - The path to the .app package.
     */
  }, {
    key: 'installApp',
    value: function installApp(app) {
      return _regeneratorRuntime.async(function installApp$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(simctl.installApp(this.udid, app));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Verify whether the particular application is installed on Simulator.
     *
     * @param {string} bundleId - The bundle id of the application to be checked.
     * @param {string} appFule - Application name minus ".app" (for iOS 7.1)
     * @return {boolean} True if the given application is installed
     */
  }, {
    key: 'isAppInstalled',
    value: function isAppInstalled(bundleId) {
      var appFile = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
      var appDirs;
      return _regeneratorRuntime.async(function isAppInstalled$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.getAppDirs(appFile, bundleId));

          case 2:
            appDirs = context$2$0.sent;
            return context$2$0.abrupt('return', appDirs.length !== 0);

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Retrieve the directory for a particular application's data.
     *
     * @param {string} id - Either a bundleId (e.g., com.apple.mobilesafari) or, for iOS 7.1, the app name without `.app` (e.g., MobileSafari)
     * @param {string} subdir - The sub-directory we expect to be within the application directory. Defaults to "Data".
     * @return {string} The root application folder.
     */
  }, {
    key: 'getAppDir',
    value: function getAppDir(id) {
      var subDir = arguments.length <= 1 || arguments[1] === undefined ? 'Data' : arguments[1];
      return _regeneratorRuntime.async(function getAppDir$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.appDataBundlePaths[subDir] = this.appDataBundlePaths[subDir] || {};
            context$2$0.t0 = _lodash2['default'].isEmpty(this.appDataBundlePaths[subDir]);

            if (!context$2$0.t0) {
              context$2$0.next = 6;
              break;
            }

            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.isFresh());

          case 5:
            context$2$0.t0 = !context$2$0.sent;

          case 6:
            if (!context$2$0.t0) {
              context$2$0.next = 10;
              break;
            }

            context$2$0.next = 9;
            return _regeneratorRuntime.awrap(this.buildBundlePathMap(subDir));

          case 9:
            this.appDataBundlePaths[subDir] = context$2$0.sent;

          case 10:
            return context$2$0.abrupt('return', this.appDataBundlePaths[subDir][id]);

          case 11:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * The xcode 6 simulators are really annoying, and bury the main app
     * directories inside directories just named with Hashes.
     * This function finds the proper directory by traversing all of them
     * and reading a metadata plist (Mobile Container Manager) to get the
     * bundle id.
     *
     * @param {string} subdir - The sub-directory we expect to be within the application directory. Defaults to "Data".
     * @return {object} The list of path-bundle pairs to an object where bundleIds are mapped to paths.
     */
  }, {
    key: 'buildBundlePathMap',
    value: function buildBundlePathMap() {
      var subDir = arguments.length <= 0 || arguments[0] === undefined ? 'Data' : arguments[0];
      var applicationList, pathBundlePair, bundlePathDirs, bundlePathPairs;
      return _regeneratorRuntime.async(function buildBundlePathMap$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Building bundle path map');
            applicationList = undefined;
            pathBundlePair = undefined;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.getPlatformVersion());

          case 5:
            context$2$0.t0 = context$2$0.sent;

            if (!(context$2$0.t0 === '7.1')) {
              context$2$0.next = 11;
              break;
            }

            // apps available
            //   Web.app,
            //   WebViewService.app,
            //   MobileSafari.app,
            //   WebContentAnalysisUI.app,
            //   DDActionsService.app,
            //   StoreKitUIService.app
            applicationList = _path2['default'].resolve(this.getDir(), 'Applications');
            pathBundlePair = function callee$2$0(dir) {
              var appFiles, bundleId;
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    dir = _path2['default'].resolve(applicationList, dir);
                    context$3$0.next = 3;
                    return _regeneratorRuntime.awrap(_appiumSupport.fs.glob(dir + '/*.app'));

                  case 3:
                    appFiles = context$3$0.sent;
                    bundleId = appFiles[0].match(/.*\/(.*)\.app/)[1];
                    return context$3$0.abrupt('return', { path: dir, bundleId: bundleId });

                  case 6:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this);
            };
            context$2$0.next = 12;
            break;

          case 11:
            (function () {
              applicationList = _path2['default'].resolve(_this.getDir(), 'Containers', subDir, 'Application');
              // given a directory, find the plist file and pull the bundle id from it
              var readBundleId = function readBundleId(dir) {
                var plist, metadata;
                return _regeneratorRuntime.async(function readBundleId$(context$4$0) {
                  while (1) switch (context$4$0.prev = context$4$0.next) {
                    case 0:
                      plist = _path2['default'].resolve(dir, '.com.apple.mobile_container_manager.metadata.plist');
                      context$4$0.next = 3;
                      return _regeneratorRuntime.awrap(settings.read(plist));

                    case 3:
                      metadata = context$4$0.sent;
                      return context$4$0.abrupt('return', metadata.MCMMetadataIdentifier);

                    case 5:
                    case 'end':
                      return context$4$0.stop();
                  }
                }, null, _this);
              };
              // given a directory, return the path and bundle id associated with it
              pathBundlePair = function callee$3$0(dir) {
                var bundleId;
                return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                  while (1) switch (context$4$0.prev = context$4$0.next) {
                    case 0:
                      dir = _path2['default'].resolve(applicationList, dir);
                      context$4$0.next = 3;
                      return _regeneratorRuntime.awrap(readBundleId(dir));

                    case 3:
                      bundleId = context$4$0.sent;
                      return context$4$0.abrupt('return', { path: dir, bundleId: bundleId });

                    case 5:
                    case 'end':
                      return context$4$0.stop();
                  }
                }, null, _this);
              };
            })();

          case 12:
            context$2$0.next = 14;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.readdir(applicationList));

          case 14:
            bundlePathDirs = context$2$0.sent;
            context$2$0.next = 17;
            return _regeneratorRuntime.awrap((0, _asyncbox.asyncmap)(bundlePathDirs, function callee$2$0(dir) {
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.next = 2;
                    return _regeneratorRuntime.awrap(pathBundlePair(dir));

                  case 2:
                    return context$3$0.abrupt('return', context$3$0.sent);

                  case 3:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this);
            }, false));

          case 17:
            bundlePathPairs = context$2$0.sent;
            return context$2$0.abrupt('return', bundlePathPairs.reduce(function (bundleMap, bundlePath) {
              bundleMap[bundlePath.bundleId] = bundlePath.path;
              return bundleMap;
            }, {}));

          case 19:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Get the state and specifics of this sim.
     *
     * @return {object} Simulator stats mapping, for example:
     * { name: 'iPhone 4s',
     *   udid: 'C09B34E5-7DCB-442E-B79C-AB6BC0357417',
     *   state: 'Shutdown',
     *   sdk: '8.3'
     * }
     */
  }, {
    key: 'stat',
    value: function stat() {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, sdk, deviceArr, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, device;

      return _regeneratorRuntime.async(function stat$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            context$2$0.prev = 3;
            context$2$0.t0 = _lodash2['default'];
            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(simctl.getDevices());

          case 7:
            context$2$0.t1 = context$2$0.sent;
            context$2$0.t2 = _Symbol$iterator;
            _iterator = context$2$0.t0.toPairs.call(context$2$0.t0, context$2$0.t1)[context$2$0.t2]();

          case 10:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              context$2$0.next = 44;
              break;
            }

            _step$value = _slicedToArray(_step.value, 2);
            sdk = _step$value[0];
            deviceArr = _step$value[1];
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _iteratorError2 = undefined;
            context$2$0.prev = 17;
            _iterator2 = _getIterator(deviceArr);

          case 19:
            if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
              context$2$0.next = 27;
              break;
            }

            device = _step2.value;

            if (!(device.udid === this.udid)) {
              context$2$0.next = 24;
              break;
            }

            device.sdk = sdk;
            return context$2$0.abrupt('return', device);

          case 24:
            _iteratorNormalCompletion2 = true;
            context$2$0.next = 19;
            break;

          case 27:
            context$2$0.next = 33;
            break;

          case 29:
            context$2$0.prev = 29;
            context$2$0.t3 = context$2$0['catch'](17);
            _didIteratorError2 = true;
            _iteratorError2 = context$2$0.t3;

          case 33:
            context$2$0.prev = 33;
            context$2$0.prev = 34;

            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }

          case 36:
            context$2$0.prev = 36;

            if (!_didIteratorError2) {
              context$2$0.next = 39;
              break;
            }

            throw _iteratorError2;

          case 39:
            return context$2$0.finish(36);

          case 40:
            return context$2$0.finish(33);

          case 41:
            _iteratorNormalCompletion = true;
            context$2$0.next = 10;
            break;

          case 44:
            context$2$0.next = 50;
            break;

          case 46:
            context$2$0.prev = 46;
            context$2$0.t4 = context$2$0['catch'](3);
            _didIteratorError = true;
            _iteratorError = context$2$0.t4;

          case 50:
            context$2$0.prev = 50;
            context$2$0.prev = 51;

            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }

          case 53:
            context$2$0.prev = 53;

            if (!_didIteratorError) {
              context$2$0.next = 56;
              break;
            }

            throw _iteratorError;

          case 56:
            return context$2$0.finish(53);

          case 57:
            return context$2$0.finish(50);

          case 58:
            return context$2$0.abrupt('return', {});

          case 59:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[3, 46, 50, 58], [17, 29, 33, 41], [34,, 36, 40], [51,, 53, 57]]);
    }

    /**
     * This is a best-bet heuristic for whether or not a sim has been booted
     * before. We usually want to start a simulator to "warm" it up, have
     * Xcode populate it with plists for us to manipulate before a real
     * test run.
     *
     * @return {boolean} True if the current Simulator has never been started before
     */
  }, {
    key: 'isFresh',
    value: function isFresh() {
      var files, pv, existences, fresh;
      return _regeneratorRuntime.async(function isFresh$(context$2$0) {
        var _this2 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            // if the following files don't exist, it hasn't been booted.
            // THIS IS NOT AN EXHAUSTIVE LIST
            _logger2['default'].debug('Checking whether simulator has been run before');
            files = this.isFreshFiles;
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.getPlatformVersion());

          case 4:
            pv = context$2$0.sent;

            if (pv !== '7.1') {
              files.push('Library/Preferences/com.apple.Preferences.plist');
            } else {
              files.push('Applications');
            }

            files = files.map(function (s) {
              return _path2['default'].resolve(_this2.getDir(), s);
            });

            context$2$0.next = 9;
            return _regeneratorRuntime.awrap((0, _asyncbox.asyncmap)(files, function callee$2$0(f) {
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.next = 2;
                    return _regeneratorRuntime.awrap(_appiumSupport.fs.hasAccess(f));

                  case 2:
                    return context$3$0.abrupt('return', context$3$0.sent);

                  case 3:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this2);
            }));

          case 9:
            existences = context$2$0.sent;
            fresh = _lodash2['default'].compact(existences).length !== files.length;

            _logger2['default'].debug('Simulator ' + (fresh ? 'has not' : 'has') + ' been run before');
            return context$2$0.abrupt('return', fresh);

          case 13:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Retrieves the state of the current Simulator. One should distinguish the
     * states of Simulator UI and the Simulator itself.
     *
     * @return {boolean} True if the current Simulator is running.
     */
  }, {
    key: 'isRunning',
    value: function isRunning() {
      var stat;
      return _regeneratorRuntime.async(function isRunning$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.stat());

          case 2:
            stat = context$2$0.sent;
            return context$2$0.abrupt('return', stat.state === 'Booted');

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Verify whether the Simulator booting is completed and/or wait for it
     * until the timeout expires.
     *
     * @param {number} startupTimeout - the number of milliseconds to wait until booting is completed.
     * @emits BOOT_COMPLETED_EVENT if the current Simulator is ready to accept simctl commands, like 'install'.
     */
  }, {
    key: 'waitForBoot',
    value: function waitForBoot(startupTimeout) {
      var bootedIndicator;
      return _regeneratorRuntime.async(function waitForBoot$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.getBootedIndicatorString());

          case 2:
            bootedIndicator = context$2$0.sent;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.tailLogsUntil(bootedIndicator, startupTimeout));

          case 5:

            // so sorry, but we should wait another two seconds, just to make sure we've really started
            // we can't look for another magic log line, because they seem to be app-dependent (not system dependent)
            _logger2['default'].debug('Waiting an extra ' + this.extraStartupTime + 'ms for the simulator to really finish booting');
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(_bluebird2['default'].delay(this.extraStartupTime));

          case 8:
            _logger2['default'].debug('Done waiting extra time for simulator');

            this.emit(BOOT_COMPLETED_EVENT);

          case 10:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Returns a magic string, which, if present in logs, reflects the fact that simulator booting has been completed.
     *
     * @return {string} The magic log string.
     */
  }, {
    key: 'getBootedIndicatorString',
    value: function getBootedIndicatorString() {
      var indicator, platformVersion;
      return _regeneratorRuntime.async(function getBootedIndicatorString$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            indicator = undefined;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.getPlatformVersion());

          case 3:
            platformVersion = context$2$0.sent;
            context$2$0.t0 = platformVersion;
            context$2$0.next = context$2$0.t0 === '7.1' ? 7 : context$2$0.t0 === '8.1' ? 7 : context$2$0.t0 === '8.2' ? 7 : context$2$0.t0 === '8.3' ? 7 : context$2$0.t0 === '8.4' ? 7 : context$2$0.t0 === '9.0' ? 9 : context$2$0.t0 === '9.1' ? 9 : context$2$0.t0 === '9.2' ? 9 : context$2$0.t0 === '9.3' ? 9 : context$2$0.t0 === '10.0' ? 11 : 13;
            break;

          case 7:
            indicator = 'profiled: Service starting...';
            return context$2$0.abrupt('break', 15);

          case 9:
            indicator = 'System app "com.apple.springboard" finished startup';
            return context$2$0.abrupt('break', 15);

          case 11:
            indicator = 'Switching to keyboard';
            return context$2$0.abrupt('break', 15);

          case 13:
            _logger2['default'].warn('No boot indicator case for platform version \'' + platformVersion + '\'');
            indicator = 'no boot indicator string available';

          case 15:
            return context$2$0.abrupt('return', indicator);

          case 16:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Start the Simulator UI client with the given arguments
     *
     * @param {object} opts - One or more of available Simulator UI client options:
     *   - {string} scaleFactor: can be one of ['1.0', '0.75', '0.5', '0.33', '0.25'].
     *   Defines the window scale value for the UI client window for the current Simulator.
     *   Equals to null by default, which keeps the current scale unchanged.
     *   - {boolean} connectHardwareKeyboard: whether to connect the hardware keyboard to the
     *   Simulator UI client. Equals to false by default.
     *   - {number} startupTimeout: number of milliseconds to wait until Simulator booting
     *   process is completed. The default timeout will be used if not set explicitly.
     */
  }, {
    key: 'startUIClient',
    value: function startUIClient() {
      var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var simulatorApp, args, stat, formattedDeviceName, argumentName;
      return _regeneratorRuntime.async(function startUIClient$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            opts = _Object$assign({
              scaleFactor: null,
              connectHardwareKeyboard: false,
              startupTimeout: this.startupTimeout
            }, opts);

            context$2$0.t0 = _path2['default'];
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap((0, _appiumXcode.getPath)());

          case 4:
            context$2$0.t1 = context$2$0.sent;
            context$2$0.t2 = this.simulatorApp;
            simulatorApp = context$2$0.t0.resolve.call(context$2$0.t0, context$2$0.t1, 'Applications', context$2$0.t2);
            args = ['-Fn', simulatorApp, '--args', '-CurrentDeviceUDID', this.udid];

            if (!opts.scaleFactor) {
              context$2$0.next = 15;
              break;
            }

            context$2$0.next = 11;
            return _regeneratorRuntime.awrap(this.stat());

          case 11:
            stat = context$2$0.sent;
            formattedDeviceName = stat.name.replace(/\s+/g, '-');
            argumentName = '-SimulatorWindowLastScale-com.apple.CoreSimulator.SimDeviceType.' + formattedDeviceName;

            args.push(argumentName, opts.scaleFactor);

          case 15:

            if (_lodash2['default'].isBoolean(opts.connectHardwareKeyboard)) {
              args.push('-ConnectHardwareKeyboard', opts.connectHardwareKeyboard ? '1' : '0');
            }

            _logger2['default'].info('Starting Simulator UI with command: open ' + args.join(' '));
            context$2$0.next = 19;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('open', args, { timeout: opts.startupTimeout }));

          case 19:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Executes given Simulator with options. The Simulator will not be restarted if
     * it is already running.
     *
     * @param {object} opts - One or more of available Simulator options.
     *   See {#startUIClient(opts)} documentation for more details on other supported keys.
     */
  }, {
    key: 'run',
    value: function run() {
      var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var _ref2, state, isServerRunning, isUIClientRunning, startTime;

      return _regeneratorRuntime.async(function run$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            opts = _Object$assign({
              startupTimeout: this.startupTimeout
            }, opts);
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.stat());

          case 3:
            _ref2 = context$2$0.sent;
            state = _ref2.state;
            isServerRunning = state === 'Booted';
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(this.isUIClientRunning());

          case 8:
            isUIClientRunning = context$2$0.sent;

            if (!(isServerRunning && isUIClientRunning)) {
              context$2$0.next = 12;
              break;
            }

            _logger2['default'].info('Both Simulator with UDID ' + this.udid + ' and the UI client are currently running');
            return context$2$0.abrupt('return');

          case 12:
            startTime = process.hrtime();
            context$2$0.prev = 13;
            context$2$0.next = 16;
            return _regeneratorRuntime.awrap(this.shutdown());

          case 16:
            context$2$0.next = 21;
            break;

          case 18:
            context$2$0.prev = 18;
            context$2$0.t0 = context$2$0['catch'](13);

            _logger2['default'].warn('Error on Simulator shutdown: ' + context$2$0.t0.message);

          case 21:
            context$2$0.next = 23;
            return _regeneratorRuntime.awrap(this.startUIClient(opts));

          case 23:
            context$2$0.next = 25;
            return _regeneratorRuntime.awrap(this.waitForBoot(opts.startupTimeout));

          case 25:
            _logger2['default'].info('Simulator with UDID ' + this.udid + ' booted in ' + process.hrtime(startTime)[0] + ' seconds');

          case 26:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[13, 18]]);
    }

    // TODO keep keychains
    /**
     * Reset the current Simulator to the clean state.
     */
  }, {
    key: 'clean',
    value: function clean() {
      return _regeneratorRuntime.async(function clean$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.endSimulatorDaemon());

          case 2:
            _logger2['default'].info('Cleaning simulator ' + this.udid);
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(simctl.eraseDevice(this.udid, 10000));

          case 5:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Scrub (delete the preferences and changed files) the particular application on Simulator.
     *
     * @param {string} appFile - Application name minus ".app".
     * @param {string} appBundleId - Bundle identifier of the application.
     */
  }, {
    key: 'scrubCustomApp',
    value: function scrubCustomApp(appFile, appBundleId) {
      return _regeneratorRuntime.async(function scrubCustomApp$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.cleanCustomApp(appFile, appBundleId, true));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Clean/scrub the particular application on Simulator.
     *
     * @param {string} appFile - Application name minus ".app".
     * @param {string} appBundleId - Bundle identifier of the application.
     * @param {boolean} scrub - If `scrub` is false, we want to clean by deleting the app and all
     *   files associated with it. If `scrub` is true, we just want to delete the preferences and
     *   changed files.
     */
  }, {
    key: 'cleanCustomApp',
    value: function cleanCustomApp(appFile, appBundleId) {
      var scrub = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var appDirs, deletePromises, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, dir, relRmPath, rmPath;

      return _regeneratorRuntime.async(function cleanCustomApp$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Cleaning app data files for \'' + appFile + '\', \'' + appBundleId + '\'');
            if (!scrub) {
              _logger2['default'].debug('Deleting app altogether');
            }

            // get the directories to be deleted
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.getAppDirs(appFile, appBundleId, scrub));

          case 4:
            appDirs = context$2$0.sent;

            if (!(appDirs.length === 0)) {
              context$2$0.next = 8;
              break;
            }

            _logger2['default'].debug("Could not find app directories to delete. It is probably not installed");
            return context$2$0.abrupt('return');

          case 8:
            deletePromises = [];
            _iteratorNormalCompletion3 = true;
            _didIteratorError3 = false;
            _iteratorError3 = undefined;
            context$2$0.prev = 12;

            for (_iterator3 = _getIterator(appDirs); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              dir = _step3.value;

              _logger2['default'].debug('Deleting directory: \'' + dir + '\'');
              deletePromises.push(_appiumSupport.fs.rimraf(dir));
            }

            context$2$0.next = 20;
            break;

          case 16:
            context$2$0.prev = 16;
            context$2$0.t0 = context$2$0['catch'](12);
            _didIteratorError3 = true;
            _iteratorError3 = context$2$0.t0;

          case 20:
            context$2$0.prev = 20;
            context$2$0.prev = 21;

            if (!_iteratorNormalCompletion3 && _iterator3['return']) {
              _iterator3['return']();
            }

          case 23:
            context$2$0.prev = 23;

            if (!_didIteratorError3) {
              context$2$0.next = 26;
              break;
            }

            throw _iteratorError3;

          case 26:
            return context$2$0.finish(23);

          case 27:
            return context$2$0.finish(20);

          case 28:
            context$2$0.next = 30;
            return _regeneratorRuntime.awrap(this.getPlatformVersion());

          case 30:
            context$2$0.t1 = context$2$0.sent;

            if (!(context$2$0.t1 >= 8)) {
              context$2$0.next = 36;
              break;
            }

            relRmPath = 'Library/Preferences/' + appBundleId + '.plist';
            rmPath = _path2['default'].resolve(this.getRootDir(), relRmPath);

            _logger2['default'].debug('Deleting file: \'' + rmPath + '\'');
            deletePromises.push(_appiumSupport.fs.rimraf(rmPath));

          case 36:
            context$2$0.next = 38;
            return _regeneratorRuntime.awrap(_bluebird2['default'].all(deletePromises));

          case 38:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[12, 16, 20, 28], [21,, 23, 27]]);
    }

    /**
     * Retrieve paths to dirs where application data is stored. iOS 8+ stores app data in two places,
     * and iOS 7.1 has only one directory
     *
     * @param {string} appFile - Application name minus ".app".
     * @param {string} appBundleId - Bundle identifier of the application.
     * @param {boolean} scrub - The `Bundle` directory has the actual app in it. If we are just scrubbing,
     *   we want this to stay. If we are cleaning we delete.
     * @return {array<string>} Array of application data paths.
     */
  }, {
    key: 'getAppDirs',
    value: function getAppDirs(appFile, appBundleId) {
      var scrub = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var dirs, data, bundle, _arr, _i, src;

      return _regeneratorRuntime.async(function getAppDirs$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            dirs = [];
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.getPlatformVersion());

          case 3:
            context$2$0.t0 = context$2$0.sent;

            if (!(context$2$0.t0 >= 8)) {
              context$2$0.next = 22;
              break;
            }

            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(this.getAppDir(appBundleId));

          case 7:
            data = context$2$0.sent;

            if (data) {
              context$2$0.next = 10;
              break;
            }

            return context$2$0.abrupt('return', dirs);

          case 10:
            if (scrub) {
              context$2$0.next = 16;
              break;
            }

            context$2$0.next = 13;
            return _regeneratorRuntime.awrap(this.getAppDir(appBundleId, 'Bundle'));

          case 13:
            context$2$0.t1 = context$2$0.sent;
            context$2$0.next = 17;
            break;

          case 16:
            context$2$0.t1 = undefined;

          case 17:
            bundle = context$2$0.t1;
            _arr = [data, bundle];

            for (_i = 0; _i < _arr.length; _i++) {
              src = _arr[_i];

              if (src) {
                dirs.push(src);
              }
            }
            context$2$0.next = 26;
            break;

          case 22:
            context$2$0.next = 24;
            return _regeneratorRuntime.awrap(this.getAppDir(appFile));

          case 24:
            data = context$2$0.sent;

            if (data) {
              dirs.push(data);
            }

          case 26:
            return context$2$0.abrupt('return', dirs);

          case 27:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Execute the Simulator in order to have the initial file structure created and shutdown it afterwards.
     *
     * @param {boolean} safari - Whether to execute mobile Safari after startup.
     * @param {number} startupTimeout - How long to wait until Simulator booting is completed (in milliseconds).
     */
  }, {
    key: 'launchAndQuit',
    value: function launchAndQuit() {
      var safari = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
      var startupTimeout = arguments.length <= 1 || arguments[1] === undefined ? this.startupTimeout : arguments[1];
      return _regeneratorRuntime.async(function launchAndQuit$(context$2$0) {
        var _this3 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Attempting to launch and quit the simulator, to create directory structure');
            _logger2['default'].debug('Will launch with Safari? ' + safari);

            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.run(startupTimeout));

          case 4:
            if (!safari) {
              context$2$0.next = 7;
              break;
            }

            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(this.openUrl('http://www.appium.io'));

          case 7:
            context$2$0.next = 9;
            return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(20, 250, function callee$2$0() {
              var msg;
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.next = 2;
                    return _regeneratorRuntime.awrap(this.isFresh());

                  case 2:
                    if (!context$3$0.sent) {
                      context$3$0.next = 6;
                      break;
                    }

                    msg = 'Simulator files not fully created. Waiting a bit';

                    _logger2['default'].debug(msg);
                    throw new Error(msg);

                  case 6:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this3);
            }));

          case 9:
            context$2$0.next = 11;
            return _regeneratorRuntime.awrap(this.shutdown());

          case 11:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Looks for launchd daemons corresponding to the sim udid and tries to stop them cleanly
     * This prevents xcrun simctl erase from hanging.
     */
  }, {
    key: 'endSimulatorDaemon',
    value: function endSimulatorDaemon() {
      var launchctlCmd, stopCmd, removeCmd;
      return _regeneratorRuntime.async(function endSimulatorDaemon$(context$2$0) {
        var _this4 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Killing any simulator daemons for ' + this.udid);

            launchctlCmd = 'launchctl list | grep ' + this.udid + ' | cut -f 3 | xargs -n 1 launchctl';
            context$2$0.prev = 2;
            stopCmd = launchctlCmd + ' stop';
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', stopCmd]));

          case 6:
            context$2$0.next = 12;
            break;

          case 8:
            context$2$0.prev = 8;
            context$2$0.t0 = context$2$0['catch'](2);

            _logger2['default'].warn('Could not stop simulator daemons: ' + context$2$0.t0.message);
            _logger2['default'].debug('Carrying on anyway!');

          case 12:
            context$2$0.prev = 12;
            removeCmd = launchctlCmd + ' remove';
            context$2$0.next = 16;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', removeCmd]));

          case 16:
            context$2$0.next = 22;
            break;

          case 18:
            context$2$0.prev = 18;
            context$2$0.t1 = context$2$0['catch'](12);

            _logger2['default'].warn('Could not remove simulator daemons: ' + context$2$0.t1.message);
            _logger2['default'].debug('Carrying on anyway!');

          case 22:
            context$2$0.prev = 22;
            context$2$0.next = 25;
            return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$2$0() {
              var _ref3, stdout;

              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.next = 2;
                    return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', 'ps -e  | grep ' + this.udid + ' | grep launchd_sim | grep -v bash | grep -v grep | awk {\'print$1\'}']));

                  case 2:
                    _ref3 = context$3$0.sent;
                    stdout = _ref3.stdout;
                    return context$3$0.abrupt('return', stdout.trim().length === 0);

                  case 5:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this4);
            }, { waitMs: 10000, intervalMs: 500 }));

          case 25:
            context$2$0.next = 31;
            break;

          case 27:
            context$2$0.prev = 27;
            context$2$0.t2 = context$2$0['catch'](22);

            _logger2['default'].warn('Could not end simulator daemon for ' + this.udid + ': ' + context$2$0.t2.message);
            _logger2['default'].debug('Carrying on anyway!');

          case 31:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[2, 8], [12, 18], [22, 27]]);
    }

    /**
     * Shutdown all the running Simulators and the UI client.
     */
  }, {
    key: 'shutdown',
    value: function shutdown() {
      return _regeneratorRuntime.async(function shutdown$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap((0, _utilsJs.killAllSimulators)());

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Delete the particular Simulator from devices list
     */
  }, {
    key: 'delete',
    value: function _delete() {
      return _regeneratorRuntime.async(function _delete$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(simctl.deleteDevice(this.udid));

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Update the particular preference file with the given key/value pairs.
     *
     * @param {string} plist - The preferences file to update.
     * @param {object} updates - The key/value pairs to update.
     */
  }, {
    key: 'updateSettings',
    value: function updateSettings(plist, updates) {
      return _regeneratorRuntime.async(function updateSettings$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(settings.updateSettings(this, plist, updates));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Authorize/de-authorize location settings for a particular application.
     *
     * @param {string} bundleId - The application ID to update.
     * @param {boolean} authorized - Whether or not to authorize.
     */
  }, {
    key: 'updateLocationSettings',
    value: function updateLocationSettings(bundleId, authorized) {
      return _regeneratorRuntime.async(function updateLocationSettings$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(settings.updateLocationSettings(this, bundleId, authorized));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Update settings for Safari.
     *
     * @param {object} updates - The hash of key/value pairs to update for Safari.
     */
  }, {
    key: 'updateSafariSettings',
    value: function updateSafariSettings(updates) {
      return _regeneratorRuntime.async(function updateSafariSettings$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(settings.updateSafariUserSettings(this, updates));

          case 2:
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(settings.updateSettings(this, 'mobileSafari', updates));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Update the locale for the Simulator.
     *
     * @param {string} language - The language for the simulator. E.g., `"fr_US"`.
     * @param {string} locale - The locale to set for the simulator. E.g., `"en"`.
     * @param {string} calendarFormat - The format of the calendar.
     */
  }, {
    key: 'updateLocale',
    value: function updateLocale(language, locale, calendarFormat) {
      return _regeneratorRuntime.async(function updateLocale$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(settings.updateLocale(this, language, locale, calendarFormat));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Completely delete mobile Safari application from the current Simulator.
     */
  }, {
    key: 'deleteSafari',
    value: function deleteSafari() {
      var dirs, pv, deletePromises, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, dir;

      return _regeneratorRuntime.async(function deleteSafari$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Deleting Safari apps from simulator');

            dirs = [];
            context$2$0.t0 = dirs;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.getAppDir('com.apple.mobilesafari'));

          case 5:
            context$2$0.t1 = context$2$0.sent;
            context$2$0.t0.push.call(context$2$0.t0, context$2$0.t1);
            context$2$0.next = 9;
            return _regeneratorRuntime.awrap(this.getPlatformVersion());

          case 9:
            pv = context$2$0.sent;

            if (!(pv >= 8)) {
              context$2$0.next = 16;
              break;
            }

            context$2$0.t2 = dirs;
            context$2$0.next = 14;
            return _regeneratorRuntime.awrap(this.getAppDir('com.apple.mobilesafari', 'Bundle'));

          case 14:
            context$2$0.t3 = context$2$0.sent;
            context$2$0.t2.push.call(context$2$0.t2, context$2$0.t3);

          case 16:
            deletePromises = [];
            _iteratorNormalCompletion4 = true;
            _didIteratorError4 = false;
            _iteratorError4 = undefined;
            context$2$0.prev = 20;

            for (_iterator4 = _getIterator(_lodash2['default'].compact(dirs)); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              dir = _step4.value;

              _logger2['default'].debug('Deleting directory: \'' + dir + '\'');
              deletePromises.push(_appiumSupport.fs.rimraf(dir));
            }
            context$2$0.next = 28;
            break;

          case 24:
            context$2$0.prev = 24;
            context$2$0.t4 = context$2$0['catch'](20);
            _didIteratorError4 = true;
            _iteratorError4 = context$2$0.t4;

          case 28:
            context$2$0.prev = 28;
            context$2$0.prev = 29;

            if (!_iteratorNormalCompletion4 && _iterator4['return']) {
              _iterator4['return']();
            }

          case 31:
            context$2$0.prev = 31;

            if (!_didIteratorError4) {
              context$2$0.next = 34;
              break;
            }

            throw _iteratorError4;

          case 34:
            return context$2$0.finish(31);

          case 35:
            return context$2$0.finish(28);

          case 36:
            context$2$0.next = 38;
            return _regeneratorRuntime.awrap(_bluebird2['default'].all(deletePromises));

          case 38:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[20, 24, 28, 36], [29,, 31, 35]]);
    }

    /**
     * Clean up the directories for mobile Safari.
     *
     * @param {boolean} keepPrefs - Whether to keep Safari preferences from being deleted.
     */
  }, {
    key: 'cleanSafari',
    value: function cleanSafari() {
      var keepPrefs = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      var libraryDir, safariRoot, safariLibraryDir, filesToDelete, deletePromises, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, file;

      return _regeneratorRuntime.async(function cleanSafari$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Cleaning mobile safari data files');
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.isFresh());

          case 3:
            if (!context$2$0.sent) {
              context$2$0.next = 6;
              break;
            }

            _logger2['default'].info('Could not find Safari support directories to clean out old ' + 'data. Probably there is nothing to clean out');
            return context$2$0.abrupt('return');

          case 6:
            libraryDir = _path2['default'].resolve(this.getDir(), 'Library');
            context$2$0.next = 9;
            return _regeneratorRuntime.awrap(this.getAppDir('com.apple.mobilesafari'));

          case 9:
            safariRoot = context$2$0.sent;

            if (safariRoot) {
              context$2$0.next = 13;
              break;
            }

            _logger2['default'].info('Could not find Safari support directories to clean out old ' + 'data. Probably there is nothing to clean out');
            return context$2$0.abrupt('return');

          case 13:
            safariLibraryDir = _path2['default'].resolve(safariRoot, 'Library');
            filesToDelete = ['Caches/Snapshots/com.apple.mobilesafari', 'Caches/com.apple.mobilesafari/*', 'Caches/com.apple.WebAppCache/*', 'Caches/com.apple.WebKit.Networking/*', 'Caches/com.apple.WebKit.WebContent/*', 'Image Cache/*', 'WebKit/com.apple.mobilesafari/*', 'WebKit/GeolocationSites.plist', 'WebKit/LocalStorage/*.*', 'Safari/*', 'Cookies/*.binarycookies', 'Caches/com.apple.UIStatusBar/*', 'Caches/com.apple.keyboards/images/*', 'Caches/com.apple.Safari.SafeBrowsing/*', '../tmp/com.apple.mobilesafari/*'];
            deletePromises = [];
            _iteratorNormalCompletion5 = true;
            _didIteratorError5 = false;
            _iteratorError5 = undefined;
            context$2$0.prev = 19;

            for (_iterator5 = _getIterator(filesToDelete); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              file = _step5.value;

              deletePromises.push(_appiumSupport.fs.rimraf(_path2['default'].resolve(libraryDir, file)));
              deletePromises.push(_appiumSupport.fs.rimraf(_path2['default'].resolve(safariLibraryDir, file)));
            }

            context$2$0.next = 27;
            break;

          case 23:
            context$2$0.prev = 23;
            context$2$0.t0 = context$2$0['catch'](19);
            _didIteratorError5 = true;
            _iteratorError5 = context$2$0.t0;

          case 27:
            context$2$0.prev = 27;
            context$2$0.prev = 28;

            if (!_iteratorNormalCompletion5 && _iterator5['return']) {
              _iterator5['return']();
            }

          case 30:
            context$2$0.prev = 30;

            if (!_didIteratorError5) {
              context$2$0.next = 33;
              break;
            }

            throw _iteratorError5;

          case 33:
            return context$2$0.finish(30);

          case 34:
            return context$2$0.finish(27);

          case 35:
            if (!keepPrefs) {
              deletePromises.push(_appiumSupport.fs.rimraf(_path2['default'].resolve(safariLibraryDir, 'Preferences/*.plist')));
            }

            context$2$0.next = 38;
            return _regeneratorRuntime.awrap(_bluebird2['default'].all(deletePromises));

          case 38:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[19, 23, 27, 35], [28,, 30, 34]]);
    }

    /**
     * Uninstall the given application from the current Simulator.
     *
     * @param {string} bundleId - The buindle ID of the application to be removed.
     */
  }, {
    key: 'removeApp',
    value: function removeApp(bundleId) {
      return _regeneratorRuntime.async(function removeApp$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(simctl.removeApp(this.udid, bundleId));

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Move a built-in application to a new place (actually, rename it).
     *
     * @param {string} appName - The name of the app to be moved.
     * @param {string} appPath - The current path to the application.
     * @param {string} newAppPath - The new path to the application.
     *   If some application already exists by this path then it's going to be removed.
     */
  }, {
    key: 'moveBuiltInApp',
    value: function moveBuiltInApp(appName, appPath, newAppPath) {
      return _regeneratorRuntime.async(function moveBuiltInApp$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap((0, _utilsJs.safeRimRaf)(newAppPath));

          case 2:
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.copyFile(appPath, newAppPath));

          case 4:
            _logger2['default'].debug('Copied \'' + appName + '\' to \'' + newAppPath + '\'');

            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(appPath));

          case 7:
            _logger2['default'].debug('Temporarily deleted original app at \'' + appPath + '\'');

            return context$2$0.abrupt('return', [newAppPath, appPath]);

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Open the given URL in mobile Safari browser.
     * The browser will be started automatically if it is not running.
     *
     * @param {string} url - The URL to be opened.
     */
  }, {
    key: 'openUrl',
    value: function openUrl(url) {
      var SAFARI_BOOTED_INDICATOR, SAFARI_STARTUP_TIMEOUT, EXTRA_STARTUP_TIME;
      return _regeneratorRuntime.async(function openUrl$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            SAFARI_BOOTED_INDICATOR = 'MobileSafari[';
            SAFARI_STARTUP_TIMEOUT = 15 * 1000;
            EXTRA_STARTUP_TIME = 3 * 1000;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.isRunning());

          case 5:
            if (!context$2$0.sent) {
              context$2$0.next = 17;
              break;
            }

            context$2$0.next = 8;
            return _regeneratorRuntime.awrap((0, _asyncbox.retry)(5000, simctl.openUrl, this.udid, url));

          case 8:
            context$2$0.next = 10;
            return _regeneratorRuntime.awrap(this.tailLogsUntil(SAFARI_BOOTED_INDICATOR, SAFARI_STARTUP_TIMEOUT));

          case 10:
            // So sorry, but the logs have nothing else for Safari starting.. just delay a little bit
            _logger2['default'].debug('Safari started, waiting ' + EXTRA_STARTUP_TIME + 'ms for it to fully start');
            context$2$0.next = 13;
            return _regeneratorRuntime.awrap(_bluebird2['default'].delay(EXTRA_STARTUP_TIME));

          case 13:
            _logger2['default'].debug('Done waiting for Safari');
            return context$2$0.abrupt('return');

          case 17:
            throw new Error('Tried to open a url, but the Simulator is not Booted');

          case 18:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Perform Simulator caches cleanup.
     *
     * @param {...string} folderNames - The names of Caches subfolders to be cleaned.
     *   Non-accessible/non-existing subfolders will be skipped.
     *   All existing subfolders under Caches will be deleted if this parameter is omitted.
     * @returns {number} The count of cleaned cache items.
     *   Zero is returned if no items were matched for cleanup (either not accessible or not directories).
     */
  }, {
    key: 'clearCaches',
    value: function clearCaches() {
      for (var _len = arguments.length, folderNames = Array(_len), _key = 0; _key < _len; _key++) {
        folderNames[_key] = arguments[_key];
      }

      var cachesRoot, itemsToRemove;
      return _regeneratorRuntime.async(function clearCaches$(context$2$0) {
        var _this5 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            cachesRoot = _path2['default'].resolve(this.getDir(), 'Library', 'Caches');
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.hasAccess(cachesRoot));

          case 3:
            if (context$2$0.sent) {
              context$2$0.next = 6;
              break;
            }

            _logger2['default'].debug('Caches root at \'' + cachesRoot + '\' does not exist or is not accessible. Nothing to do there');
            return context$2$0.abrupt('return', 0);

          case 6:
            if (!folderNames.length) {
              context$2$0.next = 10;
              break;
            }

            context$2$0.t0 = folderNames;
            context$2$0.next = 13;
            break;

          case 10:
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.readdir(cachesRoot));

          case 12:
            context$2$0.t0 = context$2$0.sent;

          case 13:
            itemsToRemove = context$2$0.t0;

            itemsToRemove = itemsToRemove.map(function (x) {
              return _path2['default'].resolve(cachesRoot, x);
            });

            if (!folderNames.length) {
              context$2$0.next = 19;
              break;
            }

            context$2$0.next = 18;
            return _regeneratorRuntime.awrap(_bluebird2['default'].filter(itemsToRemove, function (x) {
              return _appiumSupport.fs.hasAccess(x);
            }));

          case 18:
            itemsToRemove = context$2$0.sent;

          case 19:
            context$2$0.next = 21;
            return _regeneratorRuntime.awrap(_bluebird2['default'].filter(itemsToRemove, function callee$2$0(x) {
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.next = 2;
                    return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(x));

                  case 2:
                    return context$3$0.abrupt('return', context$3$0.sent.isDirectory());

                  case 3:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this5);
            }));

          case 21:
            itemsToRemove = context$2$0.sent;

            if (itemsToRemove.length) {
              context$2$0.next = 25;
              break;
            }

            _logger2['default'].debug('No Simulator cache items for cleanup were matched in \'' + cachesRoot + '\'');
            return context$2$0.abrupt('return', 0);

          case 25:

            _logger2['default'].debug('Matched ' + itemsToRemove.length + ' Simulator cache ' + ('item' + (itemsToRemove.length === 1 ? '' : 's') + ' for cleanup: ' + itemsToRemove));
            context$2$0.prev = 26;
            context$2$0.next = 29;
            return _regeneratorRuntime.awrap(_bluebird2['default'].all(itemsToRemove, function (x) {
              return _appiumSupport.fs.rimraf(x);
            }));

          case 29:
            context$2$0.next = 34;
            break;

          case 31:
            context$2$0.prev = 31;
            context$2$0.t1 = context$2$0['catch'](26);

            _logger2['default'].warn('Got an exception while cleaning Simulator caches: ' + context$2$0.t1.message);

          case 34:
            return context$2$0.abrupt('return', itemsToRemove.length);

          case 35:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[26, 31]]);
    }

    /**
     * Blocks until the given indicater string appears in Simulator logs.
     *
     * @param {string} bootedIndicator - The magic string, which appears in logs after Simulator booting is completed.
     * @param {number} timeoutMs - The maximumm number of milliseconds to wait for the string indicator presence.
     * @returns {Promise} A promise that resolves when the ios simulator logs output a line matching `bootedIndicator`
     * times out after timeoutMs
     */
  }, {
    key: 'tailLogsUntil',
    value: function tailLogsUntil(bootedIndicator, timeoutMs) {
      var simLog;
      return _regeneratorRuntime.async(function tailLogsUntil$(context$2$0) {
        var _this6 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            simLog = _path2['default'].resolve(this.getLogDir(), 'system.log');
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(200, 200, function callee$2$0() {
              var exists;
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.next = 2;
                    return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(simLog));

                  case 2:
                    exists = context$3$0.sent;

                    if (exists) {
                      context$3$0.next = 5;
                      break;
                    }

                    throw new Error('Could not find Simulator log: \'' + simLog + '\'');

                  case 5:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this6);
            }));

          case 3:

            _logger2['default'].info('Simulator log at \'' + simLog + '\'');
            _logger2['default'].info('Tailing simulator logs until we encounter the string "' + bootedIndicator + '"');
            _logger2['default'].info('We will time out after ' + timeoutMs + 'ms');
            context$2$0.prev = 6;
            context$2$0.next = 9;
            return _regeneratorRuntime.awrap((0, _tailUntilJs.tailUntil)(simLog, bootedIndicator, timeoutMs));

          case 9:
            context$2$0.next = 14;
            break;

          case 11:
            context$2$0.prev = 11;
            context$2$0.t0 = context$2$0['catch'](6);

            _logger2['default'].debug('Simulator startup timed out. Continuing anyway.');

          case 14:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[6, 11]]);
    }

    /**
     * Enable Calendar access for the given application.
     *
     * @param {string} bundleID - Bundle ID of the application, for which the access should be granted.
     */
  }, {
    key: 'enableCalendarAccess',
    value: function enableCalendarAccess(bundleID) {
      return _regeneratorRuntime.async(function enableCalendarAccess$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.calendar.enableCalendarAccess(bundleID));

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Disable Calendar access for the given application.
     *
     * @param {string} bundleID - Bundle ID of the application, for which the access should be denied.
     */
  }, {
    key: 'disableCalendarAccess',
    value: function disableCalendarAccess(bundleID) {
      return _regeneratorRuntime.async(function disableCalendarAccess$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.calendar.disableCalendarAccess(bundleID));

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Check whether the given application has access to Calendar.
     *
     * @return {boolean} True if the given application has the access.
     */
  }, {
    key: 'hasCalendarAccess',
    value: function hasCalendarAccess(bundleID) {
      return _regeneratorRuntime.async(function hasCalendarAccess$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.calendar.hasCalendarAccess(bundleID));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Generate Apple script, which activates Simulator.
     *
     * @returns {string} the generated Apple Script snippet.
     */
  }, {
    key: 'generateWindowActivationScript',
    value: function generateWindowActivationScript() {
      return _regeneratorRuntime.async(function generateWindowActivationScript$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.abrupt('return', '\n      tell application "System Events"\n        tell process "Simulator"\n          set frontmost to false\n          set frontmost to true\n        end tell\n      end tell\n    ');

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Execute given Apple Script inside a critical section, so other
     * sessions cannot influence the UI client at the same time.
     *
     * @param {string} appleScript - The valid Apple Script snippet to be executed.
     * @return {string} The stdout output produced by the script.
     * @throws {Error} If osascript tool returns non-zero exit code.
     */
  }, {
    key: 'executeUIClientScript',
    value: function executeUIClientScript(appleScript) {
      var windowActivationScript, resultScript;
      return _regeneratorRuntime.async(function executeUIClientScript$(context$2$0) {
        var _this7 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.generateWindowActivationScript());

          case 2:
            windowActivationScript = context$2$0.sent;
            resultScript = windowActivationScript + '\n' + appleScript;

            _logger2['default'].debug('Executing UI Apple Script on Simulator with UDID ' + this.udid + ': ' + resultScript);
            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(UI_CLIENT_ACCESS_GUARD.acquire(this.simulatorApp, function callee$2$0() {
              var _ref4, stdout;

              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.prev = 0;
                    context$3$0.next = 3;
                    return _regeneratorRuntime.awrap((0, _teen_process.exec)('osascript', ['-e', resultScript]));

                  case 3:
                    _ref4 = context$3$0.sent;
                    stdout = _ref4.stdout;
                    return context$3$0.abrupt('return', stdout);

                  case 8:
                    context$3$0.prev = 8;
                    context$3$0.t0 = context$3$0['catch'](0);

                    _logger2['default'].errorAndThrow('Make sure Simulator UI is running and the parent Appium application (e. g. Appium.app or Terminal.app) ' + 'is present in System Preferences > Security & Privacy > Privacy > Accessibility list. ' + ('Original error: ' + context$3$0.t0.message));

                  case 11:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this7, [[0, 8]]);
            }));

          case 7:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 8:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Get the current state of Touch ID Enrollment feature.
     *
     * @return {boolean} True if Touch ID Enrollment menu item is checked in Simulator menu
     */
  }, {
    key: 'isTouchIDEnrolled',
    value: function isTouchIDEnrolled() {
      var output;
      return _regeneratorRuntime.async(function isTouchIDEnrolled$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.executeUIClientScript('\n      tell application "System Events"\n        tell process "Simulator"\n          set dstMenuItem to menu item "Toggle Enrolled State" of menu 1 of menu item "Touch ID" of menu 1 of menu bar item "Hardware" of menu bar 1\n          set isChecked to (value of attribute "AXMenuItemMarkChar" of dstMenuItem) is ""\n        end tell\n      end tell\n    '));

          case 2:
            output = context$2$0.sent;

            _logger2['default'].debug('Touch ID enrolled state: ' + output);
            return context$2$0.abrupt('return', _lodash2['default'].isString(output) && output.trim() === 'true');

          case 5:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Execute a special Apple script, which changes Touch ID feature testing in Simulator UI client.
     *
     * @param {boolean} isEnabled - Set it to false in order to uncheck 'Toggle Enrolled State' flag
     */
  }, {
    key: 'enrollTouchID',
    value: function enrollTouchID() {
      var isEnabled = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
      return _regeneratorRuntime.async(function enrollTouchID$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.executeUIClientScript('\n      tell application "System Events"\n        tell process "Simulator"\n          set dstMenuItem to menu item "Toggle Enrolled State" of menu 1 of menu item "Touch ID" of menu 1 of menu bar item "Hardware" of menu bar 1\n          set isChecked to (value of attribute "AXMenuItemMarkChar" of dstMenuItem) is ""\n          if ' + (isEnabled ? 'not ' : '') + 'isChecked then\n            click dstMenuItem\n          end if\n        end tell\n      end tell\n    '));

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Execute a special Apple script, which clicks the particular button on Database alert.
     *
     * @param {boolean} increase - Click the button with 'Increase' title on the alert if this
     *   parameter is true. The 'Cancel' button will be clicked otherwise.
     */
  }, {
    key: 'dismissDatabaseAlert',
    value: function dismissDatabaseAlert() {
      var increase = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
      var button;
      return _regeneratorRuntime.async(function dismissDatabaseAlert$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            button = increase ? 'Increase' : 'Cancel';

            _logger2['default'].debug('Attempting to dismiss database alert with \'' + button + '\' button');
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.executeUIClientScript('\n      tell application "System Events"\n        tell process "Simulator"\n          click button "' + button + '" of window 1\n        end tell\n      end tell\n    '));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'startupTimeout',
    get: function get() {
      return STARTUP_TIMEOUT;
    }
  }], [{
    key: '_getDeviceStringPlatformVersion',
    value: function _getDeviceStringPlatformVersion(platformVersion) {
      var reqVersion;
      return _regeneratorRuntime.async(function _getDeviceStringPlatformVersion$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            reqVersion = platformVersion;

            if (reqVersion) {
              context$2$0.next = 7;
              break;
            }

            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(_appiumXcode2['default'].getMaxIOSSDK());

          case 4:
            reqVersion = context$2$0.sent;

            _logger2['default'].warn('No platform version set. Using max SDK version: ' + reqVersion);
            // this will be a number, and possibly an integer (e.g., if max iOS SDK is 9)
            // so turn it into a string and add a .0 if necessary
            if (!_lodash2['default'].isString(reqVersion)) {
              reqVersion = reqVersion % 1 ? String(reqVersion) : reqVersion + '.0';
            }

          case 7:
            return context$2$0.abrupt('return', reqVersion);

          case 8:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    // change the format in subclasses, as necessary
  }, {
    key: '_getDeviceStringVersionString',
    value: function _getDeviceStringVersionString(platformVersion) {
      var reqVersion;
      return _regeneratorRuntime.async(function _getDeviceStringVersionString$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this._getDeviceStringPlatformVersion(platformVersion));

          case 2:
            reqVersion = context$2$0.sent;
            return context$2$0.abrupt('return', '(' + reqVersion + ' Simulator)');

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    // change the format in subclasses, as necessary
  }, {
    key: '_getDeviceStringConfigFix',
    value: function _getDeviceStringConfigFix() {
      // some devices need to be updated
      return {
        'iPad Simulator (7.1 Simulator)': 'iPad 2 (7.1 Simulator)',
        'iPad Simulator (8.0 Simulator)': 'iPad 2 (8.0 Simulator)',
        'iPad Simulator (8.1 Simulator)': 'iPad 2 (8.1 Simulator)',
        'iPad Simulator (8.2 Simulator)': 'iPad 2 (8.2 Simulator)',
        'iPad Simulator (8.3 Simulator)': 'iPad 2 (8.3 Simulator)',
        'iPad Simulator (8.4 Simulator)': 'iPad 2 (8.4 Simulator)',
        'iPhone Simulator (7.1 Simulator)': 'iPhone 5s (7.1 Simulator)',
        'iPhone Simulator (8.4 Simulator)': 'iPhone 6 (8.4 Simulator)',
        'iPhone Simulator (8.3 Simulator)': 'iPhone 6 (8.3 Simulator)',
        'iPhone Simulator (8.2 Simulator)': 'iPhone 6 (8.2 Simulator)',
        'iPhone Simulator (8.1 Simulator)': 'iPhone 6 (8.1 Simulator)',
        'iPhone Simulator (8.0 Simulator)': 'iPhone 6 (8.0 Simulator)'
      };
    }

    /**
     * Takes a set of options and finds the correct device string in order for Instruments to
     * identify the correct simulator.
     *
     * @param {object} opts - The options available are:
     *   - `deviceName` - a name for the device. If the given device name starts with `=`, the name, less the equals sign, is returned.
     *   - `platformVersion` - the version of iOS to use. Defaults to the current Xcode's maximum SDK version.
     *   - `forceIphone` - force the configuration of the device string to iPhone. Defaults to `false`.
     *   - `forceIpad` - force the configuration of the device string to iPad. Defaults to `false`.
     *   If both `forceIphone` and `forceIpad` are true, the device will be forced to iPhone.
     *
     * @return {string} The found device string.
     */
  }, {
    key: 'getDeviceString',
    value: function getDeviceString(opts) {
      var logOpts, isiPhone, device, iosDeviceString, CONFIG_FIX, configFix;
      return _regeneratorRuntime.async(function getDeviceString$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            opts = _Object$assign({}, {
              deviceName: null,
              platformVersion: null,
              forceIphone: false,
              forceIpad: false
            }, opts);
            logOpts = {
              deviceName: opts.deviceName,
              platformVersion: opts.platformVersion,
              forceIphone: opts.forceIphone,
              forceIpad: opts.forceIpad
            };

            _logger2['default'].debug('Getting device string from options: ' + JSON.stringify(logOpts));

            // short circuit if we already have a device name

            if (!((opts.deviceName || '')[0] === '=')) {
              context$2$0.next = 5;
              break;
            }

            return context$2$0.abrupt('return', opts.deviceName.substring(1));

          case 5:
            isiPhone = !!opts.forceIphone || !opts.forceIpad;

            if (opts.deviceName) {
              device = opts.deviceName.toLowerCase();

              if (device.indexOf('iphone') !== -1) {
                isiPhone = true;
              } else if (device.indexOf('ipad') !== -1) {
                isiPhone = false;
              }
            }

            iosDeviceString = opts.deviceName || (isiPhone ? 'iPhone Simulator' : 'iPad Simulator');

            // if someone passes in just "iPhone", make that "iPhone Simulator" to
            // conform to all the logic below
            if (/^(iPhone|iPad)$/.test(iosDeviceString)) {
              iosDeviceString += " Simulator";
            }

            // we support deviceName: "iPhone Simulator", and also want to support
            // "iPhone XYZ Simulator", but these strings aren't in the device list.
            // So, if someone sent in "iPhone XYZ Simulator", strip off " Simulator"
            // in order to allow the default "iPhone XYZ" match
            if (/[^(iPhone|iPad)] Simulator/.test(iosDeviceString)) {
              iosDeviceString = iosDeviceString.replace(" Simulator", "");
            }
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap(this._getDeviceStringVersionString(opts.platformVersion));

          case 12:
            context$2$0.t0 = context$2$0.sent;
            iosDeviceString += ' ' + context$2$0.t0;
            CONFIG_FIX = this._getDeviceStringConfigFix();
            configFix = CONFIG_FIX;

            if (configFix[iosDeviceString]) {
              iosDeviceString = configFix[iosDeviceString];
              _logger2['default'].debug('Fixing device. Changed from \'' + opts.deviceName + '\' ' + ('to \'' + iosDeviceString + '\''));
            }

            _logger2['default'].debug('Final device string is \'' + iosDeviceString + '\'');
            return context$2$0.abrupt('return', iosDeviceString);

          case 19:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }]);

  return SimulatorXcode6;
})(EventEmitter);

var _iteratorNormalCompletion6 = true;
var _didIteratorError6 = false;
var _iteratorError6 = undefined;

try {

  for (var _iterator6 = _getIterator(_lodash2['default'].toPairs(_extensionsIndex2['default'])), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
    var _step6$value = _slicedToArray(_step6.value, 2);

    var cmd = _step6$value[0];
    var fn = _step6$value[1];

    SimulatorXcode6.prototype[cmd] = fn;
  }
} catch (err) {
  _didIteratorError6 = true;
  _iteratorError6 = err;
} finally {
  try {
    if (!_iteratorNormalCompletion6 && _iterator6['return']) {
      _iterator6['return']();
    }
  } finally {
    if (_didIteratorError6) {
      throw _iteratorError6;
    }
  }
}

exports['default'] = SimulatorXcode6;
exports.SimulatorXcode6 = SimulatorXcode6;
exports.BOOT_COMPLETED_EVENT = BOOT_COMPLETED_EVENT;

// `appFile` argument only necessary for iOS below version 8

// reduce the list of path-bundle pairs to an object where bundleIds are mapped to paths

// wait for the simulator to boot
// waiting for the simulator status to be 'booted' isn't good enough
// it claims to be booted way before finishing loading
// let's tail the simulator system log until we see a magic line (this.bootedIndicator)
// eslint-disable-line curly

// wait for the system to create the files we will manipulate
// need quite a high retry number, in order to accommodate iOS 7.1
// locally, 7.1 averages 8.5 retries (from 6 - 12)
//          8 averages 0.6 retries (from 0 - 2)
//          9 averages 14 retries

// and quit

// Waits 10 sec for the simulator launchd services to stop.

// get the data directory

// get the bundle directory

// we need to make sure log file exists before we can tail it
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9zaW11bGF0b3IteGNvZGUtNi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFpQixNQUFNOzs7OzBCQUNDLGFBQWE7O0lBQXpCLE1BQU07OzJCQUN3QyxjQUFjOzs7O3NCQUN4RCxVQUFVOzs7OzZCQUNQLGdCQUFnQjs7d0JBQ3JCLFVBQVU7Ozs7c0JBQ1YsUUFBUTs7Ozt5QkFDQSxZQUFZOzs7O3VCQUNZLFlBQVk7O3dCQUNPLFVBQVU7O3dCQUNqRCxZQUFZOztJQUExQixRQUFROzs0QkFDQyxjQUFjOzsyQkFDVCxpQkFBaUI7OytCQUNwQixvQkFBb0I7Ozs7c0JBQ3hCLFFBQVE7Ozs7d0JBQ04sWUFBWTs7OztJQUN6QixZQUFZLHVCQUFaLFlBQVk7O0FBR3BCLElBQU0sZUFBZSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUM7QUFDbEMsSUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUM7QUFDaEMsSUFBTSxzQkFBc0IsR0FBRyw0QkFBZSxDQUFDOzs7Ozs7Ozs7O0FBVS9DLElBQU0sb0JBQW9CLEdBQUcsZUFBZSxDQUFDOztJQUd2QyxlQUFlO1lBQWYsZUFBZTs7Ozs7Ozs7O0FBUVAsV0FSUixlQUFlLENBUU4sSUFBSSxFQUFFLFlBQVksRUFBRTswQkFSN0IsZUFBZTs7QUFTakIsK0JBVEUsZUFBZSw2Q0FTVDtBQUNSLFFBQUksQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pCLFFBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDOzs7OztBQUtqQyxRQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDOztBQUU3QixRQUFJLENBQUMsWUFBWSxHQUFHLGtCQUFLLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQ3hFLFFBQUksQ0FBQyxZQUFZLEdBQUcsbUJBQW1CLENBQUM7O0FBRXhDLFFBQUks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QUksU0FBUyxDQUFDLGVBQWUsQ0FBQyxFQUFFO0FBQzlCLDZCQUFlLEdBQUcsU0FBUyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQzdDLGtDQUFJLEtBQUssQ0FBQyxtQ0FBZ0MsSUFBSSxDQUFDLFVBQVUsc0JBQ3JDLGVBQWUsUUFBRyxDQUFDLENBQUM7YUFDekM7O0FBRUQsZ0NBQUksS0FBSywrQkFBNEIsZUFBZSxRQUFJLENBQUM7Z0RBQ2xELGVBQWU7Ozs7Ozs7S0FDdkI7OztTQXZnQ0csZUFBZTtHQUFTLFlBQVk7Ozs7Ozs7O0FBMGdDMUMscUNBQXNCLG9CQUFFLE9BQU8sOEJBQVksaUhBQUU7OztRQUFuQyxHQUFHO1FBQUUsRUFBRTs7QUFDZixtQkFBZSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7R0FDckM7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBRWMsZUFBZTtRQUNyQixlQUFlLEdBQWYsZUFBZTtRQUFFLG9CQUFvQixHQUFwQixvQkFBb0IiLCJmaWxlIjoibGliL3NpbXVsYXRvci14Y29kZS02LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBzaW1jdGwgZnJvbSAnbm9kZS1zaW1jdGwnO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyB4Y29kZSwgZ2V0UGF0aCBhcyBnZXRYY29kZVBhdGggfSBmcm9tICdhcHBpdW0teGNvZGUnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBmcyB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgQXN5bmNMb2NrIGZyb20gJ2FzeW5jLWxvY2snO1xuaW1wb3J0IHsga2lsbEFsbFNpbXVsYXRvcnMsIHNhZmVSaW1SYWYgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGFzeW5jbWFwLCByZXRyeUludGVydmFsLCB3YWl0Rm9yQ29uZGl0aW9uLCByZXRyeSB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCAqIGFzIHNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyB0YWlsVW50aWwgfSBmcm9tICcuL3RhaWwtdW50aWwuanMnO1xuaW1wb3J0IGV4dGVuc2lvbnMgZnJvbSAnLi9leHRlbnNpb25zL2luZGV4JztcbmltcG9ydCBldmVudHMgZnJvbSAnZXZlbnRzJztcbmltcG9ydCBDYWxlbmRhciBmcm9tICcuL2NhbGVuZGFyJztcbmNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSBldmVudHM7XG5cblxuY29uc3QgU1RBUlRVUF9USU1FT1VUID0gNjAgKiAxMDAwO1xuY29uc3QgRVhUUkFfU1RBUlRVUF9USU1FID0gMjAwMDtcbmNvbnN0IFVJX0NMSUVOVF9BQ0NFU1NfR1VBUkQgPSBuZXcgQXN5bmNMb2NrKCk7XG5cbi8qXG4gKiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgYXMgc29vbiBhcyBpT1MgU2ltdWxhdG9yXG4gKiBoYXMgZmluaXNoZWQgYm9vdGluZyBhbmQgaXQgaXMgcmVhZHkgdG8gYWNjZXB0IHhjcnVuIGNvbW1hbmRzLlxuICogVGhlIGV2ZW50IGhhbmRsZXIgaXMgY2FsbGVkIGFmdGVyICdydW4nIG1ldGhvZCBpcyBjb21wbGV0ZWRcbiAqIGZvciBYY29kZSA3IGFuZCBvbGRlciBhbmQgaXMgb25seSB1c2VmdWwgaW4gWGNvZGUgOCssXG4gKiBzaW5jZSBvbmUgY2FuIHN0YXJ0IGRvaW5nIHN0dWZmIChmb3IgZXhhbXBsZSBpbnN0YWxsL3VuaW5zdGFsbCBhbiBhcHApIGluIHBhcmFsbGVsXG4gKiB3aXRoIFNpbXVsYXRvciBVSSBzdGFydHVwLCB3aGljaCBzaG9ydGVucyBzZXNzaW9uIHN0YXJ0dXAgdGltZS5cbiAqL1xuY29uc3QgQk9PVF9DT01QTEVURURfRVZFTlQgPSAnYm9vdENvbXBsZXRlZCc7XG5cblxuY2xhc3MgU2ltdWxhdG9yWGNvZGU2IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgb2JqZWN0IHdpdGggdGhlIGB1ZGlkYCBhbmQgdmVyc2lvbiBvZiBYY29kZS4gVXNlIHRoZSBleHBvcnRlZCBgZ2V0U2ltdWxhdG9yKHVkaWQpYCBtZXRob2QgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgU2ltdWxhdG9yIElELlxuICAgKiBAcGFyYW0ge29iamVjdH0geGNvZGVWZXJzaW9uIC0gVGhlIHRhcmdldCBYY29kZSB2ZXJzaW9uIGluIGZvcm1hdCB7bWFqb3IsIG1pbm9yLCBidWlsZH0uXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWRpZCwgeGNvZGVWZXJzaW9uKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVkaWQgPSBTdHJpbmcodWRpZCk7XG4gICAgdGhpcy54Y29kZVZlcnNpb24gPSB4Y29kZVZlcnNpb247XG5cbiAgICAvLyBwbGF0Zm9ybVZlcnNpb24gY2Fubm90IGJlIGZvdW5kIGluaXRpYWxseSwgc2luY2UgZ2V0dGluZyBpdCBoYXMgc2lkZSBlZmZlY3RzIGZvclxuICAgIC8vIG91ciBsb2dpYyBmb3IgZmlndXJpbmcgb3V0IGlmIGEgc2ltIGhhcyBiZWVuIHJ1blxuICAgIC8vIGl0IHdpbGwgYmUgc2V0IHdoZW4gaXQgaXMgbmVlZGVkXG4gICAgdGhpcy5fcGxhdGZvcm1WZXJzaW9uID0gbnVsbDtcblxuICAgIHRoaXMua2V5Y2hhaW5QYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMuZ2V0RGlyKCksICdMaWJyYXJ5JywgJ0tleWNoYWlucycpO1xuICAgIHRoaXMuc2ltdWxhdG9yQXBwID0gJ2lPUyBTaW11bGF0b3IuYXBwJztcblxuICAgIHRoaXMuYXBwRGF0YUJ1bmRsZVBhdGhzID0ge307XG5cbiAgICAvLyBsaXN0IG9mIGZpbGVzIHRvIGNoZWNrIGZvciB3aGVuIHNlZWluZyBpZiBhIHNpbXVsYXRvciBpcyBcImZyZXNoXCJcbiAgICAvLyAobWVhbmluZyBpdCBoYXMgbmV2ZXIgYmVlbiBib290ZWQpLlxuICAgIC8vIElmIHRoZXNlIGZpbGVzIGFyZSBwcmVzZW50LCB3ZSBhc3N1bWUgaXQncyBiZWVuIHN1Y2Nlc3NmdWxseSBib290ZWRcbiAgICB0aGlzLmlzRnJlc2hGaWxlcyA9IFtcbiAgICAgICdMaWJyYXJ5L0NvbmZpZ3VyYXRpb25Qcm9maWxlcycsXG4gICAgICAnTGlicmFyeS9Db29raWVzJyxcbiAgICAgICdMaWJyYXJ5L1ByZWZlcmVuY2VzLy5HbG9iYWxQcmVmZXJlbmNlcy5wbGlzdCcsXG4gICAgICAnTGlicmFyeS9QcmVmZXJlbmNlcy9jb20uYXBwbGUuc3ByaW5nYm9hcmQucGxpc3QnLFxuICAgICAgJ3Zhci9ydW4vc3lzbG9nLnBpZCdcbiAgICBdO1xuXG4gICAgLy8gZXh0cmEgdGltZSB0byB3YWl0IGZvciBzaW11bGF0b3IgdG8gYmUgZGVlbWVkIGJvb3RlZFxuICAgIHRoaXMuZXh0cmFTdGFydHVwVGltZSA9IEVYVFJBX1NUQVJUVVBfVElNRTtcblxuICAgIHRoaXMuY2FsZW5kYXIgPSBuZXcgQ2FsZW5kYXIodGhpcy5nZXREaXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhlIHN0YXRlIG9mIFNpbXVsYXRvciBVSSBjbGllbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgb2YgaWYgVUkgY2xpZW50IGlzIHJ1bm5pbmcgb3IgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgYXN5bmMgaXNVSUNsaWVudFJ1bm5pbmcgKCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBleGVjKCdwZ3JlcCcsIFsnLXgnLCB0aGlzLnNpbXVsYXRvckFwcC5zcGxpdCgnLicpWzBdXSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSG93IGxvbmcgdG8gd2FpdCBiZWZvcmUgdGhyb3dpbmcgYW4gZXJyb3IgYWJvdXQgU2ltdWxhdG9yIHN0YXJ0dXAgdGltZW91dCBoYXBwZW5lZC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICovXG4gIGdldCBzdGFydHVwVGltZW91dCAoKSB7XG4gICAgcmV0dXJuIFNUQVJUVVBfVElNRU9VVDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBsYXRmb3JtIHZlcnNpb24gb2YgdGhlIGN1cnJlbnQgU2ltdWxhdG9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFNESyB2ZXJzaW9uLCBmb3IgZXhhbXBsZSAnOC4zJy5cbiAgICovXG4gIGFzeW5jIGdldFBsYXRmb3JtVmVyc2lvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9wbGF0Zm9ybVZlcnNpb24pIHtcbiAgICAgIGxldCB7c2RrfSA9IGF3YWl0IHRoaXMuc3RhdCgpO1xuICAgICAgdGhpcy5fcGxhdGZvcm1WZXJzaW9uID0gc2RrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGxhdGZvcm1WZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBmdWxsIHBhdGggdG8gdGhlIGRpcmVjdG9yeSB3aGVyZSBTaW11bGF0b3Igc3R1ZmYgaXMgbG9jYXRlZC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgcGF0aCBzdHJpbmcuXG4gICAqL1xuICBnZXRSb290RGlyICgpIHtcbiAgICBsZXQgaG9tZSA9IHByb2Nlc3MuZW52LkhPTUU7XG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZShob21lLCAnTGlicmFyeScsICdEZXZlbG9wZXInLCAnQ29yZVNpbXVsYXRvcicsICdEZXZpY2VzJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGZ1bGwgcGF0aCB0byB0aGUgZGlyZWN0b3J5IHdoZXJlIFNpbXVsYXRvciBhcHBsaWNhdGlvbnMgZGF0YSBpcyBsb2NhdGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYXRoIHN0cmluZy5cbiAgICovXG4gIGdldERpciAoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZSh0aGlzLmdldFJvb3REaXIoKSwgdGhpcy51ZGlkLCAnZGF0YScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBmdWxsIHBhdGggdG8gdGhlIGRpcmVjdG9yeSB3aGVyZSBTaW11bGF0b3IgbG9ncyBhcmUgc3RvcmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYXRoIHN0cmluZy5cbiAgICovXG4gIGdldExvZ0RpciAoKSB7XG4gICAgbGV0IGhvbWUgPSBwcm9jZXNzLmVudi5IT01FO1xuICAgIHJldHVybiBwYXRoLnJlc29sdmUoaG9tZSwgJ0xpYnJhcnknLCAnTG9ncycsICdDb3JlU2ltdWxhdG9yJywgdGhpcy51ZGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YWxsIHZhbGlkIC5hcHAgcGFja2FnZSBvbiBTaW11bGF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcHAgLSBUaGUgcGF0aCB0byB0aGUgLmFwcCBwYWNrYWdlLlxuICAgKi9cbiAgYXN5bmMgaW5zdGFsbEFwcCAoYXBwKSB7XG4gICAgcmV0dXJuIGF3YWl0IHNpbWN0bC5pbnN0YWxsQXBwKHRoaXMudWRpZCwgYXBwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgd2hldGhlciB0aGUgcGFydGljdWxhciBhcHBsaWNhdGlvbiBpcyBpbnN0YWxsZWQgb24gU2ltdWxhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYnVuZGxlSWQgLSBUaGUgYnVuZGxlIGlkIG9mIHRoZSBhcHBsaWNhdGlvbiB0byBiZSBjaGVja2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwRnVsZSAtIEFwcGxpY2F0aW9uIG5hbWUgbWludXMgXCIuYXBwXCIgKGZvciBpT1MgNy4xKVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnaXZlbiBhcHBsaWNhdGlvbiBpcyBpbnN0YWxsZWRcbiAgICovXG4gIGFzeW5jIGlzQXBwSW5zdGFsbGVkIChidW5kbGVJZCwgYXBwRmlsZSA9IG51bGwpIHtcbiAgICAvLyBgYXBwRmlsZWAgYXJndW1lbnQgb25seSBuZWNlc3NhcnkgZm9yIGlPUyBiZWxvdyB2ZXJzaW9uIDhcbiAgICBsZXQgYXBwRGlycyA9IGF3YWl0IHRoaXMuZ2V0QXBwRGlycyhhcHBGaWxlLCBidW5kbGVJZCk7XG4gICAgcmV0dXJuIGFwcERpcnMubGVuZ3RoICE9PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBkaXJlY3RvcnkgZm9yIGEgcGFydGljdWxhciBhcHBsaWNhdGlvbidzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIEVpdGhlciBhIGJ1bmRsZUlkIChlLmcuLCBjb20uYXBwbGUubW9iaWxlc2FmYXJpKSBvciwgZm9yIGlPUyA3LjEsIHRoZSBhcHAgbmFtZSB3aXRob3V0IGAuYXBwYCAoZS5nLiwgTW9iaWxlU2FmYXJpKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViZGlyIC0gVGhlIHN1Yi1kaXJlY3Rvcnkgd2UgZXhwZWN0IHRvIGJlIHdpdGhpbiB0aGUgYXBwbGljYXRpb24gZGlyZWN0b3J5LiBEZWZhdWx0cyB0byBcIkRhdGFcIi5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgcm9vdCBhcHBsaWNhdGlvbiBmb2xkZXIuXG4gICAqL1xuICBhc3luYyBnZXRBcHBEaXIgKGlkLCBzdWJEaXIgPSAnRGF0YScpIHtcbiAgICB0aGlzLmFwcERhdGFCdW5kbGVQYXRoc1tzdWJEaXJdID0gdGhpcy5hcHBEYXRhQnVuZGxlUGF0aHNbc3ViRGlyXSB8fCB7fTtcbiAgICBpZiAoXy5pc0VtcHR5KHRoaXMuYXBwRGF0YUJ1bmRsZVBhdGhzW3N1YkRpcl0pICYmICFhd2FpdCB0aGlzLmlzRnJlc2goKSkge1xuICAgICAgdGhpcy5hcHBEYXRhQnVuZGxlUGF0aHNbc3ViRGlyXSA9IGF3YWl0IHRoaXMuYnVpbGRCdW5kbGVQYXRoTWFwKHN1YkRpcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFwcERhdGFCdW5kbGVQYXRoc1tzdWJEaXJdW2lkXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgeGNvZGUgNiBzaW11bGF0b3JzIGFyZSByZWFsbHkgYW5ub3lpbmcsIGFuZCBidXJ5IHRoZSBtYWluIGFwcFxuICAgKiBkaXJlY3RvcmllcyBpbnNpZGUgZGlyZWN0b3JpZXMganVzdCBuYW1lZCB3aXRoIEhhc2hlcy5cbiAgICogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgcHJvcGVyIGRpcmVjdG9yeSBieSB0cmF2ZXJzaW5nIGFsbCBvZiB0aGVtXG4gICAqIGFuZCByZWFkaW5nIGEgbWV0YWRhdGEgcGxpc3QgKE1vYmlsZSBDb250YWluZXIgTWFuYWdlcikgdG8gZ2V0IHRoZVxuICAgKiBidW5kbGUgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJkaXIgLSBUaGUgc3ViLWRpcmVjdG9yeSB3ZSBleHBlY3QgdG8gYmUgd2l0aGluIHRoZSBhcHBsaWNhdGlvbiBkaXJlY3RvcnkuIERlZmF1bHRzIHRvIFwiRGF0YVwiLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBsaXN0IG9mIHBhdGgtYnVuZGxlIHBhaXJzIHRvIGFuIG9iamVjdCB3aGVyZSBidW5kbGVJZHMgYXJlIG1hcHBlZCB0byBwYXRocy5cbiAgICovXG4gIGFzeW5jIGJ1aWxkQnVuZGxlUGF0aE1hcCAoc3ViRGlyID0gJ0RhdGEnKSB7XG4gICAgbG9nLmRlYnVnKCdCdWlsZGluZyBidW5kbGUgcGF0aCBtYXAnKTtcbiAgICBsZXQgYXBwbGljYXRpb25MaXN0O1xuICAgIGxldCBwYXRoQnVuZGxlUGFpcjtcbiAgICBpZiAoYXdhaXQgdGhpcy5nZXRQbGF0Zm9ybVZlcnNpb24oKSA9PT0gJzcuMScpIHtcbiAgICAgIC8vIGFwcHMgYXZhaWxhYmxlXG4gICAgICAvLyAgIFdlYi5hcHAsXG4gICAgICAvLyAgIFdlYlZpZXdTZXJ2aWNlLmFwcCxcbiAgICAgIC8vICAgTW9iaWxlU2FmYXJpLmFwcCxcbiAgICAgIC8vICAgV2ViQ29udGVudEFuYWx5c2lzVUkuYXBwLFxuICAgICAgLy8gICBEREFjdGlvbnNTZXJ2aWNlLmFwcCxcbiAgICAgIC8vICAgU3RvcmVLaXRVSVNlcnZpY2UuYXBwXG4gICAgICBhcHBsaWNhdGlvbkxpc3QgPSBwYXRoLnJlc29sdmUodGhpcy5nZXREaXIoKSwgJ0FwcGxpY2F0aW9ucycpO1xuICAgICAgcGF0aEJ1bmRsZVBhaXIgPSBhc3luYyAoZGlyKSA9PiB7XG4gICAgICAgIGRpciA9IHBhdGgucmVzb2x2ZShhcHBsaWNhdGlvbkxpc3QsIGRpcik7XG4gICAgICAgIGxldCBhcHBGaWxlcyA9IGF3YWl0IGZzLmdsb2IoYCR7ZGlyfS8qLmFwcGApO1xuICAgICAgICBsZXQgYnVuZGxlSWQgPSBhcHBGaWxlc1swXS5tYXRjaCgvLipcXC8oLiopXFwuYXBwLylbMV07XG4gICAgICAgIHJldHVybiB7cGF0aDogZGlyLCBidW5kbGVJZH07XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBsaWNhdGlvbkxpc3QgPSBwYXRoLnJlc29sdmUodGhpcy5nZXREaXIoKSwgJ0NvbnRhaW5lcnMnLCBzdWJEaXIsICdBcHBsaWNhdGlvbicpO1xuICAgICAgLy8gZ2l2ZW4gYSBkaXJlY3RvcnksIGZpbmQgdGhlIHBsaXN0IGZpbGUgYW5kIHB1bGwgdGhlIGJ1bmRsZSBpZCBmcm9tIGl0XG4gICAgICBsZXQgcmVhZEJ1bmRsZUlkID0gYXN5bmMgKGRpcikgPT4ge1xuICAgICAgICBsZXQgcGxpc3QgPSBwYXRoLnJlc29sdmUoZGlyLCAnLmNvbS5hcHBsZS5tb2JpbGVfY29udGFpbmVyX21hbmFnZXIubWV0YWRhdGEucGxpc3QnKTtcbiAgICAgICAgbGV0IG1ldGFkYXRhID0gYXdhaXQgc2V0dGluZ3MucmVhZChwbGlzdCk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YS5NQ01NZXRhZGF0YUlkZW50aWZpZXI7XG4gICAgICB9O1xuICAgICAgLy8gZ2l2ZW4gYSBkaXJlY3RvcnksIHJldHVybiB0aGUgcGF0aCBhbmQgYnVuZGxlIGlkIGFzc29jaWF0ZWQgd2l0aCBpdFxuICAgICAgcGF0aEJ1bmRsZVBhaXIgPSBhc3luYyAoZGlyKSA9PiB7XG4gICAgICAgIGRpciA9IHBhdGgucmVzb2x2ZShhcHBsaWNhdGlvbkxpc3QsIGRpcik7XG4gICAgICAgIGxldCBidW5kbGVJZCA9IGF3YWl0IHJlYWRCdW5kbGVJZChkaXIpO1xuICAgICAgICByZXR1cm4ge3BhdGg6IGRpciwgYnVuZGxlSWR9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgYnVuZGxlUGF0aERpcnMgPSBhd2FpdCBmcy5yZWFkZGlyKGFwcGxpY2F0aW9uTGlzdCk7XG4gICAgbGV0IGJ1bmRsZVBhdGhQYWlycyA9IGF3YWl0IGFzeW5jbWFwKGJ1bmRsZVBhdGhEaXJzLCBhc3luYyAoZGlyKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgcGF0aEJ1bmRsZVBhaXIoZGlyKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICAvLyByZWR1Y2UgdGhlIGxpc3Qgb2YgcGF0aC1idW5kbGUgcGFpcnMgdG8gYW4gb2JqZWN0IHdoZXJlIGJ1bmRsZUlkcyBhcmUgbWFwcGVkIHRvIHBhdGhzXG4gICAgcmV0dXJuIGJ1bmRsZVBhdGhQYWlycy5yZWR1Y2UoKGJ1bmRsZU1hcCwgYnVuZGxlUGF0aCkgPT4ge1xuICAgICAgYnVuZGxlTWFwW2J1bmRsZVBhdGguYnVuZGxlSWRdID0gYnVuZGxlUGF0aC5wYXRoO1xuICAgICAgcmV0dXJuIGJ1bmRsZU1hcDtcbiAgICB9LCB7fSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0ZSBhbmQgc3BlY2lmaWNzIG9mIHRoaXMgc2ltLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFNpbXVsYXRvciBzdGF0cyBtYXBwaW5nLCBmb3IgZXhhbXBsZTpcbiAgICogeyBuYW1lOiAnaVBob25lIDRzJyxcbiAgICogICB1ZGlkOiAnQzA5QjM0RTUtN0RDQi00NDJFLUI3OUMtQUI2QkMwMzU3NDE3JyxcbiAgICogICBzdGF0ZTogJ1NodXRkb3duJyxcbiAgICogICBzZGs6ICc4LjMnXG4gICAqIH1cbiAgICovXG4gIGFzeW5jIHN0YXQgKCkge1xuICAgIGZvciAobGV0IFtzZGssIGRldmljZUFycl0gb2YgXy50b1BhaXJzKGF3YWl0IHNpbWN0bC5nZXREZXZpY2VzKCkpKSB7XG4gICAgICBmb3IgKGxldCBkZXZpY2Ugb2YgZGV2aWNlQXJyKSB7XG4gICAgICAgIGlmIChkZXZpY2UudWRpZCA9PT0gdGhpcy51ZGlkKSB7XG4gICAgICAgICAgZGV2aWNlLnNkayA9IHNkaztcbiAgICAgICAgICByZXR1cm4gZGV2aWNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBiZXN0LWJldCBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgb3Igbm90IGEgc2ltIGhhcyBiZWVuIGJvb3RlZFxuICAgKiBiZWZvcmUuIFdlIHVzdWFsbHkgd2FudCB0byBzdGFydCBhIHNpbXVsYXRvciB0byBcIndhcm1cIiBpdCB1cCwgaGF2ZVxuICAgKiBYY29kZSBwb3B1bGF0ZSBpdCB3aXRoIHBsaXN0cyBmb3IgdXMgdG8gbWFuaXB1bGF0ZSBiZWZvcmUgYSByZWFsXG4gICAqIHRlc3QgcnVuLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjdXJyZW50IFNpbXVsYXRvciBoYXMgbmV2ZXIgYmVlbiBzdGFydGVkIGJlZm9yZVxuICAgKi9cbiAgYXN5bmMgaXNGcmVzaCAoKSB7XG4gICAgLy8gaWYgdGhlIGZvbGxvd2luZyBmaWxlcyBkb24ndCBleGlzdCwgaXQgaGFzbid0IGJlZW4gYm9vdGVkLlxuICAgIC8vIFRISVMgSVMgTk9UIEFOIEVYSEFVU1RJVkUgTElTVFxuICAgIGxvZy5kZWJ1ZygnQ2hlY2tpbmcgd2hldGhlciBzaW11bGF0b3IgaGFzIGJlZW4gcnVuIGJlZm9yZScpO1xuICAgIGxldCBmaWxlcyA9IHRoaXMuaXNGcmVzaEZpbGVzO1xuXG4gICAgbGV0IHB2ID0gYXdhaXQgdGhpcy5nZXRQbGF0Zm9ybVZlcnNpb24oKTtcbiAgICBpZiAocHYgIT09ICc3LjEnKSB7XG4gICAgICBmaWxlcy5wdXNoKCdMaWJyYXJ5L1ByZWZlcmVuY2VzL2NvbS5hcHBsZS5QcmVmZXJlbmNlcy5wbGlzdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWxlcy5wdXNoKCdBcHBsaWNhdGlvbnMnKTtcbiAgICB9XG5cbiAgICBmaWxlcyA9IGZpbGVzLm1hcCgocykgPT4ge1xuICAgICAgcmV0dXJuIHBhdGgucmVzb2x2ZSh0aGlzLmdldERpcigpLCBzKTtcbiAgICB9KTtcblxuICAgIGxldCBleGlzdGVuY2VzID0gYXdhaXQgYXN5bmNtYXAoZmlsZXMsIGFzeW5jIChmKSA9PiB7IHJldHVybiBhd2FpdCBmcy5oYXNBY2Nlc3MoZik7IH0pO1xuICAgIGxldCBmcmVzaCA9IF8uY29tcGFjdChleGlzdGVuY2VzKS5sZW5ndGggIT09IGZpbGVzLmxlbmd0aDtcbiAgICBsb2cuZGVidWcoYFNpbXVsYXRvciAke2ZyZXNoID8gJ2hhcyBub3QnIDogJ2hhcyd9IGJlZW4gcnVuIGJlZm9yZWApO1xuICAgIHJldHVybiBmcmVzaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IFNpbXVsYXRvci4gT25lIHNob3VsZCBkaXN0aW5ndWlzaCB0aGVcbiAgICogc3RhdGVzIG9mIFNpbXVsYXRvciBVSSBhbmQgdGhlIFNpbXVsYXRvciBpdHNlbGYuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGN1cnJlbnQgU2ltdWxhdG9yIGlzIHJ1bm5pbmcuXG4gICAqL1xuICBhc3luYyBpc1J1bm5pbmcgKCkge1xuICAgIGxldCBzdGF0ID0gYXdhaXQgdGhpcy5zdGF0KCk7XG4gICAgcmV0dXJuIHN0YXQuc3RhdGUgPT09ICdCb290ZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB3aGV0aGVyIHRoZSBTaW11bGF0b3IgYm9vdGluZyBpcyBjb21wbGV0ZWQgYW5kL29yIHdhaXQgZm9yIGl0XG4gICAqIHVudGlsIHRoZSB0aW1lb3V0IGV4cGlyZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydHVwVGltZW91dCAtIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgdW50aWwgYm9vdGluZyBpcyBjb21wbGV0ZWQuXG4gICAqIEBlbWl0cyBCT09UX0NPTVBMRVRFRF9FVkVOVCBpZiB0aGUgY3VycmVudCBTaW11bGF0b3IgaXMgcmVhZHkgdG8gYWNjZXB0IHNpbWN0bCBjb21tYW5kcywgbGlrZSAnaW5zdGFsbCcuXG4gICAqL1xuICBhc3luYyB3YWl0Rm9yQm9vdCAoc3RhcnR1cFRpbWVvdXQpIHtcbiAgICAvLyB3YWl0IGZvciB0aGUgc2ltdWxhdG9yIHRvIGJvb3RcbiAgICAvLyB3YWl0aW5nIGZvciB0aGUgc2ltdWxhdG9yIHN0YXR1cyB0byBiZSAnYm9vdGVkJyBpc24ndCBnb29kIGVub3VnaFxuICAgIC8vIGl0IGNsYWltcyB0byBiZSBib290ZWQgd2F5IGJlZm9yZSBmaW5pc2hpbmcgbG9hZGluZ1xuICAgIC8vIGxldCdzIHRhaWwgdGhlIHNpbXVsYXRvciBzeXN0ZW0gbG9nIHVudGlsIHdlIHNlZSBhIG1hZ2ljIGxpbmUgKHRoaXMuYm9vdGVkSW5kaWNhdG9yKVxuICAgIGxldCBib290ZWRJbmRpY2F0b3IgPSBhd2FpdCB0aGlzLmdldEJvb3RlZEluZGljYXRvclN0cmluZygpO1xuICAgIGF3YWl0IHRoaXMudGFpbExvZ3NVbnRpbChib290ZWRJbmRpY2F0b3IsIHN0YXJ0dXBUaW1lb3V0KTtcblxuICAgIC8vIHNvIHNvcnJ5LCBidXQgd2Ugc2hvdWxkIHdhaXQgYW5vdGhlciB0d28gc2Vjb25kcywganVzdCB0byBtYWtlIHN1cmUgd2UndmUgcmVhbGx5IHN0YXJ0ZWRcbiAgICAvLyB3ZSBjYW4ndCBsb29rIGZvciBhbm90aGVyIG1hZ2ljIGxvZyBsaW5lLCBiZWNhdXNlIHRoZXkgc2VlbSB0byBiZSBhcHAtZGVwZW5kZW50IChub3Qgc3lzdGVtIGRlcGVuZGVudClcbiAgICBsb2cuZGVidWcoYFdhaXRpbmcgYW4gZXh0cmEgJHt0aGlzLmV4dHJhU3RhcnR1cFRpbWV9bXMgZm9yIHRoZSBzaW11bGF0b3IgdG8gcmVhbGx5IGZpbmlzaCBib290aW5nYCk7XG4gICAgYXdhaXQgQi5kZWxheSh0aGlzLmV4dHJhU3RhcnR1cFRpbWUpO1xuICAgIGxvZy5kZWJ1ZygnRG9uZSB3YWl0aW5nIGV4dHJhIHRpbWUgZm9yIHNpbXVsYXRvcicpO1xuXG4gICAgdGhpcy5lbWl0KEJPT1RfQ09NUExFVEVEX0VWRU5UKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbWFnaWMgc3RyaW5nLCB3aGljaCwgaWYgcHJlc2VudCBpbiBsb2dzLCByZWZsZWN0cyB0aGUgZmFjdCB0aGF0IHNpbXVsYXRvciBib290aW5nIGhhcyBiZWVuIGNvbXBsZXRlZC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbWFnaWMgbG9nIHN0cmluZy5cbiAgICovXG4gIGFzeW5jIGdldEJvb3RlZEluZGljYXRvclN0cmluZyAoKSB7XG4gICAgbGV0IGluZGljYXRvcjtcbiAgICBsZXQgcGxhdGZvcm1WZXJzaW9uID0gYXdhaXQgdGhpcy5nZXRQbGF0Zm9ybVZlcnNpb24oKTtcbiAgICBzd2l0Y2ggKHBsYXRmb3JtVmVyc2lvbikge1xuICAgICAgY2FzZSAnNy4xJzpcbiAgICAgIGNhc2UgJzguMSc6XG4gICAgICBjYXNlICc4LjInOlxuICAgICAgY2FzZSAnOC4zJzpcbiAgICAgIGNhc2UgJzguNCc6XG4gICAgICAgIGluZGljYXRvciA9ICdwcm9maWxlZDogU2VydmljZSBzdGFydGluZy4uLic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOS4wJzpcbiAgICAgIGNhc2UgJzkuMSc6XG4gICAgICBjYXNlICc5LjInOlxuICAgICAgY2FzZSAnOS4zJzpcbiAgICAgICAgaW5kaWNhdG9yID0gJ1N5c3RlbSBhcHAgXCJjb20uYXBwbGUuc3ByaW5nYm9hcmRcIiBmaW5pc2hlZCBzdGFydHVwJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcxMC4wJzpcbiAgICAgICAgaW5kaWNhdG9yID0gJ1N3aXRjaGluZyB0byBrZXlib2FyZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbG9nLndhcm4oYE5vIGJvb3QgaW5kaWNhdG9yIGNhc2UgZm9yIHBsYXRmb3JtIHZlcnNpb24gJyR7cGxhdGZvcm1WZXJzaW9ufSdgKTtcbiAgICAgICAgaW5kaWNhdG9yID0gJ25vIGJvb3QgaW5kaWNhdG9yIHN0cmluZyBhdmFpbGFibGUnO1xuICAgIH1cbiAgICByZXR1cm4gaW5kaWNhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBTaW11bGF0b3IgVUkgY2xpZW50IHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIE9uZSBvciBtb3JlIG9mIGF2YWlsYWJsZSBTaW11bGF0b3IgVUkgY2xpZW50IG9wdGlvbnM6XG4gICAqICAgLSB7c3RyaW5nfSBzY2FsZUZhY3RvcjogY2FuIGJlIG9uZSBvZiBbJzEuMCcsICcwLjc1JywgJzAuNScsICcwLjMzJywgJzAuMjUnXS5cbiAgICogICBEZWZpbmVzIHRoZSB3aW5kb3cgc2NhbGUgdmFsdWUgZm9yIHRoZSBVSSBjbGllbnQgd2luZG93IGZvciB0aGUgY3VycmVudCBTaW11bGF0b3IuXG4gICAqICAgRXF1YWxzIHRvIG51bGwgYnkgZGVmYXVsdCwgd2hpY2gga2VlcHMgdGhlIGN1cnJlbnQgc2NhbGUgdW5jaGFuZ2VkLlxuICAgKiAgIC0ge2Jvb2xlYW59IGNvbm5lY3RIYXJkd2FyZUtleWJvYXJkOiB3aGV0aGVyIHRvIGNvbm5lY3QgdGhlIGhhcmR3YXJlIGtleWJvYXJkIHRvIHRoZVxuICAgKiAgIFNpbXVsYXRvciBVSSBjbGllbnQuIEVxdWFscyB0byBmYWxzZSBieSBkZWZhdWx0LlxuICAgKiAgIC0ge251bWJlcn0gc3RhcnR1cFRpbWVvdXQ6IG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCB1bnRpbCBTaW11bGF0b3IgYm9vdGluZ1xuICAgKiAgIHByb2Nlc3MgaXMgY29tcGxldGVkLiBUaGUgZGVmYXVsdCB0aW1lb3V0IHdpbGwgYmUgdXNlZCBpZiBub3Qgc2V0IGV4cGxpY2l0bHkuXG4gICAqL1xuICBhc3luYyBzdGFydFVJQ2xpZW50IChvcHRzID0ge30pIHtcbiAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBzY2FsZUZhY3RvcjogbnVsbCxcbiAgICAgIGNvbm5lY3RIYXJkd2FyZUtleWJvYXJkOiBmYWxzZSxcbiAgICAgIHN0YXJ0dXBUaW1lb3V0OiB0aGlzLnN0YXJ0dXBUaW1lb3V0LFxuICAgIH0sIG9wdHMpO1xuXG4gICAgY29uc3Qgc2ltdWxhdG9yQXBwID0gcGF0aC5yZXNvbHZlKGF3YWl0IGdldFhjb2RlUGF0aCgpLCAnQXBwbGljYXRpb25zJywgdGhpcy5zaW11bGF0b3JBcHApO1xuICAgIGNvbnN0IGFyZ3MgPSBbJy1GbicsIHNpbXVsYXRvckFwcCwgJy0tYXJncycsICctQ3VycmVudERldmljZVVESUQnLCB0aGlzLnVkaWRdO1xuXG4gICAgaWYgKG9wdHMuc2NhbGVGYWN0b3IpIHtcbiAgICAgIGNvbnN0IHN0YXQgPSBhd2FpdCB0aGlzLnN0YXQoKTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZERldmljZU5hbWUgPSBzdGF0Lm5hbWUucmVwbGFjZSgvXFxzKy9nLCAnLScpO1xuICAgICAgY29uc3QgYXJndW1lbnROYW1lID0gYC1TaW11bGF0b3JXaW5kb3dMYXN0U2NhbGUtY29tLmFwcGxlLkNvcmVTaW11bGF0b3IuU2ltRGV2aWNlVHlwZS4ke2Zvcm1hdHRlZERldmljZU5hbWV9YDtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudE5hbWUsIG9wdHMuc2NhbGVGYWN0b3IpO1xuICAgIH1cblxuICAgIGlmIChfLmlzQm9vbGVhbihvcHRzLmNvbm5lY3RIYXJkd2FyZUtleWJvYXJkKSkge1xuICAgICAgYXJncy5wdXNoKCctQ29ubmVjdEhhcmR3YXJlS2V5Ym9hcmQnLCBvcHRzLmNvbm5lY3RIYXJkd2FyZUtleWJvYXJkID8gJzEnIDogJzAnKTtcbiAgICB9XG5cbiAgICBsb2cuaW5mbyhgU3RhcnRpbmcgU2ltdWxhdG9yIFVJIHdpdGggY29tbWFuZDogb3BlbiAke2FyZ3Muam9pbignICcpfWApO1xuICAgIGF3YWl0IGV4ZWMoJ29wZW4nLCBhcmdzLCB7dGltZW91dDogb3B0cy5zdGFydHVwVGltZW91dH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGdpdmVuIFNpbXVsYXRvciB3aXRoIG9wdGlvbnMuIFRoZSBTaW11bGF0b3Igd2lsbCBub3QgYmUgcmVzdGFydGVkIGlmXG4gICAqIGl0IGlzIGFscmVhZHkgcnVubmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBPbmUgb3IgbW9yZSBvZiBhdmFpbGFibGUgU2ltdWxhdG9yIG9wdGlvbnMuXG4gICAqICAgU2VlIHsjc3RhcnRVSUNsaWVudChvcHRzKX0gZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBkZXRhaWxzIG9uIG90aGVyIHN1cHBvcnRlZCBrZXlzLlxuICAgKi9cbiAgYXN5bmMgcnVuIChvcHRzID0ge30pIHtcbiAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBzdGFydHVwVGltZW91dDogdGhpcy5zdGFydHVwVGltZW91dCxcbiAgICB9LCBvcHRzKTtcbiAgICBjb25zdCB7c3RhdGV9ID0gYXdhaXQgdGhpcy5zdGF0KCk7XG4gICAgY29uc3QgaXNTZXJ2ZXJSdW5uaW5nID0gc3RhdGUgPT09ICdCb290ZWQnO1xuICAgIGNvbnN0IGlzVUlDbGllbnRSdW5uaW5nID0gYXdhaXQgdGhpcy5pc1VJQ2xpZW50UnVubmluZygpO1xuICAgIGlmIChpc1NlcnZlclJ1bm5pbmcgJiYgaXNVSUNsaWVudFJ1bm5pbmcpIHtcbiAgICAgIGxvZy5pbmZvKGBCb3RoIFNpbXVsYXRvciB3aXRoIFVESUQgJHt0aGlzLnVkaWR9IGFuZCB0aGUgVUkgY2xpZW50IGFyZSBjdXJyZW50bHkgcnVubmluZ2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFRpbWUgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnNodXRkb3duKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybihgRXJyb3Igb24gU2ltdWxhdG9yIHNodXRkb3duOiAke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnN0YXJ0VUlDbGllbnQob3B0cyk7XG5cbiAgICBhd2FpdCB0aGlzLndhaXRGb3JCb290KG9wdHMuc3RhcnR1cFRpbWVvdXQpO1xuICAgIGxvZy5pbmZvKGBTaW11bGF0b3Igd2l0aCBVRElEICR7dGhpcy51ZGlkfSBib290ZWQgaW4gJHtwcm9jZXNzLmhydGltZShzdGFydFRpbWUpWzBdfSBzZWNvbmRzYCk7XG4gIH1cblxuICAvLyBUT0RPIGtlZXAga2V5Y2hhaW5zXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgY3VycmVudCBTaW11bGF0b3IgdG8gdGhlIGNsZWFuIHN0YXRlLlxuICAgKi9cbiAgYXN5bmMgY2xlYW4gKCkge1xuICAgIGF3YWl0IHRoaXMuZW5kU2ltdWxhdG9yRGFlbW9uKCk7XG4gICAgbG9nLmluZm8oYENsZWFuaW5nIHNpbXVsYXRvciAke3RoaXMudWRpZH1gKTtcbiAgICBhd2FpdCBzaW1jdGwuZXJhc2VEZXZpY2UodGhpcy51ZGlkLCAxMDAwMCk7XG4gIH1cblxuICAvKipcbiAgICogU2NydWIgKGRlbGV0ZSB0aGUgcHJlZmVyZW5jZXMgYW5kIGNoYW5nZWQgZmlsZXMpIHRoZSBwYXJ0aWN1bGFyIGFwcGxpY2F0aW9uIG9uIFNpbXVsYXRvci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFwcEZpbGUgLSBBcHBsaWNhdGlvbiBuYW1lIG1pbnVzIFwiLmFwcFwiLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwQnVuZGxlSWQgLSBCdW5kbGUgaWRlbnRpZmllciBvZiB0aGUgYXBwbGljYXRpb24uXG4gICAqL1xuICBhc3luYyBzY3J1YkN1c3RvbUFwcCAoYXBwRmlsZSwgYXBwQnVuZGxlSWQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGVhbkN1c3RvbUFwcChhcHBGaWxlLCBhcHBCdW5kbGVJZCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4vc2NydWIgdGhlIHBhcnRpY3VsYXIgYXBwbGljYXRpb24gb24gU2ltdWxhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwRmlsZSAtIEFwcGxpY2F0aW9uIG5hbWUgbWludXMgXCIuYXBwXCIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBCdW5kbGVJZCAtIEJ1bmRsZSBpZGVudGlmaWVyIG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBzY3J1YiAtIElmIGBzY3J1YmAgaXMgZmFsc2UsIHdlIHdhbnQgdG8gY2xlYW4gYnkgZGVsZXRpbmcgdGhlIGFwcCBhbmQgYWxsXG4gICAqICAgZmlsZXMgYXNzb2NpYXRlZCB3aXRoIGl0LiBJZiBgc2NydWJgIGlzIHRydWUsIHdlIGp1c3Qgd2FudCB0byBkZWxldGUgdGhlIHByZWZlcmVuY2VzIGFuZFxuICAgKiAgIGNoYW5nZWQgZmlsZXMuXG4gICAqL1xuICBhc3luYyBjbGVhbkN1c3RvbUFwcCAoYXBwRmlsZSwgYXBwQnVuZGxlSWQsIHNjcnViID0gZmFsc2UpIHtcbiAgICBsb2cuZGVidWcoYENsZWFuaW5nIGFwcCBkYXRhIGZpbGVzIGZvciAnJHthcHBGaWxlfScsICcke2FwcEJ1bmRsZUlkfSdgKTtcbiAgICBpZiAoIXNjcnViKSB7XG4gICAgICBsb2cuZGVidWcoYERlbGV0aW5nIGFwcCBhbHRvZ2V0aGVyYCk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBkaXJlY3RvcmllcyB0byBiZSBkZWxldGVkXG4gICAgbGV0IGFwcERpcnMgPSBhd2FpdCB0aGlzLmdldEFwcERpcnMoYXBwRmlsZSwgYXBwQnVuZGxlSWQsIHNjcnViKTtcblxuICAgIGlmIChhcHBEaXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nLmRlYnVnKFwiQ291bGQgbm90IGZpbmQgYXBwIGRpcmVjdG9yaWVzIHRvIGRlbGV0ZS4gSXQgaXMgcHJvYmFibHkgbm90IGluc3RhbGxlZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZGVsZXRlUHJvbWlzZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGRpciBvZiBhcHBEaXJzKSB7XG4gICAgICBsb2cuZGVidWcoYERlbGV0aW5nIGRpcmVjdG9yeTogJyR7ZGlyfSdgKTtcbiAgICAgIGRlbGV0ZVByb21pc2VzLnB1c2goZnMucmltcmFmKGRpcikpO1xuICAgIH1cblxuICAgIGlmIChhd2FpdCB0aGlzLmdldFBsYXRmb3JtVmVyc2lvbigpID49IDgpIHtcbiAgICAgIGxldCByZWxSbVBhdGggPSBgTGlicmFyeS9QcmVmZXJlbmNlcy8ke2FwcEJ1bmRsZUlkfS5wbGlzdGA7XG4gICAgICBsZXQgcm1QYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMuZ2V0Um9vdERpcigpLCByZWxSbVBhdGgpO1xuICAgICAgbG9nLmRlYnVnKGBEZWxldGluZyBmaWxlOiAnJHtybVBhdGh9J2ApO1xuICAgICAgZGVsZXRlUHJvbWlzZXMucHVzaChmcy5yaW1yYWYocm1QYXRoKSk7XG4gICAgfVxuXG4gICAgYXdhaXQgQi5hbGwoZGVsZXRlUHJvbWlzZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHBhdGhzIHRvIGRpcnMgd2hlcmUgYXBwbGljYXRpb24gZGF0YSBpcyBzdG9yZWQuIGlPUyA4KyBzdG9yZXMgYXBwIGRhdGEgaW4gdHdvIHBsYWNlcyxcbiAgICogYW5kIGlPUyA3LjEgaGFzIG9ubHkgb25lIGRpcmVjdG9yeVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwRmlsZSAtIEFwcGxpY2F0aW9uIG5hbWUgbWludXMgXCIuYXBwXCIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBCdW5kbGVJZCAtIEJ1bmRsZSBpZGVudGlmaWVyIG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBzY3J1YiAtIFRoZSBgQnVuZGxlYCBkaXJlY3RvcnkgaGFzIHRoZSBhY3R1YWwgYXBwIGluIGl0LiBJZiB3ZSBhcmUganVzdCBzY3J1YmJpbmcsXG4gICAqICAgd2Ugd2FudCB0aGlzIHRvIHN0YXkuIElmIHdlIGFyZSBjbGVhbmluZyB3ZSBkZWxldGUuXG4gICAqIEByZXR1cm4ge2FycmF5PHN0cmluZz59IEFycmF5IG9mIGFwcGxpY2F0aW9uIGRhdGEgcGF0aHMuXG4gICAqL1xuICBhc3luYyBnZXRBcHBEaXJzIChhcHBGaWxlLCBhcHBCdW5kbGVJZCwgc2NydWIgPSBmYWxzZSkge1xuICAgIGxldCBkaXJzID0gW107XG4gICAgaWYgKGF3YWl0IHRoaXMuZ2V0UGxhdGZvcm1WZXJzaW9uKCkgPj0gOCkge1xuICAgICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmdldEFwcERpcihhcHBCdW5kbGVJZCk7XG4gICAgICBpZiAoIWRhdGEpIHJldHVybiBkaXJzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG5cbiAgICAgIGxldCBidW5kbGUgPSAhc2NydWIgPyBhd2FpdCB0aGlzLmdldEFwcERpcihhcHBCdW5kbGVJZCwgJ0J1bmRsZScpIDogdW5kZWZpbmVkO1xuXG4gICAgICBmb3IgKGxldCBzcmMgb2YgW2RhdGEsIGJ1bmRsZV0pIHtcbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIGRpcnMucHVzaChzcmMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkYXRhID0gYXdhaXQgdGhpcy5nZXRBcHBEaXIoYXBwRmlsZSk7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBkaXJzLnB1c2goZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIFNpbXVsYXRvciBpbiBvcmRlciB0byBoYXZlIHRoZSBpbml0aWFsIGZpbGUgc3RydWN0dXJlIGNyZWF0ZWQgYW5kIHNodXRkb3duIGl0IGFmdGVyd2FyZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2FmYXJpIC0gV2hldGhlciB0byBleGVjdXRlIG1vYmlsZSBTYWZhcmkgYWZ0ZXIgc3RhcnR1cC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0dXBUaW1lb3V0IC0gSG93IGxvbmcgdG8gd2FpdCB1bnRpbCBTaW11bGF0b3IgYm9vdGluZyBpcyBjb21wbGV0ZWQgKGluIG1pbGxpc2Vjb25kcykuXG4gICAqL1xuICBhc3luYyBsYXVuY2hBbmRRdWl0IChzYWZhcmkgPSBmYWxzZSwgc3RhcnR1cFRpbWVvdXQgPSB0aGlzLnN0YXJ0dXBUaW1lb3V0KSB7XG4gICAgbG9nLmRlYnVnKCdBdHRlbXB0aW5nIHRvIGxhdW5jaCBhbmQgcXVpdCB0aGUgc2ltdWxhdG9yLCB0byBjcmVhdGUgZGlyZWN0b3J5IHN0cnVjdHVyZScpO1xuICAgIGxvZy5kZWJ1ZyhgV2lsbCBsYXVuY2ggd2l0aCBTYWZhcmk/ICR7c2FmYXJpfWApO1xuXG4gICAgYXdhaXQgdGhpcy5ydW4oc3RhcnR1cFRpbWVvdXQpO1xuXG4gICAgaWYgKHNhZmFyaSkge1xuICAgICAgYXdhaXQgdGhpcy5vcGVuVXJsKCdodHRwOi8vd3d3LmFwcGl1bS5pbycpO1xuICAgIH1cblxuICAgIC8vIHdhaXQgZm9yIHRoZSBzeXN0ZW0gdG8gY3JlYXRlIHRoZSBmaWxlcyB3ZSB3aWxsIG1hbmlwdWxhdGVcbiAgICAvLyBuZWVkIHF1aXRlIGEgaGlnaCByZXRyeSBudW1iZXIsIGluIG9yZGVyIHRvIGFjY29tbW9kYXRlIGlPUyA3LjFcbiAgICAvLyBsb2NhbGx5LCA3LjEgYXZlcmFnZXMgOC41IHJldHJpZXMgKGZyb20gNiAtIDEyKVxuICAgIC8vICAgICAgICAgIDggYXZlcmFnZXMgMC42IHJldHJpZXMgKGZyb20gMCAtIDIpXG4gICAgLy8gICAgICAgICAgOSBhdmVyYWdlcyAxNCByZXRyaWVzXG4gICAgYXdhaXQgcmV0cnlJbnRlcnZhbCgyMCwgMjUwLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoYXdhaXQgdGhpcy5pc0ZyZXNoKCkpIHtcbiAgICAgICAgbGV0IG1zZyA9ICdTaW11bGF0b3IgZmlsZXMgbm90IGZ1bGx5IGNyZWF0ZWQuIFdhaXRpbmcgYSBiaXQnO1xuICAgICAgICBsb2cuZGVidWcobXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBhbmQgcXVpdFxuICAgIGF3YWl0IHRoaXMuc2h1dGRvd24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rcyBmb3IgbGF1bmNoZCBkYWVtb25zIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNpbSB1ZGlkIGFuZCB0cmllcyB0byBzdG9wIHRoZW0gY2xlYW5seVxuICAgKiBUaGlzIHByZXZlbnRzIHhjcnVuIHNpbWN0bCBlcmFzZSBmcm9tIGhhbmdpbmcuXG4gICAqL1xuICBhc3luYyBlbmRTaW11bGF0b3JEYWVtb24gKCkge1xuICAgIGxvZy5kZWJ1ZyhgS2lsbGluZyBhbnkgc2ltdWxhdG9yIGRhZW1vbnMgZm9yICR7dGhpcy51ZGlkfWApO1xuXG4gICAgbGV0IGxhdW5jaGN0bENtZCA9IGBsYXVuY2hjdGwgbGlzdCB8IGdyZXAgJHt0aGlzLnVkaWR9IHwgY3V0IC1mIDMgfCB4YXJncyAtbiAxIGxhdW5jaGN0bGA7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBzdG9wQ21kID0gYCR7bGF1bmNoY3RsQ21kfSBzdG9wYDtcbiAgICAgIGF3YWl0IGV4ZWMoJ2Jhc2gnLCBbJy1jJywgc3RvcENtZF0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYENvdWxkIG5vdCBzdG9wIHNpbXVsYXRvciBkYWVtb25zOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgbG9nLmRlYnVnKCdDYXJyeWluZyBvbiBhbnl3YXkhJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgcmVtb3ZlQ21kID0gYCR7bGF1bmNoY3RsQ21kfSByZW1vdmVgO1xuICAgICAgYXdhaXQgZXhlYygnYmFzaCcsIFsnLWMnLCByZW1vdmVDbWRdKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBDb3VsZCBub3QgcmVtb3ZlIHNpbXVsYXRvciBkYWVtb25zOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgbG9nLmRlYnVnKCdDYXJyeWluZyBvbiBhbnl3YXkhJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyBXYWl0cyAxMCBzZWMgZm9yIHRoZSBzaW11bGF0b3IgbGF1bmNoZCBzZXJ2aWNlcyB0byBzdG9wLlxuICAgICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ2Jhc2gnLCBbJy1jJyxcbiAgICAgICAgICBgcHMgLWUgIHwgZ3JlcCAke3RoaXMudWRpZH0gfCBncmVwIGxhdW5jaGRfc2ltIHwgZ3JlcCAtdiBiYXNoIHwgZ3JlcCAtdiBncmVwIHwgYXdrIHsncHJpbnQkMSd9YF0pO1xuICAgICAgICByZXR1cm4gc3Rkb3V0LnRyaW0oKS5sZW5ndGggPT09IDA7XG4gICAgICB9LCB7d2FpdE1zOiAxMDAwMCwgaW50ZXJ2YWxNczogNTAwfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybihgQ291bGQgbm90IGVuZCBzaW11bGF0b3IgZGFlbW9uIGZvciAke3RoaXMudWRpZH06ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICBsb2cuZGVidWcoJ0NhcnJ5aW5nIG9uIGFueXdheSEnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2h1dGRvd24gYWxsIHRoZSBydW5uaW5nIFNpbXVsYXRvcnMgYW5kIHRoZSBVSSBjbGllbnQuXG4gICAqL1xuICBhc3luYyBzaHV0ZG93biAoKSB7XG4gICAgYXdhaXQga2lsbEFsbFNpbXVsYXRvcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIHBhcnRpY3VsYXIgU2ltdWxhdG9yIGZyb20gZGV2aWNlcyBsaXN0XG4gICAqL1xuICBhc3luYyBkZWxldGUgKCkge1xuICAgIGF3YWl0IHNpbWN0bC5kZWxldGVEZXZpY2UodGhpcy51ZGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBhcnRpY3VsYXIgcHJlZmVyZW5jZSBmaWxlIHdpdGggdGhlIGdpdmVuIGtleS92YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBsaXN0IC0gVGhlIHByZWZlcmVuY2VzIGZpbGUgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlcyAtIFRoZSBrZXkvdmFsdWUgcGFpcnMgdG8gdXBkYXRlLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlU2V0dGluZ3MgKHBsaXN0LCB1cGRhdGVzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHNldHRpbmdzLnVwZGF0ZVNldHRpbmdzKHRoaXMsIHBsaXN0LCB1cGRhdGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdXRob3JpemUvZGUtYXV0aG9yaXplIGxvY2F0aW9uIHNldHRpbmdzIGZvciBhIHBhcnRpY3VsYXIgYXBwbGljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBidW5kbGVJZCAtIFRoZSBhcHBsaWNhdGlvbiBJRCB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0aG9yaXplZCAtIFdoZXRoZXIgb3Igbm90IHRvIGF1dGhvcml6ZS5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZUxvY2F0aW9uU2V0dGluZ3MgKGJ1bmRsZUlkLCBhdXRob3JpemVkKSB7XG4gICAgcmV0dXJuIGF3YWl0IHNldHRpbmdzLnVwZGF0ZUxvY2F0aW9uU2V0dGluZ3ModGhpcywgYnVuZGxlSWQsIGF1dGhvcml6ZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzZXR0aW5ncyBmb3IgU2FmYXJpLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlcyAtIFRoZSBoYXNoIG9mIGtleS92YWx1ZSBwYWlycyB0byB1cGRhdGUgZm9yIFNhZmFyaS5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVNhZmFyaVNldHRpbmdzICh1cGRhdGVzKSB7XG4gICAgYXdhaXQgc2V0dGluZ3MudXBkYXRlU2FmYXJpVXNlclNldHRpbmdzKHRoaXMsIHVwZGF0ZXMpO1xuICAgIGF3YWl0IHNldHRpbmdzLnVwZGF0ZVNldHRpbmdzKHRoaXMsICdtb2JpbGVTYWZhcmknLCB1cGRhdGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGxvY2FsZSBmb3IgdGhlIFNpbXVsYXRvci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIC0gVGhlIGxhbmd1YWdlIGZvciB0aGUgc2ltdWxhdG9yLiBFLmcuLCBgXCJmcl9VU1wiYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsZSAtIFRoZSBsb2NhbGUgdG8gc2V0IGZvciB0aGUgc2ltdWxhdG9yLiBFLmcuLCBgXCJlblwiYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhbGVuZGFyRm9ybWF0IC0gVGhlIGZvcm1hdCBvZiB0aGUgY2FsZW5kYXIuXG4gICAqL1xuICBhc3luYyB1cGRhdGVMb2NhbGUgKGxhbmd1YWdlLCBsb2NhbGUsIGNhbGVuZGFyRm9ybWF0KSB7XG4gICAgcmV0dXJuIGF3YWl0IHNldHRpbmdzLnVwZGF0ZUxvY2FsZSh0aGlzLCBsYW5ndWFnZSwgbG9jYWxlLCBjYWxlbmRhckZvcm1hdCk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGxldGVseSBkZWxldGUgbW9iaWxlIFNhZmFyaSBhcHBsaWNhdGlvbiBmcm9tIHRoZSBjdXJyZW50IFNpbXVsYXRvci5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZVNhZmFyaSAoKSB7XG4gICAgbG9nLmRlYnVnKCdEZWxldGluZyBTYWZhcmkgYXBwcyBmcm9tIHNpbXVsYXRvcicpO1xuXG4gICAgbGV0IGRpcnMgPSBbXTtcblxuICAgIC8vIGdldCB0aGUgZGF0YSBkaXJlY3RvcnlcbiAgICBkaXJzLnB1c2goYXdhaXQgdGhpcy5nZXRBcHBEaXIoJ2NvbS5hcHBsZS5tb2JpbGVzYWZhcmknKSk7XG5cbiAgICBsZXQgcHYgPSBhd2FpdCB0aGlzLmdldFBsYXRmb3JtVmVyc2lvbigpO1xuICAgIGlmIChwdiA+PSA4KSB7XG4gICAgICAvLyBnZXQgdGhlIGJ1bmRsZSBkaXJlY3RvcnlcbiAgICAgIGRpcnMucHVzaChhd2FpdCB0aGlzLmdldEFwcERpcignY29tLmFwcGxlLm1vYmlsZXNhZmFyaScsICdCdW5kbGUnKSk7XG4gICAgfVxuXG4gICAgbGV0IGRlbGV0ZVByb21pc2VzID0gW107XG4gICAgZm9yIChsZXQgZGlyIG9mIF8uY29tcGFjdChkaXJzKSkge1xuICAgICAgbG9nLmRlYnVnKGBEZWxldGluZyBkaXJlY3Rvcnk6ICcke2Rpcn0nYCk7XG4gICAgICBkZWxldGVQcm9taXNlcy5wdXNoKGZzLnJpbXJhZihkaXIpKTtcbiAgICB9XG4gICAgYXdhaXQgQi5hbGwoZGVsZXRlUHJvbWlzZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSBkaXJlY3RvcmllcyBmb3IgbW9iaWxlIFNhZmFyaS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBrZWVwUHJlZnMgLSBXaGV0aGVyIHRvIGtlZXAgU2FmYXJpIHByZWZlcmVuY2VzIGZyb20gYmVpbmcgZGVsZXRlZC5cbiAgICovXG4gIGFzeW5jIGNsZWFuU2FmYXJpIChrZWVwUHJlZnMgPSB0cnVlKSB7XG4gICAgbG9nLmRlYnVnKCdDbGVhbmluZyBtb2JpbGUgc2FmYXJpIGRhdGEgZmlsZXMnKTtcbiAgICBpZiAoYXdhaXQgdGhpcy5pc0ZyZXNoKCkpIHtcbiAgICAgIGxvZy5pbmZvKCdDb3VsZCBub3QgZmluZCBTYWZhcmkgc3VwcG9ydCBkaXJlY3RvcmllcyB0byBjbGVhbiBvdXQgb2xkICcgK1xuICAgICAgICAgICAgICAgJ2RhdGEuIFByb2JhYmx5IHRoZXJlIGlzIG5vdGhpbmcgdG8gY2xlYW4gb3V0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGxpYnJhcnlEaXIgPSBwYXRoLnJlc29sdmUodGhpcy5nZXREaXIoKSwgJ0xpYnJhcnknKTtcbiAgICBsZXQgc2FmYXJpUm9vdCA9IGF3YWl0IHRoaXMuZ2V0QXBwRGlyKCdjb20uYXBwbGUubW9iaWxlc2FmYXJpJyk7XG4gICAgaWYgKCFzYWZhcmlSb290KSB7XG4gICAgICBsb2cuaW5mbygnQ291bGQgbm90IGZpbmQgU2FmYXJpIHN1cHBvcnQgZGlyZWN0b3JpZXMgdG8gY2xlYW4gb3V0IG9sZCAnICtcbiAgICAgICAgICAgICAgICdkYXRhLiBQcm9iYWJseSB0aGVyZSBpcyBub3RoaW5nIHRvIGNsZWFuIG91dCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2FmYXJpTGlicmFyeURpciA9IHBhdGgucmVzb2x2ZShzYWZhcmlSb290LCAnTGlicmFyeScpO1xuICAgIGxldCBmaWxlc1RvRGVsZXRlID0gW1xuICAgICAgJ0NhY2hlcy9TbmFwc2hvdHMvY29tLmFwcGxlLm1vYmlsZXNhZmFyaScsXG4gICAgICAnQ2FjaGVzL2NvbS5hcHBsZS5tb2JpbGVzYWZhcmkvKicsXG4gICAgICAnQ2FjaGVzL2NvbS5hcHBsZS5XZWJBcHBDYWNoZS8qJyxcbiAgICAgICdDYWNoZXMvY29tLmFwcGxlLldlYktpdC5OZXR3b3JraW5nLyonLFxuICAgICAgJ0NhY2hlcy9jb20uYXBwbGUuV2ViS2l0LldlYkNvbnRlbnQvKicsXG4gICAgICAnSW1hZ2UgQ2FjaGUvKicsXG4gICAgICAnV2ViS2l0L2NvbS5hcHBsZS5tb2JpbGVzYWZhcmkvKicsXG4gICAgICAnV2ViS2l0L0dlb2xvY2F0aW9uU2l0ZXMucGxpc3QnLFxuICAgICAgJ1dlYktpdC9Mb2NhbFN0b3JhZ2UvKi4qJyxcbiAgICAgICdTYWZhcmkvKicsXG4gICAgICAnQ29va2llcy8qLmJpbmFyeWNvb2tpZXMnLFxuICAgICAgJ0NhY2hlcy9jb20uYXBwbGUuVUlTdGF0dXNCYXIvKicsXG4gICAgICAnQ2FjaGVzL2NvbS5hcHBsZS5rZXlib2FyZHMvaW1hZ2VzLyonLFxuICAgICAgJ0NhY2hlcy9jb20uYXBwbGUuU2FmYXJpLlNhZmVCcm93c2luZy8qJyxcbiAgICAgICcuLi90bXAvY29tLmFwcGxlLm1vYmlsZXNhZmFyaS8qJ1xuICAgIF07XG4gICAgbGV0IGRlbGV0ZVByb21pc2VzID0gW107XG5cbiAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzVG9EZWxldGUpIHtcbiAgICAgIGRlbGV0ZVByb21pc2VzLnB1c2goZnMucmltcmFmKHBhdGgucmVzb2x2ZShsaWJyYXJ5RGlyLCBmaWxlKSkpO1xuICAgICAgZGVsZXRlUHJvbWlzZXMucHVzaChmcy5yaW1yYWYocGF0aC5yZXNvbHZlKHNhZmFyaUxpYnJhcnlEaXIsIGZpbGUpKSk7XG4gICAgfVxuXG4gICAgaWYgKCFrZWVwUHJlZnMpIHtcbiAgICAgIGRlbGV0ZVByb21pc2VzLnB1c2goZnMucmltcmFmKHBhdGgucmVzb2x2ZShzYWZhcmlMaWJyYXJ5RGlyLCAnUHJlZmVyZW5jZXMvKi5wbGlzdCcpKSk7XG4gICAgfVxuXG4gICAgYXdhaXQgQi5hbGwoZGVsZXRlUHJvbWlzZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuaW5zdGFsbCB0aGUgZ2l2ZW4gYXBwbGljYXRpb24gZnJvbSB0aGUgY3VycmVudCBTaW11bGF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBidW5kbGVJZCAtIFRoZSBidWluZGxlIElEIG9mIHRoZSBhcHBsaWNhdGlvbiB0byBiZSByZW1vdmVkLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQXBwIChidW5kbGVJZCkge1xuICAgIGF3YWl0IHNpbWN0bC5yZW1vdmVBcHAodGhpcy51ZGlkLCBidW5kbGVJZCk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSBhIGJ1aWx0LWluIGFwcGxpY2F0aW9uIHRvIGEgbmV3IHBsYWNlIChhY3R1YWxseSwgcmVuYW1lIGl0KS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFwcE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYXBwIHRvIGJlIG1vdmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwUGF0aCAtIFRoZSBjdXJyZW50IHBhdGggdG8gdGhlIGFwcGxpY2F0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3QXBwUGF0aCAtIFRoZSBuZXcgcGF0aCB0byB0aGUgYXBwbGljYXRpb24uXG4gICAqICAgSWYgc29tZSBhcHBsaWNhdGlvbiBhbHJlYWR5IGV4aXN0cyBieSB0aGlzIHBhdGggdGhlbiBpdCdzIGdvaW5nIHRvIGJlIHJlbW92ZWQuXG4gICAqL1xuICBhc3luYyBtb3ZlQnVpbHRJbkFwcCAoYXBwTmFtZSwgYXBwUGF0aCwgbmV3QXBwUGF0aCkge1xuICAgIGF3YWl0IHNhZmVSaW1SYWYobmV3QXBwUGF0aCk7XG4gICAgYXdhaXQgZnMuY29weUZpbGUoYXBwUGF0aCwgbmV3QXBwUGF0aCk7XG4gICAgbG9nLmRlYnVnKGBDb3BpZWQgJyR7YXBwTmFtZX0nIHRvICcke25ld0FwcFBhdGh9J2ApO1xuXG4gICAgYXdhaXQgZnMucmltcmFmKGFwcFBhdGgpO1xuICAgIGxvZy5kZWJ1ZyhgVGVtcG9yYXJpbHkgZGVsZXRlZCBvcmlnaW5hbCBhcHAgYXQgJyR7YXBwUGF0aH0nYCk7XG5cbiAgICByZXR1cm4gW25ld0FwcFBhdGgsIGFwcFBhdGhdO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gdGhlIGdpdmVuIFVSTCBpbiBtb2JpbGUgU2FmYXJpIGJyb3dzZXIuXG4gICAqIFRoZSBicm93c2VyIHdpbGwgYmUgc3RhcnRlZCBhdXRvbWF0aWNhbGx5IGlmIGl0IGlzIG5vdCBydW5uaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIFVSTCB0byBiZSBvcGVuZWQuXG4gICAqL1xuICBhc3luYyBvcGVuVXJsICh1cmwpIHtcbiAgICBjb25zdCBTQUZBUklfQk9PVEVEX0lORElDQVRPUiA9ICdNb2JpbGVTYWZhcmlbJztcbiAgICBjb25zdCBTQUZBUklfU1RBUlRVUF9USU1FT1VUID0gMTUgKiAxMDAwO1xuICAgIGNvbnN0IEVYVFJBX1NUQVJUVVBfVElNRSA9IDMgKiAxMDAwO1xuXG4gICAgaWYgKGF3YWl0IHRoaXMuaXNSdW5uaW5nKCkpIHtcbiAgICAgIGF3YWl0IHJldHJ5KDUwMDAsIHNpbWN0bC5vcGVuVXJsLCB0aGlzLnVkaWQsIHVybCk7XG4gICAgICBhd2FpdCB0aGlzLnRhaWxMb2dzVW50aWwoU0FGQVJJX0JPT1RFRF9JTkRJQ0FUT1IsIFNBRkFSSV9TVEFSVFVQX1RJTUVPVVQpO1xuICAgICAgLy8gU28gc29ycnksIGJ1dCB0aGUgbG9ncyBoYXZlIG5vdGhpbmcgZWxzZSBmb3IgU2FmYXJpIHN0YXJ0aW5nLi4ganVzdCBkZWxheSBhIGxpdHRsZSBiaXRcbiAgICAgIGxvZy5kZWJ1ZyhgU2FmYXJpIHN0YXJ0ZWQsIHdhaXRpbmcgJHtFWFRSQV9TVEFSVFVQX1RJTUV9bXMgZm9yIGl0IHRvIGZ1bGx5IHN0YXJ0YCk7XG4gICAgICBhd2FpdCBCLmRlbGF5KEVYVFJBX1NUQVJUVVBfVElNRSk7XG4gICAgICBsb2cuZGVidWcoJ0RvbmUgd2FpdGluZyBmb3IgU2FmYXJpJyk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gb3BlbiBhIHVybCwgYnV0IHRoZSBTaW11bGF0b3IgaXMgbm90IEJvb3RlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIFNpbXVsYXRvciBjYWNoZXMgY2xlYW51cC5cbiAgICpcbiAgICogQHBhcmFtIHsuLi5zdHJpbmd9IGZvbGRlck5hbWVzIC0gVGhlIG5hbWVzIG9mIENhY2hlcyBzdWJmb2xkZXJzIHRvIGJlIGNsZWFuZWQuXG4gICAqICAgTm9uLWFjY2Vzc2libGUvbm9uLWV4aXN0aW5nIHN1YmZvbGRlcnMgd2lsbCBiZSBza2lwcGVkLlxuICAgKiAgIEFsbCBleGlzdGluZyBzdWJmb2xkZXJzIHVuZGVyIENhY2hlcyB3aWxsIGJlIGRlbGV0ZWQgaWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZC5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIGNvdW50IG9mIGNsZWFuZWQgY2FjaGUgaXRlbXMuXG4gICAqICAgWmVybyBpcyByZXR1cm5lZCBpZiBubyBpdGVtcyB3ZXJlIG1hdGNoZWQgZm9yIGNsZWFudXAgKGVpdGhlciBub3QgYWNjZXNzaWJsZSBvciBub3QgZGlyZWN0b3JpZXMpLlxuICAgKi9cbiAgYXN5bmMgY2xlYXJDYWNoZXMgKC4uLmZvbGRlck5hbWVzKSB7XG4gICAgY29uc3QgY2FjaGVzUm9vdCA9IHBhdGgucmVzb2x2ZSh0aGlzLmdldERpcigpLCAnTGlicmFyeScsICdDYWNoZXMnKTtcbiAgICBpZiAoIShhd2FpdCBmcy5oYXNBY2Nlc3MoY2FjaGVzUm9vdCkpKSB7XG4gICAgICBsb2cuZGVidWcoYENhY2hlcyByb290IGF0ICcke2NhY2hlc1Jvb3R9JyBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYWNjZXNzaWJsZS4gTm90aGluZyB0byBkbyB0aGVyZWApO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgbGV0IGl0ZW1zVG9SZW1vdmUgPSBmb2xkZXJOYW1lcy5sZW5ndGggPyBmb2xkZXJOYW1lcyA6IChhd2FpdCBmcy5yZWFkZGlyKGNhY2hlc1Jvb3QpKTtcbiAgICBpdGVtc1RvUmVtb3ZlID0gaXRlbXNUb1JlbW92ZS5tYXAoKHgpID0+IHBhdGgucmVzb2x2ZShjYWNoZXNSb290LCB4KSk7XG4gICAgaWYgKGZvbGRlck5hbWVzLmxlbmd0aCkge1xuICAgICAgaXRlbXNUb1JlbW92ZSA9IGF3YWl0IEIuZmlsdGVyKGl0ZW1zVG9SZW1vdmUsICh4KSA9PiBmcy5oYXNBY2Nlc3MoeCkpO1xuICAgIH1cbiAgICBpdGVtc1RvUmVtb3ZlID0gYXdhaXQgQi5maWx0ZXIoaXRlbXNUb1JlbW92ZSwgYXN5bmMgKHgpID0+IChhd2FpdCBmcy5zdGF0KHgpKS5pc0RpcmVjdG9yeSgpKTtcbiAgICBpZiAoIWl0ZW1zVG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgICBsb2cuZGVidWcoYE5vIFNpbXVsYXRvciBjYWNoZSBpdGVtcyBmb3IgY2xlYW51cCB3ZXJlIG1hdGNoZWQgaW4gJyR7Y2FjaGVzUm9vdH0nYCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBsb2cuZGVidWcoYE1hdGNoZWQgJHtpdGVtc1RvUmVtb3ZlLmxlbmd0aH0gU2ltdWxhdG9yIGNhY2hlIGAgK1xuICAgICAgYGl0ZW0ke2l0ZW1zVG9SZW1vdmUubGVuZ3RoID09PSAxID8gJycgOiAncyd9IGZvciBjbGVhbnVwOiAke2l0ZW1zVG9SZW1vdmV9YCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IEIuYWxsKGl0ZW1zVG9SZW1vdmUsICh4KSA9PiBmcy5yaW1yYWYoeCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZy53YXJuKGBHb3QgYW4gZXhjZXB0aW9uIHdoaWxlIGNsZWFuaW5nIFNpbXVsYXRvciBjYWNoZXM6ICR7ZS5tZXNzYWdlfWApO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXNUb1JlbW92ZS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQmxvY2tzIHVudGlsIHRoZSBnaXZlbiBpbmRpY2F0ZXIgc3RyaW5nIGFwcGVhcnMgaW4gU2ltdWxhdG9yIGxvZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBib290ZWRJbmRpY2F0b3IgLSBUaGUgbWFnaWMgc3RyaW5nLCB3aGljaCBhcHBlYXJzIGluIGxvZ3MgYWZ0ZXIgU2ltdWxhdG9yIGJvb3RpbmcgaXMgY29tcGxldGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1zIC0gVGhlIG1heGltdW1tIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIHN0cmluZyBpbmRpY2F0b3IgcHJlc2VuY2UuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBpb3Mgc2ltdWxhdG9yIGxvZ3Mgb3V0cHV0IGEgbGluZSBtYXRjaGluZyBgYm9vdGVkSW5kaWNhdG9yYFxuICAgKiB0aW1lcyBvdXQgYWZ0ZXIgdGltZW91dE1zXG4gICAqL1xuICBhc3luYyB0YWlsTG9nc1VudGlsIChib290ZWRJbmRpY2F0b3IsIHRpbWVvdXRNcykge1xuICAgIGxldCBzaW1Mb2cgPSBwYXRoLnJlc29sdmUodGhpcy5nZXRMb2dEaXIoKSwgJ3N5c3RlbS5sb2cnKTtcblxuICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGxvZyBmaWxlIGV4aXN0cyBiZWZvcmUgd2UgY2FuIHRhaWwgaXRcbiAgICBhd2FpdCByZXRyeUludGVydmFsKDIwMCwgMjAwLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgZXhpc3RzID0gYXdhaXQgZnMuZXhpc3RzKHNpbUxvZyk7XG4gICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIFNpbXVsYXRvciBsb2c6ICcke3NpbUxvZ30nYCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsb2cuaW5mbyhgU2ltdWxhdG9yIGxvZyBhdCAnJHtzaW1Mb2d9J2ApO1xuICAgIGxvZy5pbmZvKGBUYWlsaW5nIHNpbXVsYXRvciBsb2dzIHVudGlsIHdlIGVuY291bnRlciB0aGUgc3RyaW5nIFwiJHtib290ZWRJbmRpY2F0b3J9XCJgKTtcbiAgICBsb2cuaW5mbyhgV2Ugd2lsbCB0aW1lIG91dCBhZnRlciAke3RpbWVvdXRNc31tc2ApO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0YWlsVW50aWwoc2ltTG9nLCBib290ZWRJbmRpY2F0b3IsIHRpbWVvdXRNcyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZGVidWcoJ1NpbXVsYXRvciBzdGFydHVwIHRpbWVkIG91dC4gQ29udGludWluZyBhbnl3YXkuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBDYWxlbmRhciBhY2Nlc3MgZm9yIHRoZSBnaXZlbiBhcHBsaWNhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJ1bmRsZUlEIC0gQnVuZGxlIElEIG9mIHRoZSBhcHBsaWNhdGlvbiwgZm9yIHdoaWNoIHRoZSBhY2Nlc3Mgc2hvdWxkIGJlIGdyYW50ZWQuXG4gICAqL1xuICBhc3luYyBlbmFibGVDYWxlbmRhckFjY2VzcyAoYnVuZGxlSUQpIHtcbiAgICBhd2FpdCB0aGlzLmNhbGVuZGFyLmVuYWJsZUNhbGVuZGFyQWNjZXNzKGJ1bmRsZUlEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIENhbGVuZGFyIGFjY2VzcyBmb3IgdGhlIGdpdmVuIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYnVuZGxlSUQgLSBCdW5kbGUgSUQgb2YgdGhlIGFwcGxpY2F0aW9uLCBmb3Igd2hpY2ggdGhlIGFjY2VzcyBzaG91bGQgYmUgZGVuaWVkLlxuICAgKi9cbiAgYXN5bmMgZGlzYWJsZUNhbGVuZGFyQWNjZXNzIChidW5kbGVJRCkge1xuICAgIGF3YWl0IHRoaXMuY2FsZW5kYXIuZGlzYWJsZUNhbGVuZGFyQWNjZXNzKGJ1bmRsZUlEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBhcHBsaWNhdGlvbiBoYXMgYWNjZXNzIHRvIENhbGVuZGFyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnaXZlbiBhcHBsaWNhdGlvbiBoYXMgdGhlIGFjY2Vzcy5cbiAgICovXG4gIGFzeW5jIGhhc0NhbGVuZGFyQWNjZXNzIChidW5kbGVJRCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNhbGVuZGFyLmhhc0NhbGVuZGFyQWNjZXNzKGJ1bmRsZUlEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBBcHBsZSBzY3JpcHQsIHdoaWNoIGFjdGl2YXRlcyBTaW11bGF0b3IuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBnZW5lcmF0ZWQgQXBwbGUgU2NyaXB0IHNuaXBwZXQuXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVdpbmRvd0FjdGl2YXRpb25TY3JpcHQgKCkge1xuICAgIHJldHVybiBgXG4gICAgICB0ZWxsIGFwcGxpY2F0aW9uIFwiU3lzdGVtIEV2ZW50c1wiXG4gICAgICAgIHRlbGwgcHJvY2VzcyBcIlNpbXVsYXRvclwiXG4gICAgICAgICAgc2V0IGZyb250bW9zdCB0byBmYWxzZVxuICAgICAgICAgIHNldCBmcm9udG1vc3QgdG8gdHJ1ZVxuICAgICAgICBlbmQgdGVsbFxuICAgICAgZW5kIHRlbGxcbiAgICBgO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgZ2l2ZW4gQXBwbGUgU2NyaXB0IGluc2lkZSBhIGNyaXRpY2FsIHNlY3Rpb24sIHNvIG90aGVyXG4gICAqIHNlc3Npb25zIGNhbm5vdCBpbmZsdWVuY2UgdGhlIFVJIGNsaWVudCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwbGVTY3JpcHQgLSBUaGUgdmFsaWQgQXBwbGUgU2NyaXB0IHNuaXBwZXQgdG8gYmUgZXhlY3V0ZWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0ZG91dCBvdXRwdXQgcHJvZHVjZWQgYnkgdGhlIHNjcmlwdC5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIG9zYXNjcmlwdCB0b29sIHJldHVybnMgbm9uLXplcm8gZXhpdCBjb2RlLlxuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZVVJQ2xpZW50U2NyaXB0IChhcHBsZVNjcmlwdCkge1xuICAgIGNvbnN0IHdpbmRvd0FjdGl2YXRpb25TY3JpcHQgPSBhd2FpdCB0aGlzLmdlbmVyYXRlV2luZG93QWN0aXZhdGlvblNjcmlwdCgpO1xuICAgIGNvbnN0IHJlc3VsdFNjcmlwdCA9IGAke3dpbmRvd0FjdGl2YXRpb25TY3JpcHR9XFxuJHthcHBsZVNjcmlwdH1gO1xuICAgIGxvZy5kZWJ1ZyhgRXhlY3V0aW5nIFVJIEFwcGxlIFNjcmlwdCBvbiBTaW11bGF0b3Igd2l0aCBVRElEICR7dGhpcy51ZGlkfTogJHtyZXN1bHRTY3JpcHR9YCk7XG4gICAgcmV0dXJuIGF3YWl0IFVJX0NMSUVOVF9BQ0NFU1NfR1VBUkQuYWNxdWlyZSh0aGlzLnNpbXVsYXRvckFwcCwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKCdvc2FzY3JpcHQnLCBbJy1lJywgcmVzdWx0U2NyaXB0XSk7XG4gICAgICAgIHJldHVybiBzdGRvdXQ7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yQW5kVGhyb3coYE1ha2Ugc3VyZSBTaW11bGF0b3IgVUkgaXMgcnVubmluZyBhbmQgdGhlIHBhcmVudCBBcHBpdW0gYXBwbGljYXRpb24gKGUuIGcuIEFwcGl1bS5hcHAgb3IgVGVybWluYWwuYXBwKSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYGlzIHByZXNlbnQgaW4gU3lzdGVtIFByZWZlcmVuY2VzID4gU2VjdXJpdHkgJiBQcml2YWN5ID4gUHJpdmFjeSA+IEFjY2Vzc2liaWxpdHkgbGlzdC4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgVG91Y2ggSUQgRW5yb2xsbWVudCBmZWF0dXJlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIFRvdWNoIElEIEVucm9sbG1lbnQgbWVudSBpdGVtIGlzIGNoZWNrZWQgaW4gU2ltdWxhdG9yIG1lbnVcbiAgICovXG4gIGFzeW5jIGlzVG91Y2hJREVucm9sbGVkICgpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVVSUNsaWVudFNjcmlwdChgXG4gICAgICB0ZWxsIGFwcGxpY2F0aW9uIFwiU3lzdGVtIEV2ZW50c1wiXG4gICAgICAgIHRlbGwgcHJvY2VzcyBcIlNpbXVsYXRvclwiXG4gICAgICAgICAgc2V0IGRzdE1lbnVJdGVtIHRvIG1lbnUgaXRlbSBcIlRvZ2dsZSBFbnJvbGxlZCBTdGF0ZVwiIG9mIG1lbnUgMSBvZiBtZW51IGl0ZW0gXCJUb3VjaCBJRFwiIG9mIG1lbnUgMSBvZiBtZW51IGJhciBpdGVtIFwiSGFyZHdhcmVcIiBvZiBtZW51IGJhciAxXG4gICAgICAgICAgc2V0IGlzQ2hlY2tlZCB0byAodmFsdWUgb2YgYXR0cmlidXRlIFwiQVhNZW51SXRlbU1hcmtDaGFyXCIgb2YgZHN0TWVudUl0ZW0pIGlzIFwi4pyTXCJcbiAgICAgICAgZW5kIHRlbGxcbiAgICAgIGVuZCB0ZWxsXG4gICAgYCk7XG4gICAgbG9nLmRlYnVnKGBUb3VjaCBJRCBlbnJvbGxlZCBzdGF0ZTogJHtvdXRwdXR9YCk7XG4gICAgcmV0dXJuIF8uaXNTdHJpbmcob3V0cHV0KSAmJiBvdXRwdXQudHJpbSgpID09PSAndHJ1ZSc7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIHNwZWNpYWwgQXBwbGUgc2NyaXB0LCB3aGljaCBjaGFuZ2VzIFRvdWNoIElEIGZlYXR1cmUgdGVzdGluZyBpbiBTaW11bGF0b3IgVUkgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRW5hYmxlZCAtIFNldCBpdCB0byBmYWxzZSBpbiBvcmRlciB0byB1bmNoZWNrICdUb2dnbGUgRW5yb2xsZWQgU3RhdGUnIGZsYWdcbiAgICovXG4gIGFzeW5jIGVucm9sbFRvdWNoSUQgKGlzRW5hYmxlZCA9IHRydWUpIHtcbiAgICBhd2FpdCB0aGlzLmV4ZWN1dGVVSUNsaWVudFNjcmlwdChgXG4gICAgICB0ZWxsIGFwcGxpY2F0aW9uIFwiU3lzdGVtIEV2ZW50c1wiXG4gICAgICAgIHRlbGwgcHJvY2VzcyBcIlNpbXVsYXRvclwiXG4gICAgICAgICAgc2V0IGRzdE1lbnVJdGVtIHRvIG1lbnUgaXRlbSBcIlRvZ2dsZSBFbnJvbGxlZCBTdGF0ZVwiIG9mIG1lbnUgMSBvZiBtZW51IGl0ZW0gXCJUb3VjaCBJRFwiIG9mIG1lbnUgMSBvZiBtZW51IGJhciBpdGVtIFwiSGFyZHdhcmVcIiBvZiBtZW51IGJhciAxXG4gICAgICAgICAgc2V0IGlzQ2hlY2tlZCB0byAodmFsdWUgb2YgYXR0cmlidXRlIFwiQVhNZW51SXRlbU1hcmtDaGFyXCIgb2YgZHN0TWVudUl0ZW0pIGlzIFwi4pyTXCJcbiAgICAgICAgICBpZiAke2lzRW5hYmxlZCA/ICdub3QgJyA6ICcnfWlzQ2hlY2tlZCB0aGVuXG4gICAgICAgICAgICBjbGljayBkc3RNZW51SXRlbVxuICAgICAgICAgIGVuZCBpZlxuICAgICAgICBlbmQgdGVsbFxuICAgICAgZW5kIHRlbGxcbiAgICBgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgc3BlY2lhbCBBcHBsZSBzY3JpcHQsIHdoaWNoIGNsaWNrcyB0aGUgcGFydGljdWxhciBidXR0b24gb24gRGF0YWJhc2UgYWxlcnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jcmVhc2UgLSBDbGljayB0aGUgYnV0dG9uIHdpdGggJ0luY3JlYXNlJyB0aXRsZSBvbiB0aGUgYWxlcnQgaWYgdGhpc1xuICAgKiAgIHBhcmFtZXRlciBpcyB0cnVlLiBUaGUgJ0NhbmNlbCcgYnV0dG9uIHdpbGwgYmUgY2xpY2tlZCBvdGhlcndpc2UuXG4gICAqL1xuICBhc3luYyBkaXNtaXNzRGF0YWJhc2VBbGVydCAoaW5jcmVhc2UgPSB0cnVlKSB7XG4gICAgbGV0IGJ1dHRvbiA9IGluY3JlYXNlID8gJ0luY3JlYXNlJyA6ICdDYW5jZWwnO1xuICAgIGxvZy5kZWJ1ZyhgQXR0ZW1wdGluZyB0byBkaXNtaXNzIGRhdGFiYXNlIGFsZXJ0IHdpdGggJyR7YnV0dG9ufScgYnV0dG9uYCk7XG4gICAgYXdhaXQgdGhpcy5leGVjdXRlVUlDbGllbnRTY3JpcHQoYFxuICAgICAgdGVsbCBhcHBsaWNhdGlvbiBcIlN5c3RlbSBFdmVudHNcIlxuICAgICAgICB0ZWxsIHByb2Nlc3MgXCJTaW11bGF0b3JcIlxuICAgICAgICAgIGNsaWNrIGJ1dHRvbiBcIiR7YnV0dG9ufVwiIG9mIHdpbmRvdyAxXG4gICAgICAgIGVuZCB0ZWxsXG4gICAgICBlbmQgdGVsbFxuICAgIGApO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIF9nZXREZXZpY2VTdHJpbmdQbGF0Zm9ybVZlcnNpb24gKHBsYXRmb3JtVmVyc2lvbikge1xuICAgIGxldCByZXFWZXJzaW9uID0gcGxhdGZvcm1WZXJzaW9uO1xuICAgIGlmICghcmVxVmVyc2lvbikge1xuICAgICAgcmVxVmVyc2lvbiA9IGF3YWl0IHhjb2RlLmdldE1heElPU1NESygpO1xuICAgICAgbG9nLndhcm4oYE5vIHBsYXRmb3JtIHZlcnNpb24gc2V0LiBVc2luZyBtYXggU0RLIHZlcnNpb246ICR7cmVxVmVyc2lvbn1gKTtcbiAgICAgIC8vIHRoaXMgd2lsbCBiZSBhIG51bWJlciwgYW5kIHBvc3NpYmx5IGFuIGludGVnZXIgKGUuZy4sIGlmIG1heCBpT1MgU0RLIGlzIDkpXG4gICAgICAvLyBzbyB0dXJuIGl0IGludG8gYSBzdHJpbmcgYW5kIGFkZCBhIC4wIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKCFfLmlzU3RyaW5nKHJlcVZlcnNpb24pKSB7XG4gICAgICAgIHJlcVZlcnNpb24gPSAocmVxVmVyc2lvbiAlIDEpID8gU3RyaW5nKHJlcVZlcnNpb24pIDogYCR7cmVxVmVyc2lvbn0uMGA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXFWZXJzaW9uO1xuICB9XG5cbiAgLy8gY2hhbmdlIHRoZSBmb3JtYXQgaW4gc3ViY2xhc3NlcywgYXMgbmVjZXNzYXJ5XG4gIHN0YXRpYyBhc3luYyBfZ2V0RGV2aWNlU3RyaW5nVmVyc2lvblN0cmluZyAocGxhdGZvcm1WZXJzaW9uKSB7XG4gICAgbGV0IHJlcVZlcnNpb24gPSBhd2FpdCB0aGlzLl9nZXREZXZpY2VTdHJpbmdQbGF0Zm9ybVZlcnNpb24ocGxhdGZvcm1WZXJzaW9uKTtcblxuICAgIHJldHVybiBgKCR7cmVxVmVyc2lvbn0gU2ltdWxhdG9yKWA7XG4gIH1cblxuICAvLyBjaGFuZ2UgdGhlIGZvcm1hdCBpbiBzdWJjbGFzc2VzLCBhcyBuZWNlc3NhcnlcbiAgc3RhdGljIF9nZXREZXZpY2VTdHJpbmdDb25maWdGaXggKCkge1xuICAgIC8vIHNvbWUgZGV2aWNlcyBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgICByZXR1cm4ge1xuICAgICAgJ2lQYWQgU2ltdWxhdG9yICg3LjEgU2ltdWxhdG9yKSc6ICdpUGFkIDIgKDcuMSBTaW11bGF0b3IpJyxcbiAgICAgICdpUGFkIFNpbXVsYXRvciAoOC4wIFNpbXVsYXRvciknOiAnaVBhZCAyICg4LjAgU2ltdWxhdG9yKScsXG4gICAgICAnaVBhZCBTaW11bGF0b3IgKDguMSBTaW11bGF0b3IpJzogJ2lQYWQgMiAoOC4xIFNpbXVsYXRvciknLFxuICAgICAgJ2lQYWQgU2ltdWxhdG9yICg4LjIgU2ltdWxhdG9yKSc6ICdpUGFkIDIgKDguMiBTaW11bGF0b3IpJyxcbiAgICAgICdpUGFkIFNpbXVsYXRvciAoOC4zIFNpbXVsYXRvciknOiAnaVBhZCAyICg4LjMgU2ltdWxhdG9yKScsXG4gICAgICAnaVBhZCBTaW11bGF0b3IgKDguNCBTaW11bGF0b3IpJzogJ2lQYWQgMiAoOC40IFNpbXVsYXRvciknLFxuICAgICAgJ2lQaG9uZSBTaW11bGF0b3IgKDcuMSBTaW11bGF0b3IpJzogJ2lQaG9uZSA1cyAoNy4xIFNpbXVsYXRvciknLFxuICAgICAgJ2lQaG9uZSBTaW11bGF0b3IgKDguNCBTaW11bGF0b3IpJzogJ2lQaG9uZSA2ICg4LjQgU2ltdWxhdG9yKScsXG4gICAgICAnaVBob25lIFNpbXVsYXRvciAoOC4zIFNpbXVsYXRvciknOiAnaVBob25lIDYgKDguMyBTaW11bGF0b3IpJyxcbiAgICAgICdpUGhvbmUgU2ltdWxhdG9yICg4LjIgU2ltdWxhdG9yKSc6ICdpUGhvbmUgNiAoOC4yIFNpbXVsYXRvciknLFxuICAgICAgJ2lQaG9uZSBTaW11bGF0b3IgKDguMSBTaW11bGF0b3IpJzogJ2lQaG9uZSA2ICg4LjEgU2ltdWxhdG9yKScsXG4gICAgICAnaVBob25lIFNpbXVsYXRvciAoOC4wIFNpbXVsYXRvciknOiAnaVBob25lIDYgKDguMCBTaW11bGF0b3IpJ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSBzZXQgb2Ygb3B0aW9ucyBhbmQgZmluZHMgdGhlIGNvcnJlY3QgZGV2aWNlIHN0cmluZyBpbiBvcmRlciBmb3IgSW5zdHJ1bWVudHMgdG9cbiAgICogaWRlbnRpZnkgdGhlIGNvcnJlY3Qgc2ltdWxhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zIGF2YWlsYWJsZSBhcmU6XG4gICAqICAgLSBgZGV2aWNlTmFtZWAgLSBhIG5hbWUgZm9yIHRoZSBkZXZpY2UuIElmIHRoZSBnaXZlbiBkZXZpY2UgbmFtZSBzdGFydHMgd2l0aCBgPWAsIHRoZSBuYW1lLCBsZXNzIHRoZSBlcXVhbHMgc2lnbiwgaXMgcmV0dXJuZWQuXG4gICAqICAgLSBgcGxhdGZvcm1WZXJzaW9uYCAtIHRoZSB2ZXJzaW9uIG9mIGlPUyB0byB1c2UuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IFhjb2RlJ3MgbWF4aW11bSBTREsgdmVyc2lvbi5cbiAgICogICAtIGBmb3JjZUlwaG9uZWAgLSBmb3JjZSB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgZGV2aWNlIHN0cmluZyB0byBpUGhvbmUuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqICAgLSBgZm9yY2VJcGFkYCAtIGZvcmNlIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBkZXZpY2Ugc3RyaW5nIHRvIGlQYWQuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqICAgSWYgYm90aCBgZm9yY2VJcGhvbmVgIGFuZCBgZm9yY2VJcGFkYCBhcmUgdHJ1ZSwgdGhlIGRldmljZSB3aWxsIGJlIGZvcmNlZCB0byBpUGhvbmUuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGZvdW5kIGRldmljZSBzdHJpbmcuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0RGV2aWNlU3RyaW5nIChvcHRzKSB7XG4gICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgIGRldmljZU5hbWU6IG51bGwsXG4gICAgICBwbGF0Zm9ybVZlcnNpb246IG51bGwsXG4gICAgICBmb3JjZUlwaG9uZTogZmFsc2UsXG4gICAgICBmb3JjZUlwYWQ6IGZhbHNlXG4gICAgfSwgb3B0cyk7XG4gICAgbGV0IGxvZ09wdHMgPSB7XG4gICAgICBkZXZpY2VOYW1lOiBvcHRzLmRldmljZU5hbWUsXG4gICAgICBwbGF0Zm9ybVZlcnNpb246IG9wdHMucGxhdGZvcm1WZXJzaW9uLFxuICAgICAgZm9yY2VJcGhvbmU6IG9wdHMuZm9yY2VJcGhvbmUsXG4gICAgICBmb3JjZUlwYWQ6IG9wdHMuZm9yY2VJcGFkXG4gICAgfTtcbiAgICBsb2cuZGVidWcoYEdldHRpbmcgZGV2aWNlIHN0cmluZyBmcm9tIG9wdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkobG9nT3B0cyl9YCk7XG5cbiAgICAvLyBzaG9ydCBjaXJjdWl0IGlmIHdlIGFscmVhZHkgaGF2ZSBhIGRldmljZSBuYW1lXG4gICAgaWYgKChvcHRzLmRldmljZU5hbWUgfHwgJycpWzBdID09PSAnPScpIHtcbiAgICAgIHJldHVybiBvcHRzLmRldmljZU5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIGxldCBpc2lQaG9uZSA9ICEhb3B0cy5mb3JjZUlwaG9uZSB8fCAhb3B0cy5mb3JjZUlwYWQ7XG5cbiAgICBpZiAob3B0cy5kZXZpY2VOYW1lKSB7XG4gICAgICBsZXQgZGV2aWNlID0gb3B0cy5kZXZpY2VOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoZGV2aWNlLmluZGV4T2YoJ2lwaG9uZScpICE9PSAtMSkge1xuICAgICAgICBpc2lQaG9uZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRldmljZS5pbmRleE9mKCdpcGFkJykgIT09IC0xKSB7XG4gICAgICAgIGlzaVBob25lID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGlvc0RldmljZVN0cmluZyA9IG9wdHMuZGV2aWNlTmFtZSB8fCAoaXNpUGhvbmUgPyAnaVBob25lIFNpbXVsYXRvcicgOiAnaVBhZCBTaW11bGF0b3InKTtcblxuICAgIC8vIGlmIHNvbWVvbmUgcGFzc2VzIGluIGp1c3QgXCJpUGhvbmVcIiwgbWFrZSB0aGF0IFwiaVBob25lIFNpbXVsYXRvclwiIHRvXG4gICAgLy8gY29uZm9ybSB0byBhbGwgdGhlIGxvZ2ljIGJlbG93XG4gICAgaWYgKC9eKGlQaG9uZXxpUGFkKSQvLnRlc3QoaW9zRGV2aWNlU3RyaW5nKSkge1xuICAgICAgaW9zRGV2aWNlU3RyaW5nICs9IFwiIFNpbXVsYXRvclwiO1xuICAgIH1cblxuICAgIC8vIHdlIHN1cHBvcnQgZGV2aWNlTmFtZTogXCJpUGhvbmUgU2ltdWxhdG9yXCIsIGFuZCBhbHNvIHdhbnQgdG8gc3VwcG9ydFxuICAgIC8vIFwiaVBob25lIFhZWiBTaW11bGF0b3JcIiwgYnV0IHRoZXNlIHN0cmluZ3MgYXJlbid0IGluIHRoZSBkZXZpY2UgbGlzdC5cbiAgICAvLyBTbywgaWYgc29tZW9uZSBzZW50IGluIFwiaVBob25lIFhZWiBTaW11bGF0b3JcIiwgc3RyaXAgb2ZmIFwiIFNpbXVsYXRvclwiXG4gICAgLy8gaW4gb3JkZXIgdG8gYWxsb3cgdGhlIGRlZmF1bHQgXCJpUGhvbmUgWFlaXCIgbWF0Y2hcbiAgICBpZiAoL1teKGlQaG9uZXxpUGFkKV0gU2ltdWxhdG9yLy50ZXN0KGlvc0RldmljZVN0cmluZykpIHtcbiAgICAgIGlvc0RldmljZVN0cmluZyA9IGlvc0RldmljZVN0cmluZy5yZXBsYWNlKFwiIFNpbXVsYXRvclwiLCBcIlwiKTtcbiAgICB9XG4gICAgaW9zRGV2aWNlU3RyaW5nICs9IGAgJHthd2FpdCB0aGlzLl9nZXREZXZpY2VTdHJpbmdWZXJzaW9uU3RyaW5nKG9wdHMucGxhdGZvcm1WZXJzaW9uKX1gO1xuXG4gICAgbGV0IENPTkZJR19GSVggPSB0aGlzLl9nZXREZXZpY2VTdHJpbmdDb25maWdGaXgoKTtcblxuICAgIGxldCBjb25maWdGaXggPSBDT05GSUdfRklYO1xuICAgIGlmIChjb25maWdGaXhbaW9zRGV2aWNlU3RyaW5nXSkge1xuICAgICAgaW9zRGV2aWNlU3RyaW5nID0gY29uZmlnRml4W2lvc0RldmljZVN0cmluZ107XG4gICAgICBsb2cuZGVidWcoYEZpeGluZyBkZXZpY2UuIENoYW5nZWQgZnJvbSAnJHtvcHRzLmRldmljZU5hbWV9JyBgK1xuICAgICAgICAgICAgICAgICAgIGB0byAnJHtpb3NEZXZpY2VTdHJpbmd9J2ApO1xuICAgIH1cblxuICAgIGxvZy5kZWJ1ZyhgRmluYWwgZGV2aWNlIHN0cmluZyBpcyAnJHtpb3NEZXZpY2VTdHJpbmd9J2ApO1xuICAgIHJldHVybiBpb3NEZXZpY2VTdHJpbmc7XG4gIH1cbn1cblxuZm9yIChsZXQgW2NtZCwgZm5dIG9mIF8udG9QYWlycyhleHRlbnNpb25zKSkge1xuICBTaW11bGF0b3JYY29kZTYucHJvdG90eXBlW2NtZF0gPSBmbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2ltdWxhdG9yWGNvZGU2O1xuZXhwb3J0IHsgU2ltdWxhdG9yWGNvZGU2LCBCT09UX0NPTVBMRVRFRF9FVkVOVCB9O1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
