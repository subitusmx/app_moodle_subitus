'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _simulatorXcode6 = require('./simulator-xcode-6');

var _simulatorXcode7 = require('./simulator-xcode-7');

var _simulatorXcode72 = _interopRequireDefault(_simulatorXcode7);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _asyncbox = require('asyncbox');

var _teen_process = require('teen_process');

var _nodeSimctl = require('node-simctl');

// these sims are sloooooooow
var STARTUP_TIMEOUT = 120 * 1000;
var SAFARI_STARTUP_TIMEOUT = 25 * 1000;
var SPRINGBOARD_BUNDLE_ID = 'com.apple.springboard';
var MOBILE_SAFARI_BUNDLE_ID = 'com.apple.mobilesafari';
var UI_CLIENT_BUNDLE_ID = 'com.apple.iphonesimulator';
var PROCESS_LAUNCH_OK_PATTERN = function PROCESS_LAUNCH_OK_PATTERN(bundleId) {
  return new RegExp(bundleId.replace('.', '\\.') + ':\\s+\\d+');
};

var SimulatorXcode8 = (function (_SimulatorXcode7) {
  _inherits(SimulatorXcode8, _SimulatorXcode7);

  function SimulatorXcode8(udid, xcodeVersion) {
    _classCallCheck(this, SimulatorXcode8);

    _get(Object.getPrototypeOf(SimulatorXcode8.prototype), 'constructor', this).call(this, udid, xcodeVersion);

    // list of files to check for when seeing if a simulator is "fresh"
    // (meaning it has never been booted).
    // If these files are present, we assume it's been successfully booted
    this.isFreshFiles = ['Library/Cookies', 'Library/Preferences/.GlobalPreferences.plist', 'Library/Preferences/com.apple.springboard.plist', 'var/run/syslog.pid'];
  }

  /**
   * @return {string} Bundle identifier of Simulator UI client.
   */

  _createClass(SimulatorXcode8, [{
    key: 'isUIClientRunning',

    /**
     * Check the state of Simulator UI client.
     * @Override
     *
     * @return {boolean} True of if UI client is running or false otherwise.
     */
    value: function isUIClientRunning() {
      var args, _ref, stdout, count;

      return _regeneratorRuntime.async(function isUIClientRunning$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            args = ['-e', 'tell application "System Events" to count processes whose bundle identifier is "' + this.uiClientBundleId + '"'];
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('osascript', args));

          case 3:
            _ref = context$2$0.sent;
            stdout = _ref.stdout;
            count = parseInt(stdout.trim(), 10);

            if (isNaN(count)) {
              _logger2['default'].errorAndThrow('Cannot parse the count of running Simulator UI client instances from \'osascript ' + args + '\' output: ' + stdout);
            }
            _logger2['default'].debug('The count of running Simulator UI client instances is ' + count);
            return context$2$0.abrupt('return', count >= 1);

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Kill the UI client if it is running.
     *
     * @param {boolean} force - Set it to true to send SIGKILL signal to Simulator process.
     *                          SIGTERM will be sent by default.
     * @return {boolean} True if the UI client was successfully killed or false
     *                   if it is not running.
     */
  }, {
    key: 'killUIClient',
    value: function killUIClient() {
      var force = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      var osascriptArgs, _ref2, stdout, killArgs;

      return _regeneratorRuntime.async(function killUIClient$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            osascriptArgs = ['-e', 'tell application "System Events" to unix id of processes whose bundle identifier is "' + this.uiClientBundleId + '"'];
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('osascript', osascriptArgs));

          case 3:
            _ref2 = context$2$0.sent;
            stdout = _ref2.stdout;

            if (stdout.trim().length) {
              context$2$0.next = 7;
              break;
            }

            return context$2$0.abrupt('return', false);

          case 7:
            killArgs = force ? ['-9', stdout.trim()] : [stdout.trim()];
            context$2$0.next = 10;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('kill', killArgs));

          case 10:
            return context$2$0.abrupt('return', true);

          case 11:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Verify whether the particular application is installed on Simulator.
     * @override
     *
     * @param {string} bundleId - The bundle id of the application to be checked.
     * @return {boolean} True if the given application is installed.
     */
  }, {
    key: 'isAppInstalled',
    value: function isAppInstalled(bundleId) {
      var appContainer, info;
      return _regeneratorRuntime.async(function isAppInstalled$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.prev = 0;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _nodeSimctl.getAppContainer)(this.udid, bundleId, false));

          case 3:
            appContainer = context$2$0.sent;
            return context$2$0.abrupt('return', appContainer.endsWith('.app'));

          case 7:
            context$2$0.prev = 7;
            context$2$0.t0 = context$2$0['catch'](0);
            context$2$0.prev = 9;
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap((0, _nodeSimctl.appInfo)(this.udid, bundleId));

          case 12:
            info = context$2$0.sent;
            return context$2$0.abrupt('return', info.indexOf('ApplicationType') !== -1);

          case 16:
            context$2$0.prev = 16;
            context$2$0.t1 = context$2$0['catch'](9);
            return context$2$0.abrupt('return', false);

          case 19:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[0, 7], [9, 16]]);
    }

    /**
     * @return {string} Application bundle id, which signals that Simulator booting is
     * competed if it is running.
     */
  }, {
    key: 'waitForBoot',

    /**
     * Verify whether the Simulator booting is completed and/or wait for it
     * until the timeout expires.
     * @override
     *
     * @param {number} startupTimeout - the number of milliseconds to wait until booting is completed.
     * @emits BOOT_COMPLETED_EVENT if the current Simulator is ready to accept simctl commands, like 'install'.
     */
    value: function waitForBoot(startupTimeout) {
      var startupTimestamp, lastError;
      return _regeneratorRuntime.async(function waitForBoot$(context$2$0) {
        var _this2 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            startupTimestamp = process.hrtime();
            lastError = null;
            context$2$0.prev = 2;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap((function callee$2$0() {
              var isOnBootCompletedEmitted;
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                var _this = this;

                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    isOnBootCompletedEmitted = false;
                    context$3$0.next = 3;
                    return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$3$0() {
                      var _ref3,
                      // 'springboard' process should be the last one to start after boot
                      // 'simctl launch' will block until this process is running or fail if booting is still in progress
                      stdout;

                      return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                        while (1) switch (context$4$0.prev = context$4$0.next) {
                          case 0:
                            context$4$0.prev = 0;
                            context$4$0.next = 3;
                            return _regeneratorRuntime.awrap((0, _teen_process.exec)('xcrun', ['simctl', 'launch', this.udid, this.startupPollBundleId]));

                          case 3:
                            _ref3 = context$4$0.sent;
                            stdout = _ref3.stdout;

                            if (!PROCESS_LAUNCH_OK_PATTERN(this.startupPollBundleId).test(stdout)) {
                              context$4$0.next = 8;
                              break;
                            }

                            if (!isOnBootCompletedEmitted) {
                              isOnBootCompletedEmitted = true;
                              this.emit(_simulatorXcode6.BOOT_COMPLETED_EVENT);
                            }

                            return context$4$0.abrupt('return', true);

                          case 8:
                            context$4$0.next = 13;
                            break;

                          case 10:
                            context$4$0.prev = 10;
                            context$4$0.t0 = context$4$0['catch'](0);

                            lastError = context$4$0.t0.stderr || context$4$0.t0.message;

                          case 13:
                            return context$4$0.abrupt('return', false);

                          case 14:
                          case 'end':
                            return context$4$0.stop();
                        }
                      }, null, _this, [[0, 10]]);
                    }, { waitMs: startupTimeout, intervalMs: 1500 }));

                  case 3:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this2);
            })());

          case 5:
            context$2$0.next = 10;
            break;

          case 7:
            context$2$0.prev = 7;
            context$2$0.t0 = context$2$0['catch'](2);

            _logger2['default'].errorAndThrow('Simulator is not booted after ' + process.hrtime(startupTimestamp)[0] + ' seconds ' + ('because of: ' + (lastError || 'an unknown error')));

          case 10:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[2, 7]]);
    }

    /**
     * Open the given URL in mobile Safari browser.
     * The browser will be started automatically if it is not running.
     * @override
     *
     * @param {string} url - The URL to be opened.
     */
  }, {
    key: 'openUrl',
    value: function openUrl(url) {
      var launchTimestamp, lastError;
      return _regeneratorRuntime.async(function openUrl$(context$2$0) {
        var _this3 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.isRunning());

          case 2:
            if (context$2$0.sent) {
              context$2$0.next = 4;
              break;
            }

            throw new Error('Tried to open ' + url + ', but Simulator is not in Booted state');

          case 4:
            launchTimestamp = process.hrtime();
            lastError = null;
            context$2$0.prev = 6;
            context$2$0.next = 9;
            return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$2$0() {
              var _ref4,
              // This is to make sure Safari is already running
              stdout;

              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    context$3$0.prev = 0;
                    context$3$0.next = 3;
                    return _regeneratorRuntime.awrap((0, _teen_process.exec)('xcrun', ['simctl', 'launch', this.udid, MOBILE_SAFARI_BUNDLE_ID]));

                  case 3:
                    _ref4 = context$3$0.sent;
                    stdout = _ref4.stdout;

                    if (!PROCESS_LAUNCH_OK_PATTERN(MOBILE_SAFARI_BUNDLE_ID).test(stdout)) {
                      context$3$0.next = 9;
                      break;
                    }

                    context$3$0.next = 8;
                    return _regeneratorRuntime.awrap((0, _nodeSimctl.openUrl)(this.udid, url));

                  case 8:
                    return context$3$0.abrupt('return', true);

                  case 9:
                    context$3$0.next = 15;
                    break;

                  case 11:
                    context$3$0.prev = 11;
                    context$3$0.t0 = context$3$0['catch'](0);

                    _logger2['default'].error('Failed to open \'' + url + '\' in Safari. Retrying...');
                    lastError = context$3$0.t0.stderr || context$3$0.t0.message;

                  case 15:
                    return context$3$0.abrupt('return', false);

                  case 16:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this3, [[0, 11]]);
            }, { waitMs: SAFARI_STARTUP_TIMEOUT, intervalMs: 500 }));

          case 9:
            context$2$0.next = 14;
            break;

          case 11:
            context$2$0.prev = 11;
            context$2$0.t0 = context$2$0['catch'](6);

            _logger2['default'].errorAndThrow('Safari cannot open \'' + url + '\' after ' + process.hrtime(launchTimestamp)[0] + ' seconds ' + ('because of: ' + (lastError || 'an unknown error')));

          case 14:
            _logger2['default'].debug('Safari has successfully opened \'' + url + '\' in ' + process.hrtime(launchTimestamp)[0] + ' seconds');

          case 15:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[6, 11]]);
    }

    /**
     * Clean up the directories for mobile Safari.
     * @override
     *
     * @param {boolean} keepPrefs - Whether to keep Safari preferences from being deleted.
     */
  }, {
    key: 'cleanSafari',
    value: function cleanSafari() {
      var keepPrefs = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
      return _regeneratorRuntime.async(function cleanSafari$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.prev = 0;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _nodeSimctl.terminate)(this.udid, MOBILE_SAFARI_BUNDLE_ID));

          case 3:
            context$2$0.next = 7;
            break;

          case 5:
            context$2$0.prev = 5;
            context$2$0.t0 = context$2$0['catch'](0);

          case 7:
            context$2$0.next = 9;
            return _regeneratorRuntime.awrap(_get(Object.getPrototypeOf(SimulatorXcode8.prototype), 'cleanSafari', this).call(this, keepPrefs));

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[0, 5]]);
    }

    /**
     * Clean/scrub the particular application on Simulator.
     * @override
     *
     * @param {string} appFile - Application name minus ".app".
     * @param {string} appBundleId - Bundle identifier of the application.
     * @param {boolean} scrub - If `scrub` is false, we want to clean by deleting the app and all
     *   files associated with it. If `scrub` is true, we just want to delete the preferences and
     *   changed files.
     */
  }, {
    key: 'cleanCustomApp',
    value: function cleanCustomApp(appFile, appBundleId) {
      var scrub = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
      return _regeneratorRuntime.async(function cleanCustomApp$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.prev = 0;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _nodeSimctl.terminate)(this.udid, appBundleId));

          case 3:
            context$2$0.next = 7;
            break;

          case 5:
            context$2$0.prev = 5;
            context$2$0.t0 = context$2$0['catch'](0);

          case 7:
            context$2$0.next = 9;
            return _regeneratorRuntime.awrap(_get(Object.getPrototypeOf(SimulatorXcode8.prototype), 'cleanCustomApp', this).call(this, appFile, appBundleId, scrub));

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[0, 5]]);
    }

    /**
     * Perform Shake gesture on Simulator window via AppleScript.
     */
  }, {
    key: 'shake',
    value: function shake() {
      return _regeneratorRuntime.async(function shake$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.executeUIClientScript('\n      tell application "System Events"\n        tell process "Simulator"\n          keystroke "z" using {control down, command down}\n        end tell\n      end tell\n    '));

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Set custom geolocation parameters for the given Simulator using AppleScript.
     *
     * @param {string} latitude - The latitude value, which is going to be entered
     *   into the corresponding edit field, for example '39,0006'.
     * @param {string} longitude - The longitude value, which is going to be entered
     *   into the corresponding edit field, for example '19,0068'.
     * @returns {boolean} True if the given parameters have correct format and were successfully accepted.
     */
  }, {
    key: 'setGeolocation',
    value: function setGeolocation(latitude, longitude) {
      var output;
      return _regeneratorRuntime.async(function setGeolocation$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.executeUIClientScript('\n      tell application "System Events"\n        tell process "Simulator"\n          set featureName to "Custom Location"\n          set dstMenuItem to menu item (featureName & "…") of menu 1 of menu item "Location" of menu 1 of menu bar item "Debug" of menu bar 1\n          click dstMenuItem\n          delay 1\n          set value of text field 1 of window featureName to "' + latitude + '"\n          delay 0.5\n          set value of text field 2 of window featureName to "' + longitude + '"\n          delay 0.5\n          click button "OK" of window featureName\n          delay 0.5\n          set isInvisible to (not (exists (window featureName)))\n        end tell\n      end tell\n    '));

          case 2:
            output = context$2$0.sent;

            _logger2['default'].debug('Geolocation parameters dialog accepted: ' + output);
            return context$2$0.abrupt('return', _lodash2['default'].isString(output) && output.trim() === 'true');

          case 5:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'uiClientBundleId',
    get: function get() {
      return UI_CLIENT_BUNDLE_ID;
    }
  }, {
    key: 'startupPollBundleId',
    get: function get() {
      return SPRINGBOARD_BUNDLE_ID;
    }

    /**
     * @return {number} The max number of milliseconds to wait until Simulator booting is completed.
     */
  }, {
    key: 'startupTimeout',
    get: function get() {
      return STARTUP_TIMEOUT;
    }
  }]);

  return SimulatorXcode8;
})(_simulatorXcode72['default']);

exports['default'] = SimulatorXcode8;
module.exports = exports['default'];

// get_app_container subcommand fails for system applications,
// so we try the hidden appinfo subcommand, which prints correct info for
// system/hidden apps

// ignore error

// ignore error
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9zaW11bGF0b3IteGNvZGUtOC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBQXFDLHFCQUFxQjs7K0JBQzlCLHFCQUFxQjs7OztzQkFDbkMsUUFBUTs7OztzQkFDTixVQUFVOzs7O3dCQUNPLFVBQVU7OzRCQUN0QixjQUFjOzswQkFDMkMsYUFBYTs7O0FBSTNGLElBQU0sZUFBZSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7QUFDbkMsSUFBTSxzQkFBc0IsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO0FBQ3pDLElBQU0scUJBQXFCLEdBQUcsdUJBQXVCLENBQUM7QUFDdEQsSUFBTSx1QkFBdUIsR0FBRyx3QkFBd0IsQ0FBQztBQUN6RCxJQUFNLG1CQUFtQixHQUFHLDJCQUEyQixDQUFDO0FBQ3hELElBQU0seUJBQXlCLEdBQUcsU0FBNUIseUJBQXlCLENBQUksUUFBUTtTQUFLLElBQUksTUFBTSxDQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxlQUFZO0NBQUEsQ0FBQzs7SUFFakcsZUFBZTtZQUFmLGVBQWU7O0FBQ1AsV0FEUixlQUFlLENBQ04sSUFBSSxFQUFFLFlBQVksRUFBRTswQkFEN0IsZUFBZTs7QUFFakIsK0JBRkUsZUFBZSw2Q0FFWCxJQUFJLEVBQUUsWUFBWSxFQUFFOzs7OztBQUsxQixRQUFJLENBQUMsWUFBWSxHQUFHLENBQ2xCLGlCQUFpQixFQUNqQiw4Q0FBOEMsRUFDOUMsaURBQWlELEVBQ2pELG9CQUFvQixDQUNyQixDQUFDO0dBQ0g7Ozs7OztlQWJHLGVBQWU7Ozs7Ozs7OztXQTRCSztVQUNoQixJQUFJLFFBQ0gsTUFBTSxFQUNQLEtBQUs7Ozs7O0FBRkwsZ0JBQUksR0FBRyxDQUFDLElBQUksdUZBQXFGLElBQUksQ0FBQyxnQkFBZ0IsT0FBSTs7NkNBQ3pHLHdCQUFLLFdBQVcsRUFBRSxJQUFJLENBQUM7Ozs7QUFBdkMsa0JBQU0sUUFBTixNQUFNO0FB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OztLQUNsQzs7Ozs7Ozs7Ozs7Ozs7V0FZb0Isd0JBQUMsT0FBTyxFQUFFLFdBQVc7VUFBRSxLQUFLLHlEQUFHLEtBQUs7Ozs7Ozs2Q0FFL0MsMkJBQVUsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUM7Ozs7Ozs7Ozs7Ozt3RUFwTXZDLGVBQWUsZ0RBd01VLE9BQU8sRUFBRSxXQUFXLEVBQUUsS0FBSzs7Ozs7OztLQUN2RDs7Ozs7OztXQUtXOzs7Ozs2Q0FDSixJQUFJLENBQUMscUJBQXFCLGtMQU05Qjs7Ozs7OztLQUNIOzs7Ozs7Ozs7Ozs7O1dBV29CLHdCQUFDLFFBQVEsRUFBRSxTQUFTO1VBQ2pDLE1BQU07Ozs7OzZDQUFTLElBQUksQ0FBQyxxQkFBcUIsK1hBT2EsUUFBUSw4RkFFUixTQUFTLDhNQU9uRTs7O0FBaEJJLGtCQUFNOztBQWlCWixnQ0FBSSxLQUFLLDhDQUE0QyxNQUFNLENBQUcsQ0FBQztnREFDeEQsb0JBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUUsS0FBSyxNQUFNOzs7Ozs7O0tBQ3REOzs7U0FuT29CLGVBQUc7QUFDdEIsYUFBTyxtQkFBbUIsQ0FBQztLQUM1Qjs7O1NBa0V1QixlQUFHO0FBQ3pCLGFBQU8scUJBQXFCLENBQUM7S0FDOUI7Ozs7Ozs7U0FLa0IsZUFBRztBQUNwQixhQUFPLGVBQWUsQ0FBQztLQUN4Qjs7O1NBL0ZHLGVBQWU7OztxQkF3UE4sZUFBZSIsImZpbGUiOiJsaWIvc2ltdWxhdG9yLXhjb2RlLTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCT09UX0NPTVBMRVRFRF9FVkVOVCB9IGZyb20gJy4vc2ltdWxhdG9yLXhjb2RlLTYnO1xuaW1wb3J0IFNpbXVsYXRvclhjb2RlNyBmcm9tICcuL3NpbXVsYXRvci14Y29kZS03JztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IGdldEFwcENvbnRhaW5lciwgb3BlblVybCBhcyBzaW1jdGxPcGVuVXJsLCB0ZXJtaW5hdGUsIGFwcEluZm8gfSBmcm9tICdub2RlLXNpbWN0bCc7XG5cblxuLy8gdGhlc2Ugc2ltcyBhcmUgc2xvb29vb29vb3dcbmNvbnN0IFNUQVJUVVBfVElNRU9VVCA9IDEyMCAqIDEwMDA7XG5jb25zdCBTQUZBUklfU1RBUlRVUF9USU1FT1VUID0gMjUgKiAxMDAwO1xuY29uc3QgU1BSSU5HQk9BUkRfQlVORExFX0lEID0gJ2NvbS5hcHBsZS5zcHJpbmdib2FyZCc7XG5jb25zdCBNT0JJTEVfU0FGQVJJX0JVTkRMRV9JRCA9ICdjb20uYXBwbGUubW9iaWxlc2FmYXJpJztcbmNvbnN0IFVJX0NMSUVOVF9CVU5ETEVfSUQgPSAnY29tLmFwcGxlLmlwaG9uZXNpbXVsYXRvcic7XG5jb25zdCBQUk9DRVNTX0xBVU5DSF9PS19QQVRURVJOID0gKGJ1bmRsZUlkKSA9PiBuZXcgUmVnRXhwKGAke2J1bmRsZUlkLnJlcGxhY2UoJy4nLCAnXFxcXC4nKX06XFxcXHMrXFxcXGQrYCk7XG5cbmNsYXNzIFNpbXVsYXRvclhjb2RlOCBleHRlbmRzIFNpbXVsYXRvclhjb2RlNyB7XG4gIGNvbnN0cnVjdG9yICh1ZGlkLCB4Y29kZVZlcnNpb24pIHtcbiAgICBzdXBlcih1ZGlkLCB4Y29kZVZlcnNpb24pO1xuXG4gICAgLy8gbGlzdCBvZiBmaWxlcyB0byBjaGVjayBmb3Igd2hlbiBzZWVpbmcgaWYgYSBzaW11bGF0b3IgaXMgXCJmcmVzaFwiXG4gICAgLy8gKG1lYW5pbmcgaXQgaGFzIG5ldmVyIGJlZW4gYm9vdGVkKS5cbiAgICAvLyBJZiB0aGVzZSBmaWxlcyBhcmUgcHJlc2VudCwgd2UgYXNzdW1lIGl0J3MgYmVlbiBzdWNjZXNzZnVsbHkgYm9vdGVkXG4gICAgdGhpcy5pc0ZyZXNoRmlsZXMgPSBbXG4gICAgICAnTGlicmFyeS9Db29raWVzJyxcbiAgICAgICdMaWJyYXJ5L1ByZWZlcmVuY2VzLy5HbG9iYWxQcmVmZXJlbmNlcy5wbGlzdCcsXG4gICAgICAnTGlicmFyeS9QcmVmZXJlbmNlcy9jb20uYXBwbGUuc3ByaW5nYm9hcmQucGxpc3QnLFxuICAgICAgJ3Zhci9ydW4vc3lzbG9nLnBpZCdcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQnVuZGxlIGlkZW50aWZpZXIgb2YgU2ltdWxhdG9yIFVJIGNsaWVudC5cbiAgICovXG4gIGdldCB1aUNsaWVudEJ1bmRsZUlkICgpIHtcbiAgICByZXR1cm4gVUlfQ0xJRU5UX0JVTkRMRV9JRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgc3RhdGUgb2YgU2ltdWxhdG9yIFVJIGNsaWVudC5cbiAgICogQE92ZXJyaWRlXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgb2YgaWYgVUkgY2xpZW50IGlzIHJ1bm5pbmcgb3IgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgYXN5bmMgaXNVSUNsaWVudFJ1bm5pbmcgKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbJy1lJywgYHRlbGwgYXBwbGljYXRpb24gXCJTeXN0ZW0gRXZlbnRzXCIgdG8gY291bnQgcHJvY2Vzc2VzIHdob3NlIGJ1bmRsZSBpZGVudGlmaWVyIGlzIFwiJHt0aGlzLnVpQ2xpZW50QnVuZGxlSWR9XCJgXTtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ29zYXNjcmlwdCcsIGFyZ3MpO1xuICAgIGNvbnN0IGNvdW50ID0gcGFyc2VJbnQoc3Rkb3V0LnRyaW0oKSwgMTApO1xuICAgIGlmIChpc05hTihjb3VudCkpIHtcbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGBDYW5ub3QgcGFyc2UgdGhlIGNvdW50IG9mIHJ1bm5pbmcgU2ltdWxhdG9yIFVJIGNsaWVudCBpbnN0YW5jZXMgZnJvbSAnb3Nhc2NyaXB0ICR7YXJnc30nIG91dHB1dDogJHtzdGRvdXR9YCk7XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgVGhlIGNvdW50IG9mIHJ1bm5pbmcgU2ltdWxhdG9yIFVJIGNsaWVudCBpbnN0YW5jZXMgaXMgJHtjb3VudH1gKTtcbiAgICByZXR1cm4gY291bnQgPj0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBLaWxsIHRoZSBVSSBjbGllbnQgaWYgaXQgaXMgcnVubmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIFNldCBpdCB0byB0cnVlIHRvIHNlbmQgU0lHS0lMTCBzaWduYWwgdG8gU2ltdWxhdG9yIHByb2Nlc3MuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBTSUdURVJNIHdpbGwgYmUgc2VudCBieSBkZWZhdWx0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBVSSBjbGllbnQgd2FzIHN1Y2Nlc3NmdWxseSBraWxsZWQgb3IgZmFsc2VcbiAgICogICAgICAgICAgICAgICAgICAgaWYgaXQgaXMgbm90IHJ1bm5pbmcuXG4gICAqL1xuICBhc3luYyBraWxsVUlDbGllbnQgKGZvcmNlID0gZmFsc2UpIHtcbiAgICBjb25zdCBvc2FzY3JpcHRBcmdzID0gWyctZScsIGB0ZWxsIGFwcGxpY2F0aW9uIFwiU3lzdGVtIEV2ZW50c1wiIHRvIHVuaXggaWQgb2YgcHJvY2Vzc2VzIHdob3NlIGJ1bmRsZSBpZGVudGlmaWVyIGlzIFwiJHt0aGlzLnVpQ2xpZW50QnVuZGxlSWR9XCJgXTtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ29zYXNjcmlwdCcsIG9zYXNjcmlwdEFyZ3MpO1xuICAgIGlmICghc3Rkb3V0LnRyaW0oKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qga2lsbEFyZ3MgPSBmb3JjZSA/IFsnLTknLCBzdGRvdXQudHJpbSgpXSA6IFtzdGRvdXQudHJpbSgpXTtcbiAgICBhd2FpdCBleGVjKCdraWxsJywga2lsbEFyZ3MpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB3aGV0aGVyIHRoZSBwYXJ0aWN1bGFyIGFwcGxpY2F0aW9uIGlzIGluc3RhbGxlZCBvbiBTaW11bGF0b3IuXG4gICAqIEBvdmVycmlkZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYnVuZGxlSWQgLSBUaGUgYnVuZGxlIGlkIG9mIHRoZSBhcHBsaWNhdGlvbiB0byBiZSBjaGVja2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnaXZlbiBhcHBsaWNhdGlvbiBpcyBpbnN0YWxsZWQuXG4gICAqL1xuICBhc3luYyBpc0FwcEluc3RhbGxlZCAoYnVuZGxlSWQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXBwQ29udGFpbmVyID0gYXdhaXQgZ2V0QXBwQ29udGFpbmVyKHRoaXMudWRpZCwgYnVuZGxlSWQsIGZhbHNlKTtcbiAgICAgIHJldHVybiBhcHBDb250YWluZXIuZW5kc1dpdGgoJy5hcHAnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGdldF9hcHBfY29udGFpbmVyIHN1YmNvbW1hbmQgZmFpbHMgZm9yIHN5c3RlbSBhcHBsaWNhdGlvbnMsXG4gICAgICAvLyBzbyB3ZSB0cnkgdGhlIGhpZGRlbiBhcHBpbmZvIHN1YmNvbW1hbmQsIHdoaWNoIHByaW50cyBjb3JyZWN0IGluZm8gZm9yXG4gICAgICAvLyBzeXN0ZW0vaGlkZGVuIGFwcHNcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCBhcHBJbmZvKHRoaXMudWRpZCwgYnVuZGxlSWQpO1xuICAgICAgICByZXR1cm4gaW5mby5pbmRleE9mKCdBcHBsaWNhdGlvblR5cGUnKSAhPT0gLTE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBBcHBsaWNhdGlvbiBidW5kbGUgaWQsIHdoaWNoIHNpZ25hbHMgdGhhdCBTaW11bGF0b3IgYm9vdGluZyBpc1xuICAgKiBjb21wZXRlZCBpZiBpdCBpcyBydW5uaW5nLlxuICAgKi9cbiAgZ2V0IHN0YXJ0dXBQb2xsQnVuZGxlSWQgKCkge1xuICAgIHJldHVybiBTUFJJTkdCT0FSRF9CVU5ETEVfSUQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWF4IG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCB1bnRpbCBTaW11bGF0b3IgYm9vdGluZyBpcyBjb21wbGV0ZWQuXG4gICAqL1xuICBnZXQgc3RhcnR1cFRpbWVvdXQgKCkge1xuICAgIHJldHVybiBTVEFSVFVQX1RJTUVPVVQ7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHdoZXRoZXIgdGhlIFNpbXVsYXRvciBib290aW5nIGlzIGNvbXBsZXRlZCBhbmQvb3Igd2FpdCBmb3IgaXRcbiAgICogdW50aWwgdGhlIHRpbWVvdXQgZXhwaXJlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydHVwVGltZW91dCAtIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgdW50aWwgYm9vdGluZyBpcyBjb21wbGV0ZWQuXG4gICAqIEBlbWl0cyBCT09UX0NPTVBMRVRFRF9FVkVOVCBpZiB0aGUgY3VycmVudCBTaW11bGF0b3IgaXMgcmVhZHkgdG8gYWNjZXB0IHNpbWN0bCBjb21tYW5kcywgbGlrZSAnaW5zdGFsbCcuXG4gICAqL1xuICBhc3luYyB3YWl0Rm9yQm9vdCAoc3RhcnR1cFRpbWVvdXQpIHtcbiAgICBjb25zdCBzdGFydHVwVGltZXN0YW1wID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICBsZXQgbGFzdEVycm9yID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgbGV0IGlzT25Cb290Q29tcGxldGVkRW1pdHRlZCA9IGZhbHNlO1xuICAgICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gJ3NwcmluZ2JvYXJkJyBwcm9jZXNzIHNob3VsZCBiZSB0aGUgbGFzdCBvbmUgdG8gc3RhcnQgYWZ0ZXIgYm9vdFxuICAgICAgICAgIC8vICdzaW1jdGwgbGF1bmNoJyB3aWxsIGJsb2NrIHVudGlsIHRoaXMgcHJvY2VzcyBpcyBydW5uaW5nIG9yIGZhaWwgaWYgYm9vdGluZyBpcyBzdGlsbCBpbiBwcm9ncmVzc1xuICAgICAgICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygneGNydW4nLCBbJ3NpbWN0bCcsICdsYXVuY2gnLCB0aGlzLnVkaWQsIHRoaXMuc3RhcnR1cFBvbGxCdW5kbGVJZF0pO1xuICAgICAgICAgIGlmIChQUk9DRVNTX0xBVU5DSF9PS19QQVRURVJOKHRoaXMuc3RhcnR1cFBvbGxCdW5kbGVJZCkudGVzdChzdGRvdXQpKSB7XG4gICAgICAgICAgICBpZiAoIWlzT25Cb290Q29tcGxldGVkRW1pdHRlZCkge1xuICAgICAgICAgICAgICBpc09uQm9vdENvbXBsZXRlZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoQk9PVF9DT01QTEVURURfRVZFTlQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxhc3RFcnJvciA9IGVyci5zdGRlcnIgfHwgZXJyLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSwge3dhaXRNczogc3RhcnR1cFRpbWVvdXQsIGludGVydmFsTXM6IDE1MDB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGBTaW11bGF0b3IgaXMgbm90IGJvb3RlZCBhZnRlciAke3Byb2Nlc3MuaHJ0aW1lKHN0YXJ0dXBUaW1lc3RhbXApWzBdfSBzZWNvbmRzIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2Ugb2Y6ICR7bGFzdEVycm9yIHx8ICdhbiB1bmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3BlbiB0aGUgZ2l2ZW4gVVJMIGluIG1vYmlsZSBTYWZhcmkgYnJvd3Nlci5cbiAgICogVGhlIGJyb3dzZXIgd2lsbCBiZSBzdGFydGVkIGF1dG9tYXRpY2FsbHkgaWYgaXQgaXMgbm90IHJ1bm5pbmcuXG4gICAqIEBvdmVycmlkZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIFVSTCB0byBiZSBvcGVuZWQuXG4gICAqL1xuICBhc3luYyBvcGVuVXJsICh1cmwpIHtcbiAgICBpZiAoIWF3YWl0IHRoaXMuaXNSdW5uaW5nKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJpZWQgdG8gb3BlbiAke3VybH0sIGJ1dCBTaW11bGF0b3IgaXMgbm90IGluIEJvb3RlZCBzdGF0ZWApO1xuICAgIH1cbiAgICBjb25zdCBsYXVuY2hUaW1lc3RhbXAgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgIGxldCBsYXN0RXJyb3IgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHRvIG1ha2Ugc3VyZSBTYWZhcmkgaXMgYWxyZWFkeSBydW5uaW5nXG4gICAgICAgICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKCd4Y3J1bicsIFsnc2ltY3RsJywgJ2xhdW5jaCcsIHRoaXMudWRpZCwgTU9CSUxFX1NBRkFSSV9CVU5ETEVfSURdKTtcbiAgICAgICAgICBpZiAoUFJPQ0VTU19MQVVOQ0hfT0tfUEFUVEVSTihNT0JJTEVfU0FGQVJJX0JVTkRMRV9JRCkudGVzdChzdGRvdXQpKSB7XG4gICAgICAgICAgICBhd2FpdCBzaW1jdGxPcGVuVXJsKHRoaXMudWRpZCwgdXJsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nLmVycm9yKGBGYWlsZWQgdG8gb3BlbiAnJHt1cmx9JyBpbiBTYWZhcmkuIFJldHJ5aW5nLi4uYCk7XG4gICAgICAgICAgbGFzdEVycm9yID0gZXJyLnN0ZGVyciB8fCBlcnIubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LCB7d2FpdE1zOiBTQUZBUklfU1RBUlRVUF9USU1FT1VULCBpbnRlcnZhbE1zOiA1MDB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGBTYWZhcmkgY2Fubm90IG9wZW4gJyR7dXJsfScgYWZ0ZXIgJHtwcm9jZXNzLmhydGltZShsYXVuY2hUaW1lc3RhbXApWzBdfSBzZWNvbmRzIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2Ugb2Y6ICR7bGFzdEVycm9yIHx8ICdhbiB1bmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gICAgbG9nLmRlYnVnKGBTYWZhcmkgaGFzIHN1Y2Nlc3NmdWxseSBvcGVuZWQgJyR7dXJsfScgaW4gJHtwcm9jZXNzLmhydGltZShsYXVuY2hUaW1lc3RhbXApWzBdfSBzZWNvbmRzYCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgdGhlIGRpcmVjdG9yaWVzIGZvciBtb2JpbGUgU2FmYXJpLlxuICAgKiBAb3ZlcnJpZGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBrZWVwUHJlZnMgLSBXaGV0aGVyIHRvIGtlZXAgU2FmYXJpIHByZWZlcmVuY2VzIGZyb20gYmVpbmcgZGVsZXRlZC5cbiAgICovXG4gIGFzeW5jIGNsZWFuU2FmYXJpIChrZWVwUHJlZnMgPSB0cnVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRlcm1pbmF0ZSh0aGlzLnVkaWQsIE1PQklMRV9TQUZBUklfQlVORExFX0lEKTtcbiAgICB9IGNhdGNoIChpZ24pIHtcbiAgICAgIC8vIGlnbm9yZSBlcnJvclxuICAgIH1cbiAgICBhd2FpdCBzdXBlci5jbGVhblNhZmFyaShrZWVwUHJlZnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuL3NjcnViIHRoZSBwYXJ0aWN1bGFyIGFwcGxpY2F0aW9uIG9uIFNpbXVsYXRvci5cbiAgICogQG92ZXJyaWRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBGaWxlIC0gQXBwbGljYXRpb24gbmFtZSBtaW51cyBcIi5hcHBcIi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFwcEJ1bmRsZUlkIC0gQnVuZGxlIGlkZW50aWZpZXIgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNjcnViIC0gSWYgYHNjcnViYCBpcyBmYWxzZSwgd2Ugd2FudCB0byBjbGVhbiBieSBkZWxldGluZyB0aGUgYXBwIGFuZCBhbGxcbiAgICogICBmaWxlcyBhc3NvY2lhdGVkIHdpdGggaXQuIElmIGBzY3J1YmAgaXMgdHJ1ZSwgd2UganVzdCB3YW50IHRvIGRlbGV0ZSB0aGUgcHJlZmVyZW5jZXMgYW5kXG4gICAqICAgY2hhbmdlZCBmaWxlcy5cbiAgICovXG4gIGFzeW5jIGNsZWFuQ3VzdG9tQXBwIChhcHBGaWxlLCBhcHBCdW5kbGVJZCwgc2NydWIgPSBmYWxzZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0ZXJtaW5hdGUodGhpcy51ZGlkLCBhcHBCdW5kbGVJZCk7XG4gICAgfSBjYXRjaCAoaWduKSB7XG4gICAgICAvLyBpZ25vcmUgZXJyb3JcbiAgICB9XG4gICAgYXdhaXQgc3VwZXIuY2xlYW5DdXN0b21BcHAoYXBwRmlsZSwgYXBwQnVuZGxlSWQsIHNjcnViKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIFNoYWtlIGdlc3R1cmUgb24gU2ltdWxhdG9yIHdpbmRvdyB2aWEgQXBwbGVTY3JpcHQuXG4gICAqL1xuICBhc3luYyBzaGFrZSAoKSB7XG4gICAgYXdhaXQgdGhpcy5leGVjdXRlVUlDbGllbnRTY3JpcHQoYFxuICAgICAgdGVsbCBhcHBsaWNhdGlvbiBcIlN5c3RlbSBFdmVudHNcIlxuICAgICAgICB0ZWxsIHByb2Nlc3MgXCJTaW11bGF0b3JcIlxuICAgICAgICAgIGtleXN0cm9rZSBcInpcIiB1c2luZyB7Y29udHJvbCBkb3duLCBjb21tYW5kIGRvd259XG4gICAgICAgIGVuZCB0ZWxsXG4gICAgICBlbmQgdGVsbFxuICAgIGApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjdXN0b20gZ2VvbG9jYXRpb24gcGFyYW1ldGVycyBmb3IgdGhlIGdpdmVuIFNpbXVsYXRvciB1c2luZyBBcHBsZVNjcmlwdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhdGl0dWRlIC0gVGhlIGxhdGl0dWRlIHZhbHVlLCB3aGljaCBpcyBnb2luZyB0byBiZSBlbnRlcmVkXG4gICAqICAgaW50byB0aGUgY29ycmVzcG9uZGluZyBlZGl0IGZpZWxkLCBmb3IgZXhhbXBsZSAnMzksMDAwNicuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb25naXR1ZGUgLSBUaGUgbG9uZ2l0dWRlIHZhbHVlLCB3aGljaCBpcyBnb2luZyB0byBiZSBlbnRlcmVkXG4gICAqICAgaW50byB0aGUgY29ycmVzcG9uZGluZyBlZGl0IGZpZWxkLCBmb3IgZXhhbXBsZSAnMTksMDA2OCcuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXJzIGhhdmUgY29ycmVjdCBmb3JtYXQgYW5kIHdlcmUgc3VjY2Vzc2Z1bGx5IGFjY2VwdGVkLlxuICAgKi9cbiAgYXN5bmMgc2V0R2VvbG9jYXRpb24gKGxhdGl0dWRlLCBsb25naXR1ZGUpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVVSUNsaWVudFNjcmlwdChgXG4gICAgICB0ZWxsIGFwcGxpY2F0aW9uIFwiU3lzdGVtIEV2ZW50c1wiXG4gICAgICAgIHRlbGwgcHJvY2VzcyBcIlNpbXVsYXRvclwiXG4gICAgICAgICAgc2V0IGZlYXR1cmVOYW1lIHRvIFwiQ3VzdG9tIExvY2F0aW9uXCJcbiAgICAgICAgICBzZXQgZHN0TWVudUl0ZW0gdG8gbWVudSBpdGVtIChmZWF0dXJlTmFtZSAmIFwi4oCmXCIpIG9mIG1lbnUgMSBvZiBtZW51IGl0ZW0gXCJMb2NhdGlvblwiIG9mIG1lbnUgMSBvZiBtZW51IGJhciBpdGVtIFwiRGVidWdcIiBvZiBtZW51IGJhciAxXG4gICAgICAgICAgY2xpY2sgZHN0TWVudUl0ZW1cbiAgICAgICAgICBkZWxheSAxXG4gICAgICAgICAgc2V0IHZhbHVlIG9mIHRleHQgZmllbGQgMSBvZiB3aW5kb3cgZmVhdHVyZU5hbWUgdG8gXCIke2xhdGl0dWRlfVwiXG4gICAgICAgICAgZGVsYXkgMC41XG4gICAgICAgICAgc2V0IHZhbHVlIG9mIHRleHQgZmllbGQgMiBvZiB3aW5kb3cgZmVhdHVyZU5hbWUgdG8gXCIke2xvbmdpdHVkZX1cIlxuICAgICAgICAgIGRlbGF5IDAuNVxuICAgICAgICAgIGNsaWNrIGJ1dHRvbiBcIk9LXCIgb2Ygd2luZG93IGZlYXR1cmVOYW1lXG4gICAgICAgICAgZGVsYXkgMC41XG4gICAgICAgICAgc2V0IGlzSW52aXNpYmxlIHRvIChub3QgKGV4aXN0cyAod2luZG93IGZlYXR1cmVOYW1lKSkpXG4gICAgICAgIGVuZCB0ZWxsXG4gICAgICBlbmQgdGVsbFxuICAgIGApO1xuICAgIGxvZy5kZWJ1ZyhgR2VvbG9jYXRpb24gcGFyYW1ldGVycyBkaWFsb2cgYWNjZXB0ZWQ6ICR7b3V0cHV0fWApO1xuICAgIHJldHVybiBfLmlzU3RyaW5nKG91dHB1dCkgJiYgb3V0cHV0LnRyaW0oKSA9PT0gJ3RydWUnO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNpbXVsYXRvclhjb2RlODtcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
