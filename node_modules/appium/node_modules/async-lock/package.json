{
  "name": "async-lock",
  "description": "Lock on asynchronous code",
  "version": "1.1.0",
  "author": {
    "name": "Rogier Schouten",
    "email": "github@workingcode.ninja",
    "url": "https://github.com/rogierschouten/"
  },
  "private": false,
  "homepage": "https://github.com/rogierschouten/async-lock",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rogierschouten/async-lock.git"
  },
  "bugs": {
    "url": "https://github.com/rogierschouten/async-lock/issues"
  },
  "license": "MIT",
  "keywords": [
    "lock",
    "async",
    "concurrency",
    "critical",
    "section",
    "mutex"
  ],
  "engines": {},
  "scripts": {
    "start": "grunt",
    "test": "grunt test",
    "postinstall": ""
  },
  "devDependencies": {
    "bluebird": "~3.5.0",
    "grunt": "^1.0.1",
    "grunt-cli": "~1.2.0",
    "grunt-contrib-clean": "~1.1.0",
    "grunt-contrib-jshint": "~1.1.0",
    "grunt-contrib-watch": "~1.0.0",
    "grunt-env": "~0.4.4",
    "grunt-mocha-test": "~0.13.2",
    "load-grunt-tasks": "~3.5.2",
    "lodash": "~4.17.2",
    "mocha": "^3.2.0",
    "q": "~1.5.0",
    "should": "~11.2.1"
  },
  "contributors": [
    {
      "name": "rain1017",
      "url": "https://github.com/rain1017"
    },
    {
      "name": "JonathanPicques",
      "url": "https://github.com/JonathanPicques"
    },
    {
      "name": "Rogier Schouten",
      "url": "https://github.com/rogierschouten"
    },
    {
      "name": "erikvold",
      "url": "https://github.com/erikvold"
    }
  ],
  "readme": "# async-lock\n\nLock on asynchronous code\n\n[![Build Status](https://travis-ci.org/rogierschouten/async-lock.svg?branch=master)](https://travis-ci.org/rogierschouten/async-lock)\n\n* ES6 promise supported\n* Multiple keys lock supported\n* Timeout supported\n* Pending task limit supported\n* Domain reentrant supported\n* 100% code coverage\n\n## Why you need locking on single threaded nodejs?\n\nNodejs is single threaded, and the code execution is never get interrupted inside an event loop, so locking is unnecessary? This is true ONLY IF your critical section can be executed inside a single event loop.\nHowever, if you have any async code inside your critical section (it can be simply triggered by any I/O operation, or timer), your critical logic will across multiple event loops, therefore it's not concurrency safe!\n\nConsider the following code\n```js\nredis.get('key', function(err, value){\n\tredis.set('key', value * 2);\n});\n```\nThe above code simply multiply a redis key by 2.\nHowever, if two users run concurrency, the execution order may like this\n```\nuser1: redis.get('key') -> 1\nuser2: redis.get('key') -> 1\nuser1: redis.set('key', 1 x 2) -> 2\nuser2: redis.set('key', 1 x 2) -> 2\n```\nObviously it's not what you expected\n\n\nWith asyncLock, you can easily write your async critical section\n```js\nlock.acquire('key', function(cb){\n\t// Concurrency safe\n\tredis.get('key', function(err, value){\n\t\tredis.set('key', value * 2, cb);\n\t});\n}, function(err, ret){\n});\n```\n\n## Get Started\n\n```\nvar AsyncLock = require('async-lock');\nvar lock = new AsyncLock();\n\n/**\n * @param {String|Array} key \tresource key or keys to lock\n * @param {function} fn \texecute function\n * @param {function} cb \t(optional) callback function, otherwise will return a promise\n * @param {Object} opts \t(optional) options\n */\nlock.acquire(key, function(done){\n\t// async work\n\tdone(err, ret);\n}, function(err, ret){\n\t// lock released\n}, opts);\n\n// Promise mode\nlock.acquire(key, function(){\n\t// return value or promise\n}, opts).then(function(){\n\t// lock released\n});\n```\n\n## Error Handling\n\n```\n// Callback mode\nlock.acquire(key, function(done){\n\tdone(new Error('error'));\n}, function(err, ret){\n\tconsole.log(err.message) // output: error\n});\n\n// Promise mode\nlock.acquire(key, function(){\n\tthrow new Error('error');\n}).catch(function(err){\n\tconsole.log(err.message) // output: error\n});\n```\n\n## Acquire multiple keys\n\n```\nlock.acquire([key1, key2], fn, cb);\n```\n\n## Domain reentrant lock\n\nLock is reentrant in the same domain\n\n```\nvar domain = require('domain');\nvar lock = new AsyncLock({domainReentrant : true});\n\nvar d = domain.create();\nd.run(function(){\n\tlock.acquire('key', function(){\n\t\t//Enter lock\n\t\treturn lock.acquire('key', function(){\n\t\t\t//Enter same lock twice\n\t\t});\n\t});\n});\n```\n\n## Options\n\n```\n// Specify timeout\nvar lock = new AsyncLock({timeout : 5000});\nlock.acquire(key, fn, function(err, ret){\n\t// timed out error will be returned here if lock not acquired in given time\n});\n\n// Set max pending tasks\nvar lock = new AsyncLock({maxPending : 1000});\nlock.acquire(key, fn, function(err, ret){\n\t// Handle too much pending error\n})\n\n// Whether there is any running or pending async function\nlock.isBusy();\n\n// Use your own promise library instead of the global Promise variable\nvar lock = new AsyncLock({Promise : require('bluebird')}); // Bluebird\nvar lock = new AsyncLock({Promise : require('q')}); // Q\n\n// Add a task to the front of the queue waiting for a given lock\nlock.acquire(key, fn1, cb); // runs immediately\nlock.acquire(key, fn2, cb); // added to queue\nlock.acquire(key, priorityFn, cb, {skipQueue: true}); // jumps queue and runs before fn2\n```\n\n## Changelog\n\nSee [Changelog](./History.md)\n\n## Issues\n\nSee [isse tracker](https://github.com/rogierschouten/async-lock/issues).\n\n## License\n\nMIT, see [LICENSE](./LICENSE)\n",
  "readmeFilename": "README.md",
  "_id": "async-lock@1.1.0",
  "_shasum": "48177561d47f81b286309598e908a825bb02082a",
  "_resolved": "https://registry.npmjs.org/async-lock/-/async-lock-1.1.0.tgz",
  "_from": "https://registry.npmjs.org/async-lock/-/async-lock-1.1.0.tgz"
}
